<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Android," />





  <link rel="alternate" href="/atom.xml" title="Raycco's Notes" type="application/atom+xml" />






<meta name="description" content="从前面AudioFlinger启动知道，其运行在audioserver进程，而创建AudioTrack一般在APP端创建，APP一般运行在单独的进程，所以这里说AudioTrack到AudioFlinger数据传输，其实也是两个进程之间数据传输，这篇笔记就记录了AudioTrack是怎么将Audio数据转移到AudioFlinger的。 通信模型在AudioTrack和AudioFlinger通信">
<meta name="keywords" content="Android">
<meta property="og:type" content="article">
<meta property="og:title" content="AudioTrack到AudioFlinger数据传输：共享内存">
<meta property="og:url" content="http://yoursite.com/2017/12/28/AudioTrack到AudioFlinger数据传输/index.html">
<meta property="og:site_name" content="Raycco&#39;s Notes">
<meta property="og:description" content="从前面AudioFlinger启动知道，其运行在audioserver进程，而创建AudioTrack一般在APP端创建，APP一般运行在单独的进程，所以这里说AudioTrack到AudioFlinger数据传输，其实也是两个进程之间数据传输，这篇笔记就记录了AudioTrack是怎么将Audio数据转移到AudioFlinger的。 通信模型在AudioTrack和AudioFlinger通信">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://i.imgur.com/uFXUT2x.png">
<meta property="og:image" content="https://i.imgur.com/azF90j1.png">
<meta property="og:image" content="https://i.imgur.com/fWwABNR.png">
<meta property="og:image" content="https://i.imgur.com/RATRreG.png">
<meta property="og:image" content="https://i.imgur.com/Ws4jiXt.png">
<meta property="og:image" content="https://i.imgur.com/z0xTk2d.png">
<meta property="og:updated_time" content="2018-01-25T12:11:53.058Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="AudioTrack到AudioFlinger数据传输：共享内存">
<meta name="twitter:description" content="从前面AudioFlinger启动知道，其运行在audioserver进程，而创建AudioTrack一般在APP端创建，APP一般运行在单独的进程，所以这里说AudioTrack到AudioFlinger数据传输，其实也是两个进程之间数据传输，这篇笔记就记录了AudioTrack是怎么将Audio数据转移到AudioFlinger的。 通信模型在AudioTrack和AudioFlinger通信">
<meta name="twitter:image" content="https://i.imgur.com/uFXUT2x.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/12/28/AudioTrack到AudioFlinger数据传输/"/>





  <title>AudioTrack到AudioFlinger数据传输：共享内存 | Raycco's Notes</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Raycco's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Quick Notes</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/28/AudioTrack到AudioFlinger数据传输/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Raycco">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Raycco's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">AudioTrack到AudioFlinger数据传输：共享内存</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-28T15:49:05+08:00">
                2017-12-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android-Audio/" itemprop="url" rel="index">
                    <span itemprop="name">Android Audio</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/12/28/AudioTrack到AudioFlinger数据传输/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/12/28/AudioTrack到AudioFlinger数据传输/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/12/28/AudioTrack到AudioFlinger数据传输/" class="leancloud_visitors" data-flag-title="AudioTrack到AudioFlinger数据传输：共享内存">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>从前面AudioFlinger启动知道，其运行在audioserver进程，而创建AudioTrack一般在APP端创建，APP一般运行在单独的进程，所以这里说AudioTrack到AudioFlinger数据传输，其实也是两个进程之间数据传输，这篇笔记就记录了AudioTrack是怎么将Audio数据转移到AudioFlinger的。</p>
<h2 id="通信模型"><a href="#通信模型" class="headerlink" title="通信模型"></a>通信模型</h2><p>在AudioTrack和AudioFlinger通信过程中，有两种情形：MODE_STATIC和MODE_STREAM。</p>
<p>MODE_STATIC主要针对数据量较小及延迟要求高的音频，比如短促的游戏音乐，这种情况下，共享内存的创建在Client进程，且一般也不会动态处理这段buffer，AudioTrack会一次性将数据通过共享内存传递到AudioFlinger。</p>
<p>MODE_STREAM适用于大多数应用场景，是Android主要的音频播放方式，如下图，就是MODE_STREAM模式下，AudioTrack到AudioFlinger数据传输的模式，同样使用共享内存，且是环形buffer，通过生产者-消费者模式进行数据传输。与MODE_STATIC的主要区别在于共享内存的创建方式及对共享内存的控制方式不太一样。<br><img src="https://i.imgur.com/uFXUT2x.png" alt=""></p>
<h2 id="共享内存控制块"><a href="#共享内存控制块" class="headerlink" title="共享内存控制块"></a>共享内存控制块</h2><p>对于共享内存的通信方式，涉及到两个进程对于共享内存的读写，这就会有进程间的同步，所以共享内存控制块起着关键性的作用，所以下面我们看看其定义：frameworks/av/include/private/media/AudioTrackShared.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// for audio_track_cblk_t::mFlags</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CBLK_UNDERRUN   0x01 <span class="comment">// set by server immediately on output underrun, cleared by client</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CBLK_FORCEREADY 0x02 <span class="comment">// set: track is considered ready immediately by AudioFlinger,</span></span></div><div class="line">                             <span class="comment">// clear: track is ready when buffer full</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CBLK_INVALID    0x04 <span class="comment">// track buffer invalidated by AudioFlinger, need to re-create</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CBLK_DISABLED   0x08 <span class="comment">// output track disabled by AudioFlinger due to underrun,</span></span></div><div class="line">                             <span class="comment">// need to re-start.  Unlike CBLK_UNDERRUN, this is not set</span></div><div class="line">                             <span class="comment">// immediately, but only after a long string of underruns.</span></div><div class="line"><span class="comment">// 0x10 unused</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CBLK_LOOP_CYCLE 0x20 <span class="comment">// set by server each time a loop </span></span></div><div class="line">                             <span class="comment">// cycle other than final one completes</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CBLK_LOOP_FINAL 0x40 <span class="comment">// set by server when the final loop cycle completes</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CBLK_BUFFER_END 0x80 <span class="comment">// set by server when the position </span></span></div><div class="line">                             <span class="comment">// reaches end of buffer if not looping</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CBLK_OVERRUN   0x100 <span class="comment">// set by server immediately on input overrun, cleared by client</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CBLK_INTERRUPT 0x200 <span class="comment">// set by client on interrupt(), cleared by client in obtainBuffer()</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CBLK_STREAM_END_DONE 0x400 <span class="comment">// set by server on render completion, cleared by client</span></span></div></pre></td></tr></table></figure></p>
<p>如上是对于传输的状态的定义。</p>
<ul>
<li>CBLK_UNDERRUN：AudioTrack写入数据的速度跟不上AudioFlinger读取数据的速度，使得 AudioFlinger不能及时获取到预期的数据量，反映到现实的后果就是声音断续；这种情况的根本原因大多是应用程序不能及时写入数据或者缓冲区分配过小，AudioTrack本身并没有错；AudioFlinger针对这点做了容错处理：当发现underrun时，先陷入短时间的睡眠，不急着读取数据，让应用程序准备更多的数据。</li>
<li>CBLK_OVERRUN：刚好和CBLK_UNDERRUN相反，主要对于AudioRecord，底层写数据的速度太快，AudioRecord读取数据比较慢，数据传输就会处于超负荷的运行。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Important: do not add any virtual methods, including ~</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">audio_track_cblk_t</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">                <span class="comment">// Since the control block is always located in shared memory, this constructor</span></div><div class="line">                <span class="comment">// is only used for placement new(). It is never used for regular new() or stack.</span></div><div class="line">                            <span class="keyword">audio_track_cblk_t</span>();</div><div class="line">                <span class="comment">/*virtual*/</span> ~<span class="keyword">audio_track_cblk_t</span>() &#123; &#125;</div><div class="line">                ......               <span class="comment">// friend classes of Proxy</span></div><div class="line">    <span class="comment">// The data members are grouped so that members accessed frequently and in the same context</span></div><div class="line">    <span class="comment">// are in the same line of data cache.</span></div><div class="line">                <span class="keyword">uint32_t</span>    mServer; <span class="comment">// Number of filled frames consumed by server (mIsOut),</span></div><div class="line">                                     <span class="comment">// or filled frames provided by server (!mIsOut).</span></div><div class="line">                                     <span class="comment">// It is updated asynchronously by server without </span></div><div class="line">                                     <span class="comment">// a barrier. The value should be used</span></div><div class="line">                                     <span class="comment">// "for entertainment purposes only",</span></div><div class="line">                                     <span class="comment">// which means don't make important decisions based on it.</span></div><div class="line">    <span class="keyword">volatile</span>    <span class="keyword">int32_t</span>     mFutex;  <span class="comment">// event flag: down (P) by client,</span></div><div class="line">                                     <span class="comment">// up (V) by server or binderDied() or interrupt()</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CBLK_FUTEX_WAKE 1        <span class="comment">// if event flag bit is set, then a deferred wake is pending</span></span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">                <span class="comment">// This field should be a size_t, but since it is located in shared </span></div><div class="line">                <span class="comment">// memory we force to 32-bit. The client and server may have </span></div><div class="line">                <span class="comment">// different typedefs for size_t.</span></div><div class="line">                <span class="keyword">uint32_t</span>    mMinimum;    <span class="comment">// server wakes up client if available &gt;= mMinimum</span></div><div class="line">                <span class="comment">// Stereo gains for AudioTrack only, not used by AudioRecord.</span></div><div class="line">                <span class="keyword">gain_minifloat_packed_t</span> mVolumeLR;</div><div class="line">                <span class="keyword">uint32_t</span>    mSampleRate; <span class="comment">// AudioTrack only: client's requested </span></div><div class="line">                                         <span class="comment">// sample rate in Hz or 0 == default. </span></div><div class="line">                                         <span class="comment">// Write-only client, read-only server.</span></div><div class="line">                PlaybackRateQueue::Shared mPlaybackRateQueue;</div><div class="line">                <span class="comment">// client write-only, server read-only</span></div><div class="line">                <span class="keyword">uint16_t</span>    mSendLevel;      <span class="comment">// Fixed point U4.12 so 0x1000 means 1.0</span></div><div class="line">                <span class="comment">// server write-only, client read</span></div><div class="line">                ExtendedTimestampQueue::Shared mExtendedTimestampQueue;</div><div class="line">                <span class="comment">// This is set by AudioTrack.setBufferSizeInFrames().</span></div><div class="line">                <span class="comment">// A write will not fill the buffer above this limit.</span></div><div class="line">    <span class="keyword">volatile</span>    <span class="keyword">uint32_t</span>   mBufferSizeInFrames;  <span class="comment">// effective size of the buffer</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">volatile</span>    <span class="keyword">int32_t</span>     mFlags;         <span class="comment">// combinations of CBLK_*</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">                <span class="keyword">union</span> &#123;</div><div class="line">                    AudioTrackSharedStreaming   mStreaming;</div><div class="line">                    AudioTrackSharedStatic      mStatic;</div><div class="line">                    <span class="keyword">int</span>                         mAlign[<span class="number">8</span>];</div><div class="line">                &#125; u;</div><div class="line">                <span class="comment">// Cache line boundary (32 bytes)</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>我们比较关注的mFutex，用于进程的同步，mMinimum唤醒server最小值，mFlags标记当前传输处于什么样的状态，没有直接看到环形buffer相关控制变量，但是有一个联合体。</p>
<p>对于MODE_STREAM：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AudioTrackSharedStreaming</span> &#123;</span></div><div class="line">    <span class="comment">// similar to NBAIO MonoPipe</span></div><div class="line">    <span class="comment">// in continuously incrementing frame units, take modulo buffer size, </span></div><div class="line">    <span class="comment">// which must be a power of 2</span></div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span> mFront;    <span class="comment">// read by consumer (output: server, input: client)</span></div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span> mRear;     <span class="comment">// written by producer (output: client, input: server)</span></div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span> mFlush;    <span class="comment">// incremented by client to indicate a request to flush;</span></div><div class="line">                                <span class="comment">// server notices and discards all data between mFront and mRear</span></div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">uint32_t</span> mUnderrunFrames; <span class="comment">// server increments for each unavailable </span></div><div class="line">                                       <span class="comment">// but desired frame</span></div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">uint32_t</span> mUnderrunCount;  <span class="comment">// server increments for each underrun occurrence</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="共享内存的创建"><a href="#共享内存的创建" class="headerlink" title="共享内存的创建"></a>共享内存的创建</h2><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p>首先通过时序图看看匿名共享内存的创建过程，对于MODE_STREAM，匿名共享内创建在AudioFlinger中，即在audioserver中，其中会通过Binder通信将创建好的共享内存随Track的返回而返回到AudioTrack的client中，通过获取共享内存地址再重新映射到client进程，这样两个进程就可以操作这块内存传输数据了。<br><img src="https://i.imgur.com/azF90j1.png" alt=""></p>
<h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><p>看完时序图，大致看看源代码，看看其创建过程。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">status_t</span> AudioTrack::<span class="built_in">set</span>(</div><div class="line">        ......</div><div class="line">        <span class="keyword">const</span> sp&lt;IMemory&gt;&amp; sharedBuffer,</div><div class="line">        ......)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    mSharedBuffer = sharedBuffer;</div><div class="line">    ......</div><div class="line">    <span class="comment">// create the IAudioTrack</span></div><div class="line">    <span class="keyword">status_t</span> status = createTrack_l();</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在创建AudioTrack的时候，有一个比较重要的参数sharedBuffer，这个参数决定了创建共享内存的进程，若为空，则会在AudioFlinger创建，否则在创建AudioTrack之前就创建。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">status_t</span> AudioTrack::createTrack_l()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">const</span> sp&lt;IAudioFlinger&gt;&amp; audioFlinger = AudioSystem::get_audio_flinger();</div><div class="line">    ......</div><div class="line">    <span class="keyword">audio_io_handle_t</span> output;</div><div class="line">    <span class="keyword">audio_stream_type_t</span> streamType = mStreamType;</div><div class="line">    ......</div><div class="line">    status = AudioSystem::getOutputForAttr(attr, &amp;output,</div><div class="line">                                           mSessionId, &amp;streamType, mClientUid,</div><div class="line">                                           &amp;config,</div><div class="line">                                           mFlags, mSelectedDeviceId, &amp;mPortId);</div><div class="line">    ......</div><div class="line">    sp&lt;IAudioTrack&gt; track = audioFlinger-&gt;createTrack(streamType,</div><div class="line">                                                      mSampleRate,</div><div class="line">                                                      mFormat,</div><div class="line">                                                      mChannelMask,</div><div class="line">                                                      &amp;temp,</div><div class="line">                                                      &amp;flags,</div><div class="line">                                                      mSharedBuffer,</div><div class="line">                                                      output,</div><div class="line">                                                      mClientPid,</div><div class="line">                                                      tid,</div><div class="line">                                                      &amp;mSessionId,</div><div class="line">                                                      mClientUid,</div><div class="line">                                                      &amp;status,</div><div class="line">                                                      mPortId);</div><div class="line">    ......</div><div class="line">    sp&lt;IMemory&gt; iMem = track-&gt;getCblk(); <span class="comment">// 这里获取整个匿名共享内存IMemory</span></div><div class="line">    ......</div><div class="line">    <span class="keyword">void</span> *iMemPointer = iMem-&gt;pointer(); <span class="comment">// 映射匿名共享内存到当前进程，获取共享内存首地址</span></div><div class="line">    ......</div><div class="line">    mAudioTrack = track; <span class="comment">// 保存AudioFlinger::PlaybackThread::Track的代理对象 IAudioTrack</span></div><div class="line">    mCblkMemory = iMem;  <span class="comment">// 保存匿名共享内存</span></div><div class="line"></div><div class="line">    <span class="comment">// 控制块位于匿名共享内存的首部</span></div><div class="line">    <span class="keyword">audio_track_cblk_t</span>* cblk = <span class="keyword">static_cast</span>&lt;<span class="keyword">audio_track_cblk_t</span>*&gt;(iMemPointer);</div><div class="line">    mCblk = cblk;</div><div class="line">    ......</div><div class="line">    <span class="keyword">void</span>* buffers;</div><div class="line">    <span class="keyword">if</span> (mSharedBuffer == <span class="number">0</span>) &#123;</div><div class="line">        buffers = cblk + <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        buffers = mSharedBuffer-&gt;pointer();</div><div class="line">        <span class="keyword">if</span> (buffers == <span class="literal">NULL</span>) &#123;</div><div class="line">            ALOGE(<span class="string">"Could not get buffer pointer"</span>);</div><div class="line">            <span class="keyword">return</span> NO_INIT;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">    mServer = <span class="number">0</span>;</div><div class="line">    <span class="comment">// update proxy</span></div><div class="line">    <span class="keyword">if</span> (mSharedBuffer == <span class="number">0</span>) &#123;</div><div class="line">        mStaticProxy.clear();</div><div class="line">        <span class="comment">// 当mSharedBuffer为空，意味着音轨数据模式为MODE_STREAM，那么创建</span></div><div class="line">        <span class="comment">// AudioTrackClientProxy对象</span></div><div class="line">        mProxy = <span class="keyword">new</span> AudioTrackClientProxy(cblk, buffers, frameCount, mFrameSize);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 当mSharedBuffer非空，意味着音轨数据模式为MODE_STATIC，那么创建</span></div><div class="line">        <span class="comment">// StaticAudioTrackClientProxy对象</span></div><div class="line">        mStaticProxy = <span class="keyword">new</span> StaticAudioTrackClientProxy(cblk, buffers, frameCount, mFrameSize);</div><div class="line">        mProxy = mStaticProxy;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在AudioPolicyService启动的时候在AudioPolicyService中会保存着与放音线程PlaybackThread对应的output，这里首先通过streamType等参数获取audio_io_handle_t代表的output，然后进入AudioFlinger创建IAudioTrack。通过IAudioTrack获取整个匿名共享内存IMemory，然后再映射匿名共享内存到当前进程，保存到mCblkMemory，mCblkMemory的首部是匿名共享内存控制块audio_track_cblk_t，最后创建AudioTrackClientProxy，后续通过AudioTrackClientProxy操作共享内存写数据。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/av/services/audioflinger/AudioFlinger.cpp</span></div><div class="line">sp&lt;IAudioTrack&gt; AudioFlinger::createTrack(</div><div class="line">        ......</div><div class="line">        <span class="keyword">const</span> sp&lt;IMemory&gt;&amp; sharedBuffer,</div><div class="line">        <span class="keyword">audio_io_handle_t</span> output,</div><div class="line">        ......)</div><div class="line">&#123;</div><div class="line">    sp&lt;PlaybackThread::Track&gt; track;</div><div class="line">    sp&lt;TrackHandle&gt; trackHandle;</div><div class="line">    sp&lt;Client&gt; client;</div><div class="line">    ......</div><div class="line">    &#123;</div><div class="line">        Mutex::Autolock _l(mLock);</div><div class="line">        <span class="comment">// 根据传入来的audio_io_handle_t，找到对应的PlaybackThread</span></div><div class="line">        PlaybackThread *thread = checkPlaybackThread_l(output);</div><div class="line">        <span class="keyword">if</span> (thread == <span class="literal">NULL</span>) &#123;</div><div class="line">            ALOGE(<span class="string">"no playback thread found for output handle %d"</span>, output);</div><div class="line">            lStatus = BAD_VALUE;</div><div class="line">            <span class="keyword">goto</span> Exit;</div><div class="line">        &#125;</div><div class="line">        client = registerPid(pid);</div><div class="line">        ......</div><div class="line">        track = thread-&gt;createTrack_l(client, streamType, sampleRate, format,</div><div class="line">                channelMask, frameCount, sharedBuffer, lSessionId, flags, tid,</div><div class="line">                clientUid, &amp;lStatus, portId);</div><div class="line">        ......</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// return handle to client</span></div><div class="line">    trackHandle = <span class="keyword">new</span> TrackHandle(track);<span class="comment">// 创建Track的代理TrackHandle并返回</span></div><div class="line">Exit:</div><div class="line">    *status = lStatus;</div><div class="line">    <span class="keyword">return</span> trackHandle;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在AudioFlinger中首先根据audio_io_handle_t找到相应的放音线程PlaybackThread，创建Client保存对应的客户端，在PlaybackThread中创建Track，最后创建Track的代理TrackHandle并返回到AudioTrack。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/av/services/audioflinger/Threads.cpp</span></div><div class="line">sp&lt;AudioFlinger::PlaybackThread::Track&gt; AudioFlinger::PlaybackThread::createTrack_l(</div><div class="line">        <span class="keyword">const</span> sp&lt;AudioFlinger::Client&gt;&amp; client,</div><div class="line">        ......</div><div class="line">        <span class="keyword">const</span> sp&lt;IMemory&gt;&amp; sharedBuffer,</div><div class="line">        ......)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">size_t</span> frameCount = *pFrameCount;</div><div class="line">    sp&lt;Track&gt; track;</div><div class="line">    <span class="keyword">status_t</span> lStatus;</div><div class="line">    ......</div><div class="line">    <span class="comment">// For normal PCM streaming tracks, update minimum frame count.</span></div><div class="line">    <span class="comment">// For compatibility with AudioTrack calculation, buffer depth is forced</span></div><div class="line">    <span class="comment">// to be at least 2 x the normal mixer frame count and cover audio hardware latency.</span></div><div class="line">    <span class="comment">// This is probably too conservative, but legacy application code may depend on it.</span></div><div class="line">    <span class="comment">// If you change this calculation, also review the start threshold which is related.</span></div><div class="line">    <span class="keyword">if</span> (!(*flags &amp; AUDIO_OUTPUT_FLAG_FAST)</div><div class="line">            &amp;&amp; audio_has_proportional_frames(format) &amp;&amp; sharedBuffer == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// this must match AudioTrack.cpp calculateMinFrameCount().</span></div><div class="line">        <span class="comment">// <span class="doctag">TODO:</span> Move to a common library</span></div><div class="line">        <span class="keyword">uint32_t</span> latencyMs = <span class="number">0</span>;</div><div class="line">        lStatus = mOutput-&gt;stream-&gt;getLatency(&amp;latencyMs);</div><div class="line">        <span class="keyword">if</span> (lStatus != OK) &#123;</div><div class="line">            ALOGE(<span class="string">"Error when retrieving output stream latency: %d"</span>, lStatus);</div><div class="line">            <span class="keyword">goto</span> Exit;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">uint32_t</span> minBufCount = latencyMs / ((<span class="number">1000</span> * mNormalFrameCount) / mSampleRate);</div><div class="line">        <span class="keyword">if</span> (minBufCount &lt; <span class="number">2</span>) &#123;</div><div class="line">            minBufCount = <span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// For normal mixing tracks, if speed is &gt; 1.0f (normal), AudioTrack</span></div><div class="line">        <span class="comment">// or the client should compute and pass in a larger buffer request.</span></div><div class="line">        <span class="keyword">size_t</span> minFrameCount =</div><div class="line">                minBufCount * sourceFramesNeededWithTimestretch(</div><div class="line">                        sampleRate, mNormalFrameCount,</div><div class="line">                        mSampleRate, AUDIO_TIMESTRETCH_SPEED_NORMAL <span class="comment">/*speed*/</span>);</div><div class="line">        <span class="keyword">if</span> (frameCount &lt; minFrameCount) &#123; <span class="comment">// including frameCount == 0</span></div><div class="line">            frameCount = minFrameCount;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">    &#123; <span class="comment">// scope for mLock</span></div><div class="line">        Mutex::Autolock _l(mLock);</div><div class="line">        ......</div><div class="line">        track = <span class="keyword">new</span> Track(<span class="keyword">this</span>, client, streamType, sampleRate, format,</div><div class="line">                          channelMask, frameCount, <span class="literal">NULL</span>, sharedBuffer,</div><div class="line">                          sessionId, uid, *flags, TrackBase::TYPE_DEFAULT, portId);</div><div class="line">        ......</div><div class="line">    &#125;</div><div class="line">    lStatus = NO_ERROR;</div><div class="line">Exit:</div><div class="line">    *status = lStatus;</div><div class="line">    <span class="keyword">return</span> track;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据HAL的参数获取延迟latencyMs，mNormalFrameCount是在放音线程PlaybackThread创建时，预先初始化的frame count，根据这两个值得出播放当前音频需要的最小的buffer count，继而的到最小的frame count，然后创建Track。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/av/services/audioflinger/Tracks.cpp</span></div><div class="line">AudioFlinger::PlaybackThread::Track::Track(</div><div class="line">            PlaybackThread *thread,</div><div class="line">            <span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</div><div class="line">            <span class="keyword">audio_stream_type_t</span> streamType,</div><div class="line">            <span class="keyword">uint32_t</span> sampleRate,</div><div class="line">            <span class="keyword">audio_format_t</span> format,</div><div class="line">            <span class="keyword">audio_channel_mask_t</span> channelMask,</div><div class="line">            <span class="keyword">size_t</span> frameCount,</div><div class="line">            <span class="keyword">void</span> *buffer,</div><div class="line">            <span class="keyword">const</span> sp&lt;IMemory&gt;&amp; sharedBuffer,</div><div class="line">            <span class="keyword">audio_session_t</span> sessionId,</div><div class="line">            <span class="keyword">uid_t</span> uid,</div><div class="line">            <span class="keyword">audio_output_flags_t</span> flags,</div><div class="line">            track_type type,</div><div class="line">            <span class="keyword">audio_port_handle_t</span> portId)</div><div class="line">    :   TrackBase(thread, client, sampleRate, format, channelMask, frameCount,</div><div class="line">                  (sharedBuffer != <span class="number">0</span>) ? sharedBuffer-&gt;pointer() : buffer,</div><div class="line">                  sessionId, uid, <span class="literal">true</span> <span class="comment">/*isOut*/</span>, (type == TYPE_PATCH) ? </div><div class="line">                  ( buffer == <span class="literal">NULL</span> ? ALLOC_LOCAL : ALLOC_NONE) : ALLOC_CBLK,</div><div class="line">                  type, portId),</div><div class="line">    mFillingUpStatus(FS_INVALID),</div><div class="line">    <span class="comment">// mRetryCount initialized later when needed</span></div><div class="line">    mSharedBuffer(sharedBuffer),</div><div class="line">    ......</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    <span class="keyword">if</span> (sharedBuffer == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 数据传输模式为MODE_STREAM模式，创建一个AudioTrackServerProxy对象</span></div><div class="line">        <span class="comment">// PlaybackThread将持续使用它从环形buffer上取得可读数据的位置</span></div><div class="line">        mAudioTrackServerProxy = <span class="keyword">new</span> AudioTrackServerProxy(mCblk, mBuffer, frameCount,</div><div class="line">                mFrameSize, !isExternalTrack(), sampleRate);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Is the shared buffer of sufficient size?</span></div><div class="line">        <span class="comment">// (frameCount * mFrameSize) is &lt;= SIZE_MAX, checked in TrackBase.</span></div><div class="line">        <span class="keyword">if</span> (sharedBuffer-&gt;size() &lt; frameCount * mFrameSize) &#123;</div><div class="line">            <span class="comment">// Workaround: clear out mCblk to indicate track hasn't been properly created.</span></div><div class="line">            mCblk-&gt;~<span class="keyword">audio_track_cblk_t</span>();   <span class="comment">// destroy our shared-structure.</span></div><div class="line">            <span class="keyword">if</span> (mClient == <span class="number">0</span>) &#123;</div><div class="line">                <span class="built_in">free</span>(mCblk);</div><div class="line">            &#125;</div><div class="line">            mCblk = <span class="literal">NULL</span>;</div><div class="line">            mSharedBuffer.clear(); <span class="comment">// release shared buffer early</span></div><div class="line">            android_errorWriteLog(<span class="number">0x534e4554</span>, <span class="string">"38340117"</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 数据传输模式为MODE_STATIC模式，创建一个StaticAudioTrackServerProxy对象</span></div><div class="line">        mAudioTrackServerProxy = <span class="keyword">new</span> StaticAudioTrackServerProxy(mCblk, mBuffer, frameCount,</div><div class="line">                mFrameSize);</div><div class="line">    &#125;</div><div class="line">    mServerProxy = mAudioTrackServerProxy;</div><div class="line">    ......</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// frameworks/av/services/audioflinger/Tracks.cpp</span></div><div class="line">AudioFlinger::ThreadBase::TrackBase::TrackBase(</div><div class="line">            ThreadBase *thread,</div><div class="line">            <span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</div><div class="line">            <span class="keyword">uint32_t</span> sampleRate,</div><div class="line">            <span class="keyword">audio_format_t</span> format,</div><div class="line">            <span class="keyword">audio_channel_mask_t</span> channelMask,</div><div class="line">            <span class="keyword">size_t</span> frameCount,</div><div class="line">            <span class="keyword">void</span> *buffer,</div><div class="line">            <span class="keyword">audio_session_t</span> sessionId,</div><div class="line">            <span class="keyword">uid_t</span> clientUid,</div><div class="line">            <span class="keyword">bool</span> isOut,</div><div class="line">            alloc_type alloc,</div><div class="line">            track_type type,</div><div class="line">            <span class="keyword">audio_port_handle_t</span> portId)</div><div class="line">    :   RefBase(),</div><div class="line">        mThread(thread),</div><div class="line">        mClient(client),</div><div class="line">        mFrameSize(audio_has_proportional_frames(format) ?</div><div class="line">                mChannelCount * audio_bytes_per_sample(format) : <span class="keyword">sizeof</span>(<span class="keyword">int8_t</span>))</div><div class="line">        ......</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    <span class="keyword">size_t</span> bufferSize = buffer == <span class="literal">NULL</span> ? roundup(frameCount) : frameCount;</div><div class="line">    bufferSize *= mFrameSize;</div><div class="line">    <span class="keyword">size_t</span> size = <span class="keyword">sizeof</span>(<span class="keyword">audio_track_cblk_t</span>);</div><div class="line">    <span class="keyword">if</span> (buffer == <span class="literal">NULL</span> &amp;&amp; alloc == ALLOC_CBLK) &#123;</div><div class="line">        <span class="comment">// check overflow when computing allocation size for streaming tracks.</span></div><div class="line">        <span class="keyword">if</span> (size &gt; SIZE_MAX - bufferSize) &#123;</div><div class="line">            android_errorWriteLog(<span class="number">0x534e4554</span>, <span class="string">"34749571"</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        size += bufferSize;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (client != <span class="number">0</span>) &#123;</div><div class="line">        mCblkMemory = client-&gt;heap()-&gt;allocate(size); <span class="comment">// 创建共享内存并映射当前进程</span></div><div class="line">        <span class="keyword">if</span> (mCblkMemory == <span class="number">0</span> ||</div><div class="line">                (mCblk = <span class="keyword">static_cast</span>&lt;<span class="keyword">audio_track_cblk_t</span> *&gt;(mCblkMemory-&gt;pointer())) == <span class="literal">NULL</span>) &#123;</div><div class="line">            ALOGE(<span class="string">"not enough memory for AudioTrack size=%zu"</span>, size);</div><div class="line">            client-&gt;heap()-&gt;dump(<span class="string">"AudioTrack"</span>);</div><div class="line">            mCblkMemory.clear();</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line">    ......</div><div class="line">    <span class="comment">// construct the shared structure in-place.</span></div><div class="line">    <span class="keyword">if</span> (mCblk != <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="comment">// 这是C++的placement new（定位创建对象）语法：new(@BUFFER) @CLASS();</span></div><div class="line">        <span class="comment">// 可以在特定内存位置上构造一个对象</span></div><div class="line">        <span class="comment">// 这里，在匿名共享内存首地址上构造了一个audio_track_cblk_ 对象</span></div><div class="line">        <span class="comment">// 这样AudioTrack与AudioFlinger都能访问这个audio_track_cblk_t对象了</span></div><div class="line">        <span class="keyword">new</span>(mCblk) <span class="keyword">audio_track_cblk_t</span>();</div><div class="line">        <span class="keyword">switch</span> (alloc) &#123;</div><div class="line">        ......</div><div class="line">        <span class="keyword">case</span> ALLOC_CBLK:</div><div class="line">            <span class="comment">// clear all buffers</span></div><div class="line">            <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>) &#123;</div><div class="line">                <span class="comment">// 数据传输模式为MODE_STREAM时，数据buffer的分配</span></div><div class="line">                <span class="comment">// 数据buffer的首地址紧靠控制块（audio_track_cblk_t）之后</span></div><div class="line">                mBuffer = (<span class="keyword">char</span>*)mCblk + <span class="keyword">sizeof</span>(<span class="keyword">audio_track_cblk_t</span>);</div><div class="line">                <span class="built_in">memset</span>(mBuffer, <span class="number">0</span>, bufferSize);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 数据传输模式为MODE_STATIC时，直接指向sharedBuffer</span></div><div class="line">                <span class="comment">// sharedBuffer是应用进程分配的匿名共享内存，应用进程已经一次性把数据</span></div><div class="line">                <span class="comment">// 写到sharedBuffer来了，AudioFlinger可以直接从这里读取</span></div><div class="line">                mBuffer = buffer;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        ......</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// system/meida/audio/include/system/audio.h</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> size_t <span class="title">audio_bytes_per_sample</span><span class="params">(<span class="keyword">audio_format_t</span> format)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">size_t</span> size = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (format) &#123;</div><div class="line">    <span class="keyword">case</span> AUDIO_FORMAT_PCM_32_BIT:</div><div class="line">    <span class="keyword">case</span> AUDIO_FORMAT_PCM_8_24_BIT:</div><div class="line">        size = <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> AUDIO_FORMAT_PCM_24_BIT_PACKED:</div><div class="line">        size = <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>) * <span class="number">3</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> AUDIO_FORMAT_PCM_16_BIT:</div><div class="line">    <span class="keyword">case</span> AUDIO_FORMAT_IEC61937:</div><div class="line">        size = <span class="keyword">sizeof</span>(<span class="keyword">int16_t</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> AUDIO_FORMAT_PCM_8_BIT:</div><div class="line">        size = <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> AUDIO_FORMAT_PCM_FLOAT:</div><div class="line">        size = <span class="keyword">sizeof</span>(<span class="keyword">float</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> size;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Track从TrackBase继承而来，所以会先执行TrackBase构造函数，mFrameSize会根据format和channel count计算而得，比如双声道，forma为AUDIO_FORMAT_PCM_16_BIT，则mFrameSize为4Byte。计算共享内存大小，其大小为控制块大小加上真正数据大小。<br>size = sizeof(audio_track_cblk_t) + framecount * mFrameSize<br>然后会创建匿名共享内存并且映射到当前进程mCblkMemory = client-&gt;heap()-&gt;allocate(size);<br>然后使用C++的placement new（定位创建对象）在匿名共享内存上创建共享内存控制块。最后将mBuffer清空，创建AudioTrackServerProxy，后续一次操作共享内存读取数据。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">sp&lt;AudioFlinger::Client&gt; AudioFlinger::registerPid(<span class="keyword">pid_t</span> pid)</div><div class="line">&#123;</div><div class="line">    Mutex::Autolock _cl(mClientLock);</div><div class="line">    <span class="comment">// If pid is already in the mClients wp&lt;&gt; map, then use that entry</span></div><div class="line">    <span class="comment">// (for which promote() is always != 0), otherwise create a new entry and Client.</span></div><div class="line">    sp&lt;Client&gt; client = mClients.valueFor(pid).promote();</div><div class="line">    <span class="keyword">if</span> (client == <span class="number">0</span>) &#123;</div><div class="line">        client = <span class="keyword">new</span> Client(<span class="keyword">this</span>, pid);</div><div class="line">        mClients.add(pid, client);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> client;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Max shared memory size for audio tracks and audio records per client process</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kClientSharedHeapSizeBytes = <span class="number">1024</span>*<span class="number">1024</span>;</div><div class="line"><span class="comment">// Shared memory size multiplier for non low ram devices</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kClientSharedHeapSizeMultiplier = <span class="number">4</span>;</div><div class="line"></div><div class="line">AudioFlinger::Client::Client(<span class="keyword">const</span> sp&lt;AudioFlinger&gt;&amp; audioFlinger, <span class="keyword">pid_t</span> pid)</div><div class="line">    :   RefBase(),</div><div class="line">        mAudioFlinger(audioFlinger),</div><div class="line">        mPid(pid)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">size_t</span> heapSize = property_get_int32(<span class="string">"ro.af.client_heap_size_kbyte"</span>, <span class="number">0</span>);</div><div class="line">    heapSize *= <span class="number">1024</span>;</div><div class="line">    <span class="keyword">if</span> (!heapSize) &#123;</div><div class="line">        heapSize = kClientSharedHeapSizeBytes;</div><div class="line">        <span class="comment">// Increase heap size on non low ram devices to limit risk of reconnection </span></div><div class="line">        <span class="comment">// failure for invalidated tracks</span></div><div class="line">        <span class="comment">// 目前一般的设备都不是RAM比较小的设备，所以一般默认申请4M内存</span></div><div class="line">        <span class="keyword">if</span> (!audioFlinger-&gt;isLowRamDevice()) &#123;</div><div class="line">            heapSize *= kClientSharedHeapSizeMultiplier;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    mMemoryDealer = <span class="keyword">new</span> MemoryDealer(heapSize, <span class="string">"AudioFlinger::Client"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建共享内存使用了Client类，client-&gt;heap()-&gt;allocate(size)，创建Client即创建内存管理接口MemoryDealer，即MemoryHeapBase。下一节分析匿名共享内存的C++接口，再具体分析匿名共享内存的管理。</p>
<h2 id="匿名共享内存C-接口"><a href="#匿名共享内存C-接口" class="headerlink" title="匿名共享内存C++接口"></a>匿名共享内存C++接口</h2><h3 id="MemoryHeapBase"><a href="#MemoryHeapBase" class="headerlink" title="MemoryHeapBase"></a>MemoryHeapBase</h3><p>MemoryHeapBase类的对象可以作为Binder对象在进程间传输，作为一个Binder对象，就有Server端对象和Client端引用的概念。下面先看Server端的实现。<br><img src="https://i.imgur.com/fWwABNR.png" alt=""><br>共同基类RefBase，主要用于智能指针的使用。在ProcessState中打开Binder驱动，IPCThreadState通过ProcessState和Binder驱动交互，当有服务请求时，会先调用IPCThreadState的transact函数，进而调用BBinder的transact函数，根据继承关系会调动BnMemoryHeap的onTransact函数，根据code决定调用具体实现函数，从而进入MemoryHeapBase。这就是一次通信在服务端的运行流程。</p>
<p>MemoryHeapBase要创建共享内存，接下来看看其中一个构造函数具体实现。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/native/libs/binder/MemoryHeapBase.cpp</span></div><div class="line">MemoryHeapBase::MemoryHeapBase(<span class="keyword">size_t</span> size, <span class="keyword">uint32_t</span> flags, <span class="keyword">char</span> <span class="keyword">const</span> * name)</div><div class="line">    : mFD(<span class="number">-1</span>), mSize(<span class="number">0</span>), mBase(MAP_FAILED), mFlags(flags),</div><div class="line">      mDevice(<span class="number">0</span>), mNeedUnmap(<span class="literal">false</span>), mOffset(<span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 获得系统中一页大小的内存</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> pagesize = getpagesize();</div><div class="line">    <span class="comment">// 内存页对齐</span></div><div class="line">    size = ((size + pagesize<span class="number">-1</span>) &amp; ~(pagesize<span class="number">-1</span>));</div><div class="line">    <span class="comment">// 创建一块匿名共享内存</span></div><div class="line">    <span class="keyword">int</span> fd = ashmem_create_region(name == <span class="literal">NULL</span> ? <span class="string">"MemoryHeapBase"</span> : name, size);</div><div class="line">    ALOGE_IF(fd&lt;<span class="number">0</span>, <span class="string">"error creating ashmem region: %s"</span>, strerror(errno));</div><div class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 将创建的匿名共享内存映射到当前进程地址空间中</span></div><div class="line">        <span class="keyword">if</span> (mapfd(fd, size) == NO_ERROR) &#123;</div><div class="line">            <span class="comment">// 如果地址映射成功，修改匿名共享内存的访问属性</span></div><div class="line">            <span class="keyword">if</span> (flags &amp; READ_ONLY) &#123;</div><div class="line">                ashmem_set_prot_region(fd, PROT_READ);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在以上构造函数中根据参数，利用匿名共享内存提供的C语言接口创建一块匿名共享内存，并映射到当前进程的虚拟地址空间，参数size是指定匿名共享内存的大小，flags指定匿名共享内存的访问属性，name指定匿名共享内存的名称，如果没有指定名称，默认命名为MemoryHeapBase。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/native/libs/binder/MemoryHeapBase.cpp</span></div><div class="line"><span class="keyword">status_t</span> MemoryHeapBase::mapfd(<span class="keyword">int</span> fd, <span class="keyword">size_t</span> size, <span class="keyword">uint32_t</span> offset)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// try to figure out the size automatically</span></div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></div><div class="line">        <span class="keyword">if</span> (fstat(fd, &amp;sb) == <span class="number">0</span>)</div><div class="line">            size = sb.st_size;</div><div class="line">        <span class="comment">// if it didn't work, let mmap() fail.</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> ((mFlags &amp; DONT_MAP_LOCALLY) == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 通过mmap系统调用进入内核空间的匿名共享内存驱动，</span></div><div class="line">        <span class="comment">// 并调用ashmem_mmap函数将匿名共享内存映射到当前进程</span></div><div class="line">        <span class="keyword">void</span>* base = (<span class="keyword">uint8_t</span>*)mmap(<span class="number">0</span>, size,</div><div class="line">                PROT_READ|PROT_WRITE, MAP_SHARED, fd, offset);</div><div class="line">        <span class="keyword">if</span> (base == MAP_FAILED) &#123;</div><div class="line">            ALOGE(<span class="string">"mmap(fd=%d, size=%u) failed (%s)"</span>,</div><div class="line">                    fd, <span class="keyword">uint32_t</span>(size), strerror(errno));</div><div class="line">            close(fd);</div><div class="line">            <span class="keyword">return</span> -errno;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//ALOGD("mmap(fd=%d, base=%p, size=%lu)", fd, base, size);</span></div><div class="line">        mBase = base;</div><div class="line">        mNeedUnmap = <span class="literal">true</span>;</div><div class="line">    &#125; <span class="keyword">else</span>  &#123;</div><div class="line">        mBase = <span class="number">0</span>; <span class="comment">// not MAP_FAILED</span></div><div class="line">        mNeedUnmap = <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    mFD = fd;</div><div class="line">    mSize = size;</div><div class="line">    mOffset = offset;</div><div class="line">    <span class="keyword">return</span> NO_ERROR;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>mmap函数的第一个参数0表示由内核来决定这个匿名共享内存文件在进程地址空间的起始位置，第二个参数size表示要映射的匿名共享内文件的大小，第三个参数PROT_READ|PROT_WRITE表示这个匿名共享内存是可读写的，第四个参数fd指定要映射的匿名共享内存的文件描述符，第五个参数offset表示要从这个文件的哪个偏移位置开始映射。调用了这个函数之后，最后会进入到内核空间的ashmem驱动程序模块中去执行ashmem_mmap函数，调用mmap函数返回之后，就得这块匿名共享内存在本进程地址空间中的起始访问地址了，将这个地址保存在成员变量mBase中，最后，还将这个匿名共享内存的文件描述符和以及大小分别保存在成员变量mFD和mSize，并提供了相应接口函数来访问这些变量值。通过构造MemoryHeapBase对象就可以创建一块匿名共享内存，或者映射一块已经创建的匿名共享内存到当前进程的地址空间。</p>
<p>接下来我们再来看一下MemoryHeapBase在Client端实现。<br><img src="https://i.imgur.com/RATRreG.png" alt=""><br>在和匿名共享内存操作相关的类中，BpMemoryHeap类是前面分析的MemoryHeapBase类在Client端进程的远接接口类，当Client端进程从Service Manager或者其它途径获得了一个MemoryHeapBase对象的引用之后，就会在本地创建一个BpMemoryHeap对象来代表这个引用。BpMemoryHeap类同样是要实现IMemoryHeap接口，Client端将调用传递给BpMemoryHeap，BpMemoryHeap的基类BpRefBase有一个mRemote对象，指向BpBinder,所以通过调用BpBinder的transact函数进而调用IPCThreadState，将请求传递给Server端。</p>
<p>BpMemoryHeap的声明如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/native/libs/binder/IMemory.cpp</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BpMemoryHeap</span> :</span> <span class="keyword">public</span> BpInterface&lt;IMemoryHeap&gt;</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BpMemoryHeap</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; impl)</span></span>;</div><div class="line">    <span class="keyword">virtual</span> ~BpMemoryHeap();</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getHeapID</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>* <span class="title">getBase</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> size_t <span class="title">getSize</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> uint32_t <span class="title">getFlags</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> uint32_t <span class="title">getOffset</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">IMemory</span>;</span></div><div class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapCache</span>;</span></div><div class="line">    <span class="comment">// for debugging in this module</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> sp&lt;IMemoryHeap&gt; find_heap(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder) &#123;</div><div class="line">        <span class="keyword">return</span> gHeapCache-&gt;find_heap(binder);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">free_heap</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder)</span> </span>&#123;</div><div class="line">        gHeapCache-&gt;free_heap(binder);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> sp&lt;IMemoryHeap&gt; get_heap(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder) &#123;</div><div class="line">        <span class="keyword">return</span> gHeapCache-&gt;get_heap(binder);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dump_heaps</span><span class="params">()</span> </span>&#123;</div><div class="line">        gHeapCache-&gt;dump_heaps();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">assertMapped</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">assertReallyMapped</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::atomic&lt;<span class="keyword">int32_t</span>&gt; mHeapId;</div><div class="line">    <span class="keyword">mutable</span> <span class="keyword">void</span>*       mBase;</div><div class="line">    <span class="keyword">mutable</span> <span class="keyword">size_t</span>      mSize;</div><div class="line">    <span class="keyword">mutable</span> <span class="keyword">uint32_t</span>    mFlags;</div><div class="line">    <span class="keyword">mutable</span> <span class="keyword">uint32_t</span>    mOffset;</div><div class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span>        mRealHeap;</div><div class="line">    <span class="keyword">mutable</span> Mutex       mLock;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>先来看构造函数BpMemoryHeap的实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">BpMemoryHeap::BpMemoryHeap(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; impl)</div><div class="line">    : BpInterface&lt;IMemoryHeap&gt;(impl),</div><div class="line">        mHeapId(<span class="number">-1</span>), mBase(MAP_FAILED), mSize(<span class="number">0</span>), mFlags(<span class="number">0</span>), mOffset(<span class="number">0</span>), mRealHeap(<span class="literal">false</span>)</div><div class="line">&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它的实现很简单，只是初始化一下各个成员变量，例如，表示匿名共享内存文件描述符的mHeapId值初化为-1、表示匿名内共享内存基地址的mBase值初始化为MAP_FAILED以及表示匿名共享内存大小的mSize初始为为0，它们都表示在Client端进程中，这个匿名共享内存还未准备就绪，要等到第一次使用时才会去创建。这里还需要注意的一点，参数impl指向的是一个BpBinder对象，它里面包含了一个指向Server端Binder对象，即MemoryHeapBase对象的引用。</p>
<p>以获取共享内存基地址为例，看看Client端如何获取服务端创建的共享内存。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/native/libs/binder/IMemory.cpp</span></div><div class="line"><span class="keyword">void</span>* BpMemoryHeap::getBase() <span class="keyword">const</span> &#123;</div><div class="line">    assertMapped();</div><div class="line">    <span class="keyword">return</span> mBase;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> BpMemoryHeap::assertMapped() <span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int32_t</span> heapId = mHeapId.load(memory_order_acquire);</div><div class="line">    <span class="comment">// 如果还没有请求服务创建匿名共享内存</span></div><div class="line">    <span class="keyword">if</span> (heapId == <span class="number">-1</span>) &#123;</div><div class="line">        <span class="comment">// 将当前BpMemoryHeap对象转换为IBinder对象</span></div><div class="line">        sp&lt;IBinder&gt; binder(IInterface::asBinder(<span class="keyword">const_cast</span>&lt;BpMemoryHeap*&gt;(<span class="keyword">this</span>)));</div><div class="line">        <span class="comment">// 从成员变量gHeapCache中查找对应的BpMemoryHeap对象</span></div><div class="line">        sp&lt;BpMemoryHeap&gt; heap(<span class="keyword">static_cast</span>&lt;BpMemoryHeap*&gt;(find_heap(binder).get()));</div><div class="line">        <span class="comment">// 向服务端请求获取匿名共享内存信息</span></div><div class="line">        heap-&gt;assertReallyMapped();</div><div class="line">        <span class="comment">// 判断该匿名共享内存是否映射成功</span></div><div class="line">        <span class="keyword">if</span> (heap-&gt;mBase != MAP_FAILED) &#123;</div><div class="line">            Mutex::Autolock _l(mLock);</div><div class="line">            <span class="comment">// 保存服务端返回回来的匿名共享内存信息</span></div><div class="line">            <span class="keyword">if</span> (mHeapId.load(memory_order_relaxed) == <span class="number">-1</span>) &#123;</div><div class="line">                mBase   = heap-&gt;mBase;</div><div class="line">                mSize   = heap-&gt;mSize;</div><div class="line">                mOffset = heap-&gt;mOffset;</div><div class="line">                <span class="keyword">int</span> fd = fcntl(heap-&gt;mHeapId.load(memory_order_relaxed), F_DUPFD_CLOEXEC, <span class="number">0</span>);</div><div class="line">                ALOGE_IF(fd==<span class="number">-1</span>, <span class="string">"cannot dup fd=%d"</span>,</div><div class="line">                        heap-&gt;mHeapId.load(memory_order_relaxed));</div><div class="line">                mHeapId.store(fd, memory_order_release);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// something went wrong</span></div><div class="line">            free_heap(binder);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>mHeapId等于-1，表示匿名共享内存还为准备就绪，因此请求服务端MemoryHeapBase创建匿名共享内存，否则该函数不作任何处理。只有第一次使用匿名共享时才会请求服务端创建匿名共享内存。由于在客户端进程中使用同一个BpBinder代理对象可以创建多个与匿名共享内存业务相关的BpMemoryHeap对象，因此定义了类型为HeapCache的全局变量gHeapCache用来保存创建的所有BpMemoryHeap对象，assertMapped函数首先将当前BpMemoryHeap对象强制转换为IBinder类型对象，然后调用find_heap()函数从全局变量gHeapCache中查找出对应的BpMemoryHeap对象，并调用assertReallyMapped()函数向服务进程的BnemoryHeap请求创建匿名共享内存。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/native/libs/binder/IMemory.cpp</span></div><div class="line"><span class="keyword">void</span> BpMemoryHeap::assertReallyMapped() <span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int32_t</span> heapId = mHeapId.load(memory_order_acquire);</div><div class="line">    <span class="comment">// 再次判断是否已经请求创建过匿名共享内存</span></div><div class="line">    <span class="keyword">if</span> (heapId == <span class="number">-1</span>) &#123;</div><div class="line">        <span class="comment">// remote call without mLock held, worse case scenario, we end up</span></div><div class="line">        <span class="comment">// calling transact() from multiple threads, but that's not a problem,</span></div><div class="line">        <span class="comment">// only mmap below must be in the critical section.</span></div><div class="line">        Parcel data, reply;</div><div class="line">        data.writeInterfaceToken(IMemoryHeap::getInterfaceDescriptor());</div><div class="line">        <span class="comment">// 向服务端BnMemoryHeap发起请求</span></div><div class="line">        <span class="keyword">status_t</span> err = remote()-&gt;transact(HEAP_ID, data, &amp;reply);</div><div class="line">        <span class="keyword">int</span> parcel_fd = reply.readFileDescriptor();</div><div class="line">        <span class="keyword">ssize_t</span> size = reply.readInt32();</div><div class="line">        <span class="keyword">uint32_t</span> flags = reply.readInt32();</div><div class="line">        <span class="keyword">uint32_t</span> offset = reply.readInt32();</div><div class="line">        ALOGE_IF(err, <span class="string">"binder=%p transaction failed fd=%d, size=%zd, err=%d (%s)"</span>,</div><div class="line">                IInterface::asBinder(<span class="keyword">this</span>).get(),</div><div class="line">                parcel_fd, size, err, strerror(-err));</div><div class="line">        Mutex::Autolock _l(mLock);</div><div class="line">        <span class="keyword">if</span> (mHeapId.load(memory_order_relaxed) == <span class="number">-1</span>) &#123;</div><div class="line">            <span class="keyword">int</span> fd = fcntl(parcel_fd, F_DUPFD_CLOEXEC, <span class="number">0</span>);</div><div class="line">            ALOGE_IF(fd==<span class="number">-1</span>, <span class="string">"cannot dup fd=%d, size=%zd, err=%d (%s)"</span>,</div><div class="line">                    parcel_fd, size, err, strerror(errno));</div><div class="line">            <span class="keyword">int</span> access = PROT_READ;</div><div class="line">            <span class="keyword">if</span> (!(flags &amp; READ_ONLY)) &#123;</div><div class="line">                access |= PROT_WRITE;</div><div class="line">            &#125;</div><div class="line">            mRealHeap = <span class="literal">true</span>;</div><div class="line">            <span class="comment">// 将服务进程创建的匿名共享内存映射到当前客户进程的地址空间中</span></div><div class="line">            mBase = mmap(<span class="number">0</span>, size, access, MAP_SHARED, fd, offset);</div><div class="line">            <span class="keyword">if</span> (mBase == MAP_FAILED) &#123;</div><div class="line">                ALOGE(<span class="string">"cannot map BpMemoryHeap (binder=%p), size=%zd, fd=%d (%s)"</span>,</div><div class="line">                        IInterface::asBinder(<span class="keyword">this</span>).get(), size, fd, strerror(errno));</div><div class="line">                close(fd);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 映射成功后，将匿名共享内存信息保存到BpMemoryHeap的成员变量中，供其他接口函数访问</span></div><div class="line">                mSize = size;</div><div class="line">                mFlags = flags;</div><div class="line">                mOffset = offset;</div><div class="line">                mHeapId.store(fd, memory_order_release);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该函数首先通过Binder通信方式向服务进程请求创建匿名共享内存，当服务端BnMemoryHeap对象创建完匿名共享内存后，并将共享内存信息返回到客户进程后，客户进程通过系统调用mmap函数将匿名共享内存映射到当前进程的地址空间，这样客户进程就可以访问服务进程创建的匿名共享内存了。当了解Binder通信机制，就知道BpMemoryHeap对象通过transact函数向服务端发起请求后，服务端的BnMemoryHeap的onTransact函数会被调用。</p>
<p>在上面获取共享内存的过程中，有一个类型为HeapCache的全局变量gHeapCache。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/native/libs/binder/IMemory.cpp</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapCache</span> :</span> <span class="keyword">public</span> IBinder::DeathRecipient</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    HeapCache();</div><div class="line">    <span class="keyword">virtual</span> ~HeapCache();</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">(<span class="keyword">const</span> wp&lt;IBinder&gt;&amp; who)</span></span>;</div><div class="line">    sp&lt;IMemoryHeap&gt; find_heap(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder);</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">free_heap</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder)</span></span>;</div><div class="line">    sp&lt;IMemoryHeap&gt; get_heap(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder);</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dump_heaps</span><span class="params">()</span></span>;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">// For IMemory.cpp</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">heap_info_t</span> &#123;</span></div><div class="line">        sp&lt;IMemoryHeap&gt; heap;</div><div class="line">        <span class="keyword">int32_t</span>         count;</div><div class="line">        <span class="comment">// Note that this cannot be meaningfully copied.</span></div><div class="line">    &#125;;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">free_heap</span><span class="params">(<span class="keyword">const</span> wp&lt;IBinder&gt;&amp; binder)</span></span>;</div><div class="line">    Mutex mHeapCacheLock;  <span class="comment">// Protects entire vector below.</span></div><div class="line">    KeyedVector&lt; wp&lt;IBinder&gt;, <span class="keyword">heap_info_t</span> &gt; mHeapCache;</div><div class="line">    <span class="comment">// We do not use the copy-on-write capabilities of KeyedVector.</span></div><div class="line">    <span class="comment">// <span class="doctag">TODO:</span> Reimplemement based on standard C++ container?</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">static</span> sp&lt;HeapCache&gt; gHeapCache = <span class="keyword">new</span> HeapCache();</div></pre></td></tr></table></figure></p>
<p>它里面定义了一个成员变量mHeapCache，用来维护本进程中的所有BpMemoryHeap对象，同时还提供了find_heap和get_heap函数来查找内部所维护的BpMemoryHeap对象的功能。函数find_heap和get_heap的区别是，在find_heap函数中，如果在mHeapCache找不到相应的BpMemoryHeap对象，就会把这个BpMemoryHeap对象加入到mHeapCache中去，而在get_heap函数中，则不会自动把这个BpMemoryHeap对象加入到mHeapCache中去。</p>
<p>这里，我们主要看一下find_heap函数的实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/native/libs/binder/IMemory.cpp</span></div><div class="line">sp&lt;IMemoryHeap&gt; HeapCache::find_heap(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder)</div><div class="line">&#123;</div><div class="line">    Mutex::Autolock _l(mHeapCacheLock);</div><div class="line">    <span class="keyword">ssize_t</span> i = mHeapCache.indexOfKey(binder);</div><div class="line">    <span class="keyword">if</span> (i&gt;=<span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">heap_info_t</span>&amp; info = mHeapCache.editValueAt(i);</div><div class="line">        ALOGD_IF(VERBOSE,</div><div class="line">                <span class="string">"found binder=%p, heap=%p, size=%zu, fd=%d, count=%d"</span>,</div><div class="line">                binder.get(), info.heap.get(),</div><div class="line">                <span class="keyword">static_cast</span>&lt;BpMemoryHeap*&gt;(info.heap.get())-&gt;mSize,</div><div class="line">                <span class="keyword">static_cast</span>&lt;BpMemoryHeap*&gt;(info.heap.get())</div><div class="line">                    -&gt;mHeapId.load(memory_order_relaxed),</div><div class="line">                info.count);</div><div class="line">        ++info.count;</div><div class="line">        <span class="keyword">return</span> info.heap;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">heap_info_t</span> info;</div><div class="line">        info.heap = interface_cast&lt;IMemoryHeap&gt;(binder);</div><div class="line">        info.count = <span class="number">1</span>;</div><div class="line">        <span class="comment">//ALOGD("adding binder=%p, heap=%p, count=%d",</span></div><div class="line">        <span class="comment">//      binder.get(), info.heap.get(), info.count);</span></div><div class="line">        mHeapCache.add(binder, info);</div><div class="line">        <span class="keyword">return</span> info.heap;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 这个函数很简单，首先它以传进来的参数binder为关键字，在mHeapCache中查找，看看是否有对应的heap_info对象info存在，如果有的话，就增加它的引用计数info.count值，表示这个BpBinder对象多了一个使用者；如果没有的话，那么就需要创建一个heap_info对象info，并且将它加放到mHeapCache中去了。</p>
<h3 id="MemoryBase"><a href="#MemoryBase" class="headerlink" title="MemoryBase"></a>MemoryBase</h3><p>MemoryBase接口是建立在MemoryHeapBase接口的基础上的，它们都可以作为一个Binder对象来在进程间进行数据共享，它们的关系如下所示：<br><img src="https://i.imgur.com/Ws4jiXt.png" alt=""><br>MemoryBase类包含了一个成员变量mHeap，它的类型的IMemoryHeap，MemoryBase类所代表的匿名共享内存就是通过这个成员变量来实现的。</p>
<p>MemoryBase类在Server端的实现与MemoryHeapBase类在Server端的实现是类似的，这里只要把IMemory类换成IMemoryHeap类、把BnMemory类换成BnMemoryHeap类以及MemoryBase类换成MemoryHeapBase类就变成是MemoryHeapBase类在Server端的实现了，因此，我们这里只简单分析IMemory类和MemoryBase类的实现。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">IMemory</span> :</span> <span class="keyword">public</span> IInterface</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    DECLARE_META_INTERFACE(Memory)</div><div class="line">    <span class="keyword">virtual</span> sp&lt;IMemoryHeap&gt; getMemory(<span class="keyword">ssize_t</span>* offset=<span class="number">0</span>, <span class="keyword">size_t</span>* size=<span class="number">0</span>) <span class="keyword">const</span> = <span class="number">0</span>;</div><div class="line">    <span class="comment">// helpers</span></div><div class="line">    <span class="function"><span class="keyword">void</span>* <span class="title">fastPointer</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; heap, <span class="keyword">ssize_t</span> offset)</span> <span class="keyword">const</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span>* <span class="title">pointer</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">    <span class="keyword">size_t</span> size() <span class="keyword">const</span>;</div><div class="line">    <span class="keyword">ssize_t</span> offset() <span class="keyword">const</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>成员函数getMemory用来获取内部的MemoryHeapBase对象的IMemoryHeap接口；成员函数pointer()用来获取内部所维护的匿名共享内存的基地址；成员函数size()用来获取内部所维护的匿名共享内存的大小；成员函数offset()用来获取内部所维护的这部分匿名共享内存在整个匿名共享内存中的偏移量。</p>
<p>IMemory类本身实现了pointer、size和offset三个成员函数，因此，它的子类，即MemoryBase类，只需要实现getMemory成员函数就可以了。IMemory类的实现定义在frameworks/native/libs/binder/IMemory.cpp文件中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span>* IMemory::fastPointer(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder, <span class="keyword">ssize_t</span> offset) <span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">    sp&lt;IMemoryHeap&gt; realHeap = BpMemoryHeap::get_heap(binder);</div><div class="line">    <span class="keyword">void</span>* <span class="keyword">const</span> base = realHeap-&gt;base();</div><div class="line">    <span class="keyword">if</span> (base == MAP_FAILED)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(base) + offset;</div><div class="line">&#125;</div><div class="line"><span class="keyword">void</span>* IMemory::pointer() <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">ssize_t</span> offset;</div><div class="line">    sp&lt;IMemoryHeap&gt; heap = getMemory(&amp;offset);</div><div class="line">    <span class="keyword">void</span>* <span class="keyword">const</span> base = heap!=<span class="number">0</span> ? heap-&gt;base() : MAP_FAILED;</div><div class="line">    <span class="keyword">if</span> (base == MAP_FAILED)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(base) + offset;</div><div class="line">&#125;</div><div class="line"><span class="keyword">size_t</span> IMemory::size() <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">size_t</span> size;</div><div class="line">    getMemory(<span class="literal">NULL</span>, &amp;size);</div><div class="line">    <span class="keyword">return</span> size;</div><div class="line">&#125;</div><div class="line"><span class="keyword">ssize_t</span> IMemory::offset() <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">ssize_t</span> offset;</div><div class="line">    getMemory(&amp;offset);</div><div class="line">    <span class="keyword">return</span> offset;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当客户端的BpMemory向服务端MemoryBase发起RPC请求后，服务端的BnMemory对象的onTransact函数被调用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">status_t</span> BnMemory::onTransact(</div><div class="line">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">switch</span>(code) &#123;</div><div class="line">        <span class="keyword">case</span> GET_MEMORY: &#123;</div><div class="line">            <span class="comment">// 根据客户端发送过来的接口描述进行检查确认</span></div><div class="line">            CHECK_INTERFACE(IMemory, data, reply);</div><div class="line">            <span class="keyword">ssize_t</span> offset;</div><div class="line">            <span class="keyword">size_t</span> size;</div><div class="line">            <span class="comment">// 调用服务端的getMemory函数获取匿名共享内存对象MemoryHeapBase</span></div><div class="line">            <span class="comment">// 及匿名共享内存大小，偏移，并返回给客户端</span></div><div class="line">            reply-&gt;writeStrongBinder( IInterface::asBinder(getMemory(&amp;offset, &amp;size)) );</div><div class="line">            <span class="comment">// 将偏移量返回给客户端</span></div><div class="line">            reply-&gt;writeInt32(offset);</div><div class="line">             <span class="comment">// 将匿名共享内存大小返回给客户端</span></div><div class="line">            reply-&gt;writeInt32(size);</div><div class="line">            <span class="keyword">return</span> NO_ERROR;</div><div class="line">        &#125; <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> BBinder::onTransact(code, data, reply, flags);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>服务端的getMemory函数由BnMemory的子类MemoryBase实现。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">sp&lt;IMemoryHeap&gt; MemoryBase::getMemory(<span class="keyword">ssize_t</span>* offset, <span class="keyword">size_t</span>* size) <span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (offset) *offset = mOffset;</div><div class="line">    <span class="keyword">if</span> (size)   *size = mSize;</div><div class="line">    <span class="keyword">return</span> mHeap;</div><div class="line">&#125;</div><div class="line"></div><div class="line">MemoryBase::MemoryBase(<span class="keyword">const</span> sp&lt;IMemoryHeap&gt;&amp; heap,</div><div class="line">        <span class="keyword">ssize_t</span> offset, <span class="keyword">size_t</span> size)</div><div class="line">    : mSize(size), mOffset(offset), mHeap(heap)</div><div class="line">&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在它的构造函数中，接受三个参数，参数heap指向的是一个MemoryHeapBase对象，真正的匿名共享内存就是由它来维护的，参数offset表示这个MemoryBase对象所要维护的这部分匿名共享内存在整个匿名共享内存块中的起始位置，参数size表示这个MemoryBase对象所要维护的这部分匿名共享内存的大小。</p>
<p>成员函数getMemory的实现很简单，只是简单地返回内部的MemoryHeapBase对象的IMemoryHeap接口，如果传进来的参数offset和size不为NULL，还会把其内部维护的这部分匿名共享内存在整个匿名共享内存块中的偏移位置以及这部分匿名共享内存的大小返回给调用者。</p>
<p>这里可以看出，MemoryBase在Server端的实现只是简单地封装了MemoryHeapBase的实现。</p>
<p>MemoryBase类在Client端的实现与MemoryHeapBase类在Client端的实现是类似的，这里只要把IMemory类换成IMemoryHeap类以及把BpMemory类换成BpMemoryHeap类就变成是MemoryHeapBase类在Client端的实现了，因此，我们这里只简单分析BpMemory类的实现，前面已经分析过IMemory类的实现了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BpMemory</span> :</span> <span class="keyword">public</span> BpInterface&lt;IMemory&gt;</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BpMemory</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; impl)</span></span>;</div><div class="line">    <span class="keyword">virtual</span> ~BpMemory();</div><div class="line">    <span class="keyword">virtual</span> sp&lt;IMemoryHeap&gt; getMemory(<span class="keyword">ssize_t</span>* offset=<span class="number">0</span>, <span class="keyword">size_t</span>* size=<span class="number">0</span>) <span class="keyword">const</span>;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">mutable</span> sp&lt;IMemoryHeap&gt; mHeap;</div><div class="line">    <span class="keyword">mutable</span> <span class="keyword">ssize_t</span> mOffset;</div><div class="line">    <span class="keyword">mutable</span> <span class="keyword">size_t</span> mSize;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>下面就看一下BpMemory类的成员函数getMemory的实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">sp&lt;IMemoryHeap&gt; BpMemory::getMemory(<span class="keyword">ssize_t</span>* offset, <span class="keyword">size_t</span>* size) <span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// 指向的匿名共享内存MemoryHeapBase为空</span></div><div class="line">    <span class="keyword">if</span> (mHeap == <span class="number">0</span>) &#123;</div><div class="line">        Parcel data, reply;</div><div class="line">        data.writeInterfaceToken(IMemory::getInterfaceDescriptor());</div><div class="line">        <span class="comment">// 向服务端MemoryBase发起RPC请求</span></div><div class="line">        <span class="keyword">if</span> (remote()-&gt;transact(GET_MEMORY, data, &amp;reply) == NO_ERROR) &#123;</div><div class="line">            <span class="comment">// 读取服务端返回来的结果</span></div><div class="line">            <span class="comment">// 读取匿名共享内存MemoryHeapBase的IBinder对象</span></div><div class="line">            sp&lt;IBinder&gt; heap = reply.readStrongBinder(); </div><div class="line">            <span class="keyword">ssize_t</span> o = reply.readInt32(); <span class="comment">// 读取匿名共享内存中的偏移量</span></div><div class="line">            <span class="keyword">size_t</span> s = reply.readInt32();  <span class="comment">// 读取匿名共享内存的大小</span></div><div class="line">            <span class="comment">// 如果服务端返回来的用于描述整块匿名共享内存的MemoryHeapBase不为空</span></div><div class="line">            <span class="keyword">if</span> (heap != <span class="number">0</span>) &#123;</div><div class="line">                mHeap = interface_cast&lt;IMemoryHeap&gt;(heap);</div><div class="line">                <span class="keyword">if</span> (mHeap != <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">size_t</span> heapSize = mHeap-&gt;getSize();</div><div class="line">                    <span class="comment">// 将匿名共享内存的偏移和大小保存到成员变量中</span></div><div class="line">                    <span class="keyword">if</span> (s &lt;= heapSize</div><div class="line">                            &amp;&amp; o &gt;= <span class="number">0</span></div><div class="line">                            &amp;&amp; (<span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(o) &lt;= heapSize - s)) &#123;</div><div class="line">                        mOffset = o;</div><div class="line">                        mSize = s;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="comment">// Hm.</span></div><div class="line">                        android_errorWriteWithInfoLog(<span class="number">0x534e4554</span>,</div><div class="line">                            <span class="string">"26877992"</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</div><div class="line">                        mOffset = <span class="number">0</span>;</div><div class="line">                        mSize = <span class="number">0</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 将成员变量赋值给传进来的参数，从而修改参数值</span></div><div class="line">    <span class="keyword">if</span> (offset) *offset = mOffset;</div><div class="line">    <span class="keyword">if</span> (size) *size = mSize;</div><div class="line">    <span class="keyword">return</span> (mSize &gt; <span class="number">0</span>) ? mHeap : <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果成员变量mHeap的值为NULL，就表示这个BpMemory对象尚未建立好匿名共享内存，于是，就会通过一个Binder进程间调用去Server端请求匿名共享内存信息，在这些信息中，最重要的就是这个Server端的MemoryHeapBase对象的引用heap了，通过这个引用可以在Client端进程中创建一个BpMemoryHeap远程接口，最后将这个BpMemoryHeap远程接口保存在成员变量mHeap中，同时，从Server端获得的信息还包括这块匿名共享内存在整个匿名共享内存中的偏移位置以及大小。这样，这个BpMemory对象中的匿名共享内存就准备就绪了。</p>
<h3 id="MemoryDealer"><a href="#MemoryDealer" class="headerlink" title="MemoryDealer"></a>MemoryDealer</h3><p>在AudioFlinger创建Client过程中，使用MemoryDealer申请共享内存,其实MemoryDealer工具类就是对MemoryHeapBase和MemoryBase的封装。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mMemoryDealer = <span class="keyword">new</span> MemoryDealer(heapSize, <span class="string">"AudioFlinger::Client"</span>);</div></pre></td></tr></table></figure></p>
<p>下面看看MemoryDealer的构造函数，这里会创建MemoryHeapBase，即分配4M共享内存，还会创建与一个简单分配器，后续每次通信需要的具体内存由SimpleBestFitAllocator从4M内存上分配。在SimpleBestFitAllocator中维护一个双向链表来管理这4M的内存。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">MemoryDealer::MemoryDealer(<span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">uint32_t</span> flags)</div><div class="line">    : mHeap(<span class="keyword">new</span> MemoryHeapBase(size, flags, name)),</div><div class="line">    mAllocator(<span class="keyword">new</span> SimpleBestFitAllocator(size))</div><div class="line">&#123;    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// align all the memory blocks on a cache-line boundary</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> SimpleBestFitAllocator::kMemoryAlign = <span class="number">32</span>;</div><div class="line">SimpleBestFitAllocator::SimpleBestFitAllocator(<span class="keyword">size_t</span> size)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">size_t</span> pagesize = getpagesize();</div><div class="line">    mHeapSize = ((size + pagesize<span class="number">-1</span>) &amp; ~(pagesize<span class="number">-1</span>));</div><div class="line">    <span class="keyword">chunk_t</span>* node = <span class="keyword">new</span> <span class="keyword">chunk_t</span>(<span class="number">0</span>, mHeapSize / kMemoryAlign);</div><div class="line">    mList.insertHead(node);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>前面我们看到最终申请内存通过MemoryDealer的allocate的函数，返回的是IMemory类型。从代码看，会返回Allocation，继承自MemoryBase。分配时，最终调用SimpleBestFitAllocator的alloc函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">sp&lt;IMemory&gt; MemoryDealer::allocate(<span class="keyword">size_t</span> size)</div><div class="line">&#123;</div><div class="line">    sp&lt;IMemory&gt; memory;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">ssize_t</span> offset = allocator()-&gt;allocate(size);</div><div class="line">    <span class="keyword">if</span> (offset &gt;= <span class="number">0</span>) &#123;</div><div class="line">        memory = <span class="keyword">new</span> Allocation(<span class="keyword">this</span>, heap(), offset, size);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> memory;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SimpleBestFitAllocator* MemoryDealer::allocator() <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> mAllocator;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">size_t</span> SimpleBestFitAllocator::allocate(<span class="keyword">size_t</span> size, <span class="keyword">uint32_t</span> flags)</div><div class="line">&#123;</div><div class="line">    Mutex::Autolock _l(mLock);</div><div class="line">    <span class="keyword">ssize_t</span> offset = alloc(size, flags);</div><div class="line">    <span class="keyword">return</span> offset;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> SimpleBestFitAllocator::alloc(<span class="keyword">size_t</span> size, <span class="keyword">uint32_t</span> flags)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    size = (size + kMemoryAlign<span class="number">-1</span>) / kMemoryAlign;</div><div class="line">    <span class="keyword">chunk_t</span>* free_chunk = <span class="number">0</span>;</div><div class="line">    <span class="keyword">chunk_t</span>* cur = mList.head();</div><div class="line">    <span class="keyword">size_t</span> pagesize = getpagesize();</div><div class="line">    <span class="keyword">while</span> (cur) &#123;</div><div class="line">        <span class="keyword">int</span> extra = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (flags &amp; PAGE_ALIGNED)</div><div class="line">            extra = ( -cur-&gt;start &amp; ((pagesize/kMemoryAlign)<span class="number">-1</span>) ) ;</div><div class="line">        <span class="comment">// best fit</span></div><div class="line">        <span class="keyword">if</span> (cur-&gt;<span class="built_in">free</span> &amp;&amp; (cur-&gt;size &gt;= (size+extra))) &#123;</div><div class="line">            <span class="keyword">if</span> ((!free_chunk) || (cur-&gt;size &lt; free_chunk-&gt;size)) &#123;</div><div class="line">                free_chunk = cur;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (cur-&gt;size == size) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        cur = cur-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (free_chunk) &#123;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">size_t</span> free_size = free_chunk-&gt;size;</div><div class="line">        free_chunk-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</div><div class="line">        free_chunk-&gt;size = size;</div><div class="line">        <span class="keyword">if</span> (free_size &gt; size) &#123;</div><div class="line">            <span class="keyword">int</span> extra = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> (flags &amp; PAGE_ALIGNED)</div><div class="line">                extra = ( -free_chunk-&gt;start &amp; ((pagesize/kMemoryAlign)<span class="number">-1</span>) ) ;</div><div class="line">            <span class="keyword">if</span> (extra) &#123;</div><div class="line">                <span class="keyword">chunk_t</span>* split = <span class="keyword">new</span> <span class="keyword">chunk_t</span>(free_chunk-&gt;start, extra);</div><div class="line">                free_chunk-&gt;start += extra;</div><div class="line">                mList.insertBefore(free_chunk, split);</div><div class="line">            &#125;</div><div class="line">            ALOGE_IF((flags&amp;PAGE_ALIGNED) &amp;&amp; </div><div class="line">                    ((free_chunk-&gt;start*kMemoryAlign)&amp;(pagesize<span class="number">-1</span>)),</div><div class="line">                    <span class="string">"PAGE_ALIGNED requested, but page is not aligned!!!"</span>);</div><div class="line">            <span class="keyword">const</span> <span class="keyword">ssize_t</span> tail_free = free_size - (size+extra);</div><div class="line">            <span class="keyword">if</span> (tail_free &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">chunk_t</span>* split = <span class="keyword">new</span> <span class="keyword">chunk_t</span>(</div><div class="line">                        free_chunk-&gt;start + free_chunk-&gt;size, tail_free);</div><div class="line">                mList.insertAfter(free_chunk, split);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (free_chunk-&gt;start)*kMemoryAlign;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> NO_MEMORY;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>链表节点，每次从4M空间挖取一段内存作为一个节点，不用时再释放删除节点，通过这种简单的方式来管理这段内存。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk_t</span> &#123;</span></div><div class="line">        <span class="keyword">chunk_t</span>(<span class="keyword">size_t</span> start, <span class="keyword">size_t</span> size)</div><div class="line">        : start(start), size(size), <span class="built_in">free</span>(<span class="number">1</span>), prev(<span class="number">0</span>), next(<span class="number">0</span>) &#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">size_t</span>              start;                  <span class="comment">// 起始地址</span></div><div class="line">        <span class="keyword">size_t</span>              size : <span class="number">28</span>;              <span class="comment">// 内存大小</span></div><div class="line">        <span class="keyword">int</span>                 <span class="built_in">free</span> : <span class="number">4</span>;               <span class="comment">// 是否占用</span></div><div class="line">        <span class="keyword">mutable</span> <span class="keyword">chunk_t</span>*    prev;</div><div class="line">        <span class="keyword">mutable</span> <span class="keyword">chunk_t</span>*    next;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<h2 id="AudioTrack数据写入和AudioFlinger数据读取"><a href="#AudioTrack数据写入和AudioFlinger数据读取" class="headerlink" title="AudioTrack数据写入和AudioFlinger数据读取"></a>AudioTrack数据写入和AudioFlinger数据读取</h2><p>AudioTrack实例构造后，应用程序接着可以写入音频数据了。AudioTrack与AudioFlinger是生产者-消费者的关系：</p>
<ul>
<li>AudioTrack：AudioTrack在共享内存中找到一块可用空间，把用户传入的音频数据写入到这块可用空间上，然后更新写位置（对于AudioFinger来说，意味共享内存上有更多的可读数据了）；如果用户传入的数据量比可用空间要大，那么要把用户传入的数据拆分多次写入到共享中（AudioTrack和AudioFlinger是不同的进程，AudioFlinger同时也在不停地读取数据，所以共享内存可用空间是在不停变化的）。</li>
<li>AudioFlinger：AudioFlinger在共享内存中找到一块可读数据块，把可读数据拷贝到目的缓冲区上，然后更新读位置（对于AudioTrack来说，意味着共享内存上有更多的可用空间了）；如果共享内存上可读数据量比预期的要小，那么要进行多次的读取，才能积累到预期的数据量（AudioTrack和AudioFlinger是不同的进程，AudioTrack同时也在不停地写入数据，所以共享内存可读的数据量是在不停变化的）。</li>
</ul>
<p>在AudioTrack和AudioFlinger操作共享内存的时使用Proxy来管理。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/av/include/private/meida/AudioTrackShared.h</span></div><div class="line"><span class="comment">// Proxy for shared memory control block, to isolate callers </span></div><div class="line"><span class="comment">// from needing to know the details. There is exactly one</span></div><div class="line"><span class="comment">// ClientProxy and one ServerProxy per shared memory control block.</span></div><div class="line"><span class="comment">// The proxies are located in normal memory, </span></div><div class="line"><span class="comment">// and are not multi-thread safe within a given side.</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> :</span> <span class="keyword">public</span> RefBase &#123;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    Proxy(<span class="keyword">audio_track_cblk_t</span>* cblk, <span class="keyword">void</span> *buffers, <span class="keyword">size_t</span> frameCount, </div><div class="line">          <span class="keyword">size_t</span> frameSize, <span class="keyword">bool</span> isOut, <span class="keyword">bool</span> clientInServer);</div><div class="line">    <span class="keyword">virtual</span> ~Proxy() &#123; &#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">size_t</span> frameCount() <span class="keyword">const</span> &#123; <span class="keyword">return</span> mFrameCount; &#125;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="comment">// These refer to shared memory, and are virtual addresses with respect to the </span></div><div class="line">    <span class="comment">// current process. They may have different virtual addresses within the other process.</span></div><div class="line">    <span class="keyword">audio_track_cblk_t</span>* <span class="keyword">const</span>   mCblk;  <span class="comment">// the control block</span></div><div class="line">    <span class="keyword">void</span>* <span class="keyword">const</span>     mBuffers;           <span class="comment">// starting address of buffers</span></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span>    mFrameCount;        <span class="comment">// not necessarily a power of 2</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span>    mFrameSize;         <span class="comment">// in bytes</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span>    mFrameCountP2;      <span class="comment">// mFrameCount rounded to power of 2, streaming mode</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">bool</span>      mIsOut;             <span class="comment">// true for AudioTrack, false for AudioRecord</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">bool</span>      mClientInServer;    <span class="comment">// true for OutputTrack, </span></div><div class="line">                                        <span class="comment">// false for AudioTrack &amp; AudioRecord</span></div><div class="line">    <span class="keyword">bool</span>            mIsShutdown;        <span class="comment">// latch set to true when </span></div><div class="line">                                        <span class="comment">// shared memory corruption detected</span></div><div class="line">    <span class="keyword">size_t</span>          mUnreleased;        <span class="comment">// unreleased frames remaining </span></div><div class="line">                                        <span class="comment">// from most recent obtainBuffer</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>如下是Proxy的类图：<br><img src="https://i.imgur.com/z0xTk2d.png" alt=""></p>
<ul>
<li>AudioTrackClientProxy：MODE_STREAM模式下，生产者AudioTrack使用它在共享内存中找到可用空间的位置</li>
<li><p>AudioTrackServerProxy：MODE_STREAM模式下，消费者AudioFlinger::PlaybackThread使用它在 共享内存中找到可读数据的位置</p>
</li>
<li><p>StaticAudioTrackClientProxy：MODE_STATIC模式下，生产者AudioTrack使用它在共享内存中找到可用空间的位置</p>
</li>
<li><p>StaticAudioTrackServerProxy：MODE_STATIC模式下，消费者AudioFlinger::PlaybackThread 使用它在共享内存中找到可读数据的位置</p>
</li>
<li><p>AudioRecordClientProxy：消费者AudioRecord使用它在共享内存中找到可读数据的位置</p>
</li>
<li>AudioTrackServerProxy：生产者AudioFlinger::RecordThread使用它在共享内存中找到可用空间的位置</li>
</ul>
<h3 id="AudioTrack数据写入"><a href="#AudioTrack数据写入" class="headerlink" title="AudioTrack数据写入"></a>AudioTrack数据写入</h3><p>在写数据的过程中会用到两个buffer，分别是AudioTrack::Buffer和Proxy::Buffer，它们声明如下。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/av/media/libaudioclient/include/media/AudioTrack.h</span></div><div class="line"><span class="comment">// AudioTrack::Buffer声明</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buffer</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// FIXME use m prefix</span></div><div class="line">    <span class="keyword">size_t</span>      frameCount;   <span class="comment">// number of sample frames corresponding to size;</span></div><div class="line">                              <span class="comment">// on input to obtainBuffer() it is the number of frames desired,</span></div><div class="line">                              <span class="comment">// on output from obtainBuffer() it is the number of available</span></div><div class="line">                              <span class="comment">//    [empty slots for] frames to be filled</span></div><div class="line">                              <span class="comment">// on input to releaseBuffer() it is currently ignored</span></div><div class="line">    <span class="keyword">size_t</span>      size;         <span class="comment">// input/output in bytes == frameCount * frameSize</span></div><div class="line">                              <span class="comment">// on input to obtainBuffer() it is ignored</span></div><div class="line">                              <span class="comment">// on output from obtainBuffer() it is the number of available</span></div><div class="line">                              <span class="comment">//    [empty slots for] bytes to be filled,</span></div><div class="line">                              <span class="comment">//    which is frameCount * frameSize</span></div><div class="line">                              <span class="comment">// on input to releaseBuffer() it is the number of bytes to</span></div><div class="line">                              <span class="comment">//    release</span></div><div class="line">                              <span class="comment">// FIXME This is redundant with respect to frameCount.  Consider</span></div><div class="line">                              <span class="comment">//    removing size and making frameCount the primary field.</span></div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">void</span>*       raw;</div><div class="line">        <span class="keyword">short</span>*      i16;      <span class="comment">// signed 16-bit</span></div><div class="line">        <span class="keyword">int8_t</span>*     i8;       <span class="comment">// unsigned 8-bit, offset by 0x80</span></div><div class="line">    &#125;;                        <span class="comment">// input to obtainBuffer(): unused, output: pointer to buffer</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// frameworks/av/include/private/meida/AudioTrackShared.h</span></div><div class="line"><span class="comment">// Proxy::Buffer声明</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Buffer</span> &#123;</span></div><div class="line">    <span class="keyword">size_t</span>  mFrameCount;            <span class="comment">// number of frames available in this buffer</span></div><div class="line">    <span class="keyword">void</span>*   mRaw;                   <span class="comment">// pointer to first frame</span></div><div class="line">    <span class="keyword">size_t</span>  mNonContig;             <span class="comment">// number of additional non-contiguous frames available</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>当创建好AudioTrack，Client端会执行写数据，则会调用AudioTrack的write函数向硬件写数据，首先会获取可用的共享内存空间，将数据拷贝到这块可用空间，然后更新共享内存写数据的位置。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/av/media/libaudioclient/AudioTrack.cpp</span></div><div class="line"><span class="keyword">ssize_t</span> AudioTrack::write(<span class="keyword">const</span> <span class="keyword">void</span>* buffer, <span class="keyword">size_t</span> userSize, <span class="keyword">bool</span> blocking)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 条件检查</span></div><div class="line">    ......</div><div class="line">    <span class="keyword">size_t</span> written = <span class="number">0</span>;</div><div class="line">    Buffer audioBuffer; <span class="comment">//如上声明</span></div><div class="line">    <span class="keyword">while</span> (userSize &gt;= mFrameSize) &#123;</div><div class="line">        <span class="comment">// 单帧数据量 frameSize = channelCount * bytesPerSample</span></div><div class="line">        <span class="comment">// 对于双声道，16位采样的音频数据来说，frameSize = 2 * 2 = 4(bytes)</span></div><div class="line">        <span class="comment">// 用户传入的数据帧数 frameCount = userSize / frameSize</span></div><div class="line">        audioBuffer.frameCount = userSize / mFrameSize;</div><div class="line">        <span class="comment">// obtainBuffer() 从共享内存上得到一块可用区间</span></div><div class="line">        <span class="keyword">status_t</span> err = obtainBuffer(&amp;audioBuffer,</div><div class="line">                blocking ? &amp;ClientProxy::kForever : &amp;ClientProxy::kNonBlocking);</div><div class="line">        </div><div class="line">        ......</div><div class="line">        <span class="comment">// toWrite 是共享内存上可用区间的大小，可能比userSize（用户传入数据的大小）要小</span></div><div class="line">        <span class="comment">// 因此用户传入的数据可能要拆分多次拷贝到共享内存上</span></div><div class="line">        <span class="comment">// 注意：AudioTrack和AudioFlinger是不同的进程，AudioFlinger同时也在不停地</span></div><div class="line">        <span class="comment">// 消耗数据，所以共享内存可用区间是在不停变化的</span></div><div class="line">        <span class="keyword">size_t</span> toWrite = audioBuffer.size;</div><div class="line">        <span class="built_in">memcpy</span>(audioBuffer.i8, buffer, toWrite);    <span class="comment">// 把用户数据拷贝到共享内存可用区间</span></div><div class="line">        buffer = ((<span class="keyword">const</span> <span class="keyword">char</span> *) buffer) + toWrite; <span class="comment">// 未拷贝数据的位置</span></div><div class="line">        userSize -= toWrite;                        <span class="comment">// 未拷贝数据的大小</span></div><div class="line">        written += toWrite;                         <span class="comment">// 已拷贝数据的大小</span></div><div class="line">        </div><div class="line">        <span class="comment">// releaseBuffer() 更新共享内存写位置</span></div><div class="line">        <span class="comment">// 对于AudioFinger来说，意味共享内存上有更多的可读数据</span></div><div class="line">        releaseBuffer(&amp;audioBuffer);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (written &gt; <span class="number">0</span>) &#123;</div><div class="line">        mFramesWritten += written / mFrameSize;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> written;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在AudioTrack内部会先设置进程睡眠时间，然后调用AudioTrackClientProxy的obtainBuffer函数获取Proxy::Buffer，然后将其转换为AudioTrack::Buffer，然后通过参数返回。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/av/media/libaudioclient/AudioTrack.cpp</span></div><div class="line"><span class="keyword">status_t</span> AudioTrack::obtainBuffer(Buffer* audioBuffer, <span class="keyword">int32_t</span> waitCount, <span class="keyword">size_t</span> *nonContig)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 条件检查</span></div><div class="line">    .....</div><div class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> *<span class="title">requested</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">timeout</span>;</span></div><div class="line">    <span class="comment">// 通过waitCount的值计算是否需要等待，若要等待则等待多久</span></div><div class="line">    .....</div><div class="line">    <span class="keyword">return</span> obtainBuffer(audioBuffer, requested, <span class="literal">NULL</span> <span class="comment">/*elapsed*/</span>, nonContig);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">status_t</span> AudioTrack::obtainBuffer(Buffer* audioBuffer, <span class="keyword">const</span> struct timespec *requested,</div><div class="line">        struct timespec *elapsed, <span class="keyword">size_t</span> *nonContig)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// previous and new IAudioTrack sequence numbers are used to detect track re-creation</span></div><div class="line">    <span class="keyword">uint32_t</span> oldSequence = <span class="number">0</span>;</div><div class="line">    <span class="keyword">uint32_t</span> newSequence;</div><div class="line">    Proxy::Buffer buffer;</div><div class="line">    <span class="keyword">status_t</span> status = NO_ERROR;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int32_t</span> kMaxTries = <span class="number">5</span>; <span class="comment">// 最多5次尝试获取可用空间</span></div><div class="line">    <span class="keyword">int32_t</span> tryCounter = kMaxTries;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="comment">// obtainBuffer() is called with mutex unlocked, so keep extra references </span></div><div class="line">        <span class="comment">// to these fields to keep them from going away </span></div><div class="line">        <span class="comment">// if another thread re-creates the track during obtainBuffer()</span></div><div class="line">        sp&lt;AudioTrackClientProxy&gt; proxy;</div><div class="line">        sp&lt;IMemory&gt; iMem;</div><div class="line"></div><div class="line">        ...... <span class="comment">// 对异常状况，stop状态等情况的处理，并获取AudioTrackClientProxy</span></div><div class="line"></div><div class="line">        <span class="comment">// 调用AudioTrackClientProxy的obtainBuffer函数，由于继承关系，</span></div><div class="line">		<span class="comment">// 会调用ClientProxy的obtainBuffer函数</span></div><div class="line">        buffer.mFrameCount = audioBuffer-&gt;frameCount;</div><div class="line">        <span class="comment">// FIXME starts the requested timeout and elapsed over from scratch</span></div><div class="line">        status = proxy-&gt;obtainBuffer(&amp;buffer, requested, elapsed);</div><div class="line">    &#125; <span class="keyword">while</span> (((status == DEAD_OBJECT) || (status == NOT_ENOUGH_DATA)) &amp;&amp; (tryCounter-- &gt; <span class="number">0</span>));</div><div class="line"></div><div class="line">    将Proxy::Buffer转为AudioTrack::Buffer</div><div class="line">    audioBuffer-&gt;frameCount = buffer.mFrameCount;</div><div class="line">    audioBuffer-&gt;size = buffer.mFrameCount * mFrameSize;</div><div class="line">    audioBuffer-&gt;raw = buffer.mRaw;</div><div class="line">    <span class="keyword">if</span> (nonContig != <span class="literal">NULL</span>) &#123;</div><div class="line">        *nonContig = buffer.mNonContig;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> status;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在ClientProxy中，首先设置timeout类型，然后从共享内存读取队头和队尾指针，从而计算已经使用的区域，结合共享内存的大小计算可用空间，最后找到一块合适的空间返回。在其中还会通过系统调用进行进程间的同步控制，看具体情况将进程挂起。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/av/media/libaudioclient/AudioTrackShared.cpp</span></div><div class="line">__attribute__((no_sanitize(<span class="string">"integer"</span>)))</div><div class="line"><span class="keyword">status_t</span> ClientProxy::obtainBuffer(Buffer* buffer, <span class="keyword">const</span> struct timespec *requested,</div><div class="line">        struct timespec *elapsed)</div><div class="line">&#123;</div><div class="line">    LOG_ALWAYS_FATAL_IF(buffer == <span class="literal">NULL</span> || buffer-&gt;mFrameCount == <span class="number">0</span>);</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">total</span>;</span>          <span class="comment">// total elapsed time spent waiting</span></div><div class="line">    total.tv_sec = <span class="number">0</span>;</div><div class="line">    total.tv_nsec = <span class="number">0</span>;</div><div class="line">    <span class="keyword">bool</span> measure = elapsed != <span class="literal">NULL</span>; <span class="comment">// whether to measure total elapsed time spent waiting</span></div><div class="line">    <span class="keyword">status_t</span> status;</div><div class="line">    <span class="keyword">enum</span> &#123;</div><div class="line">        TIMEOUT_ZERO,       <span class="comment">// requested == NULL || *requested == 0</span></div><div class="line">        TIMEOUT_INFINITE,   <span class="comment">// *requested == infinity</span></div><div class="line">        TIMEOUT_FINITE,     <span class="comment">// 0 &lt; *requested &lt; infinity</span></div><div class="line">        TIMEOUT_CONTINUE,   <span class="comment">// additional chances after TIMEOUT_FINITE</span></div><div class="line">    &#125; timeout;</div><div class="line"></div><div class="line">    ...... <span class="comment">// 根据requested设置timeout类型</span></div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">before</span>;</span></div><div class="line">    <span class="keyword">bool</span> beforeIsValid = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">audio_track_cblk_t</span>* cblk = mCblk;</div><div class="line">    <span class="keyword">bool</span> ignoreInitialPendingInterrupt = <span class="literal">true</span>;</div><div class="line">    <span class="comment">// check for shared memory corruption</span></div><div class="line">    <span class="keyword">if</span> (mIsShutdown) &#123;</div><div class="line">        status = NO_INIT;</div><div class="line">        <span class="keyword">goto</span> end;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line"></div><div class="line">        ...... <span class="comment">// 基本条件检查</span></div><div class="line"></div><div class="line">        <span class="keyword">int32_t</span> front;</div><div class="line">        <span class="keyword">int32_t</span> rear;</div><div class="line">        <span class="comment">// 注意使用带内存屏障的函数android_atomic_acquire_load</span></div><div class="line">        <span class="comment">// 获取队头和队尾</span></div><div class="line">        <span class="keyword">if</span> (mIsOut) &#123; <span class="comment">// 对应AudioTrack</span></div><div class="line">            <span class="comment">// The barrier following the read of mFront is probably redundant.</span></div><div class="line">            <span class="comment">// We're about to perform a conditional branch based on 'filled',</span></div><div class="line">            <span class="comment">// which will force the processor to observe the read of mFront</span></div><div class="line">            <span class="comment">// prior to allowing data writes starting at mRaw.</span></div><div class="line">            <span class="comment">// However, the processor may support speculative execution,</span></div><div class="line">            <span class="comment">// and be unable to undo speculative writes into shared memory.</span></div><div class="line">            <span class="comment">// The barrier will prevent such speculative execution.</span></div><div class="line">            front = android_atomic_acquire_load(&amp;cblk-&gt;u.mStreaming.mFront);</div><div class="line">            rear = cblk-&gt;u.mStreaming.mRear;</div><div class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 对应AudioRecord</span></div><div class="line">            <span class="comment">// On the other hand, this barrier is required.</span></div><div class="line">            rear = android_atomic_acquire_load(&amp;cblk-&gt;u.mStreaming.mRear);</div><div class="line">            front = cblk-&gt;u.mStreaming.mFront;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// write to rear, read from front</span></div><div class="line">        <span class="comment">// 已经使用的区域</span></div><div class="line">        <span class="keyword">ssize_t</span> filled = rear - front;</div><div class="line">        <span class="comment">// pipe should not be overfull</span></div><div class="line">        <span class="comment">// 当已经使用的空间大于预先设置的帧数，对于播放来讲出错了，</span></div><div class="line">        <span class="comment">// 而对于录音来说目前处于overrun,写入的速度太快，读取熟读跟不上</span></div><div class="line">        <span class="keyword">if</span> (!(<span class="number">0</span> &lt;= filled &amp;&amp; (<span class="keyword">size_t</span>) filled &lt;= mFrameCount)) &#123;</div><div class="line">            <span class="keyword">if</span> (mIsOut) &#123;</div><div class="line">                ALOGE(<span class="string">"Shared memory control block is corrupt (filled=%zd, mFrameCount=%zu); "</span></div><div class="line">                        <span class="string">"shutting down"</span>, filled, mFrameCount);</div><div class="line">                mIsShutdown = <span class="literal">true</span>;</div><div class="line">                status = NO_INIT;</div><div class="line">                <span class="keyword">goto</span> end;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// for input, sync up on overrun</span></div><div class="line">            filled = <span class="number">0</span>;</div><div class="line">            cblk-&gt;u.mStreaming.mFront = rear;</div><div class="line">            (<span class="keyword">void</span>) android_atomic_or(CBLK_OVERRUN, &amp;cblk-&gt;mFlags);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// Don't allow filling pipe beyond the user settable size.</span></div><div class="line">        <span class="comment">// The calculation for avail can go negative if the buffer size</span></div><div class="line">        <span class="comment">// is suddenly dropped below the amount already in the buffer.</span></div><div class="line">        <span class="comment">// So use a signed calculation to prevent a numeric overflow abort.</span></div><div class="line">        <span class="comment">// 有符号运算可用空间</span></div><div class="line">        <span class="keyword">ssize_t</span> adjustableSize = (<span class="keyword">ssize_t</span>) getBufferSizeInFrames();</div><div class="line">        <span class="keyword">ssize_t</span> avail =  (mIsOut) ? adjustableSize - filled : filled;</div><div class="line">        <span class="keyword">if</span> (avail &lt; <span class="number">0</span>) &#123;</div><div class="line">            avail = <span class="number">0</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (avail &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 'avail' may be non-contiguous, so return only the first contiguous chunk</span></div><div class="line">            <span class="keyword">size_t</span> part1;</div><div class="line">            <span class="keyword">if</span> (mIsOut) &#123;</div><div class="line">                rear &amp;= mFrameCountP2 - <span class="number">1</span>;</div><div class="line">                part1 = mFrameCountP2 - rear;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                front &amp;= mFrameCountP2 - <span class="number">1</span>;</div><div class="line">                part1 = mFrameCountP2 - front;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (part1 &gt; (<span class="keyword">size_t</span>)avail) &#123;</div><div class="line">                part1 = avail;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (part1 &gt; buffer-&gt;mFrameCount) &#123;</div><div class="line">                part1 = buffer-&gt;mFrameCount;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 赋值Proxy::Buffer</span></div><div class="line">            buffer-&gt;mFrameCount = part1;</div><div class="line">            buffer-&gt;mRaw = part1 &gt; <span class="number">0</span> ?</div><div class="line">                    &amp;((<span class="keyword">char</span> *) mBuffers)[(mIsOut ? rear : front) * mFrameSize] : <span class="literal">NULL</span>;</div><div class="line">            buffer-&gt;mNonContig = avail - part1;</div><div class="line">            mUnreleased = part1;</div><div class="line">            status = NO_ERROR;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">remaining</span>;</span></div><div class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> *<span class="title">ts</span>;</span></div><div class="line"></div><div class="line">        ...... <span class="comment">// 根据timeout类型计算剩余等待的时间ts</span></div><div class="line"></div><div class="line">        <span class="keyword">int32_t</span> old = android_atomic_and(~CBLK_FUTEX_WAKE, &amp;cblk-&gt;mFutex);</div><div class="line">        <span class="keyword">if</span> (!(old &amp; CBLK_FUTEX_WAKE)) &#123;</div><div class="line">            <span class="keyword">if</span> (measure &amp;&amp; !beforeIsValid) &#123;</div><div class="line">                clock_gettime(CLOCK_MONOTONIC, &amp;before);</div><div class="line">                beforeIsValid = <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">            errno = <span class="number">0</span>;</div><div class="line">            <span class="comment">// 同步控制，down (P)操作,原子性的给cblk-&gt;mFutex同步变量减1，</span></div><div class="line">            <span class="comment">// FUTEX_WAIT，原子性的检查cblk-&gt;mFutex中计数器的值是否为负值,</span></div><div class="line">            <span class="comment">// 如果是则让进程休眠，直到FUTEX_WAKE或者超时(time-out)。也就是</span></div><div class="line">            <span class="comment">// 把进程挂到cblk-&gt;mFutex相对应的等待队列上去。</span></div><div class="line">            (<span class="keyword">void</span>) syscall(__NR_futex, &amp;cblk-&gt;mFutex,</div><div class="line">                    mClientInServer ? FUTEX_WAIT_PRIVATE : FUTEX_WAIT, </div><div class="line">                    old &amp; ~CBLK_FUTEX_WAKE, ts);</div><div class="line">            <span class="keyword">status_t</span> error = errno; <span class="comment">// clock_gettime can affect errno</span></div><div class="line">            <span class="comment">// update total elapsed time spent waiting</span></div><div class="line">            ......</div><div class="line">            <span class="keyword">switch</span> (error) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="number">0</span>:            <span class="comment">// normal wakeup by server, or by binderDied()</span></div><div class="line">            <span class="keyword">case</span> EWOULDBLOCK:  <span class="comment">// benign race condition with server</span></div><div class="line">            <span class="keyword">case</span> EINTR:        <span class="comment">// wait was interrupted by signal or other spurious wakeup</span></div><div class="line">            <span class="keyword">case</span> ETIMEDOUT:    <span class="comment">// time-out expired</span></div><div class="line">                <span class="comment">// FIXME these error/non-0 status are being dropped</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                status = error;</div><div class="line">                ALOGE(<span class="string">"%s unexpected error %s"</span>, __func__, strerror(status));</div><div class="line">                <span class="keyword">goto</span> end;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">end:</div><div class="line">    ...... <span class="comment">// 善后处理</span></div><div class="line">    <span class="keyword">return</span> status;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Client端拷贝完会更新共享内存的写数据指针，这一步通过ClientProxy的releaseBuffer实现。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/av/media/libaudioclient/AudioTrack.cpp</span></div><div class="line"><span class="keyword">void</span> AudioTrack::releaseBuffer(<span class="keyword">const</span> Buffer* audioBuffer)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// FIXME add error checking on mode, by adding an internal version</span></div><div class="line">    ..... <span class="comment">// 条件检查</span></div><div class="line"></div><div class="line">    <span class="comment">// 数据写入完毕，将数据从AudioTrack::Buffer转入Proxy::Buffer，</span></div><div class="line">    <span class="comment">// 调用AudioTrackClientProxy的releaseBuffer函数释放buffer控制权</span></div><div class="line">    Proxy::Buffer buffer;</div><div class="line">    buffer.mFrameCount = stepCount;</div><div class="line">    buffer.mRaw = audioBuffer-&gt;raw;</div><div class="line">    <span class="function">AutoMutex <span class="title">lock</span><span class="params">(mLock)</span></span>;</div><div class="line">    mReleased += stepCount;</div><div class="line">    mInUnderrun = <span class="literal">false</span>;</div><div class="line">    mProxy-&gt;releaseBuffer(&amp;buffer);</div><div class="line">    <span class="comment">// restart track if it was disabled by audioflinger due to previous underrun</span></div><div class="line">    restartIfDisabled();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// frameworks/av/media/libaudioclient/AudioTrackShared.cpp</span></div><div class="line">__attribute__((no_sanitize(<span class="string">"integer"</span>)))</div><div class="line"><span class="keyword">void</span> ClientProxy::releaseBuffer(Buffer* buffer)</div><div class="line">&#123;</div><div class="line">    LOG_ALWAYS_FATAL_IF(buffer == <span class="literal">NULL</span>);</div><div class="line">    <span class="keyword">size_t</span> stepCount = buffer-&gt;mFrameCount;</div><div class="line">    <span class="keyword">if</span> (stepCount == <span class="number">0</span> || mIsShutdown) &#123;</div><div class="line">        <span class="comment">// prevent accidental re-use of buffer</span></div><div class="line">        buffer-&gt;mFrameCount = <span class="number">0</span>;</div><div class="line">        buffer-&gt;mRaw = <span class="literal">NULL</span>;</div><div class="line">        buffer-&gt;mNonContig = <span class="number">0</span>;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    LOG_ALWAYS_FATAL_IF(!(stepCount &lt;= mUnreleased &amp;&amp; mUnreleased &lt;= mFrameCount));</div><div class="line">    mUnreleased -= stepCount;</div><div class="line">    <span class="keyword">audio_track_cblk_t</span>* cblk = mCblk;</div><div class="line">    <span class="comment">// Both of these barriers are required</span></div><div class="line">    <span class="comment">// 释放buffer控制权，其实是移动队尾（队头），更新写数据位置，注意内存屏障的使用</span></div><div class="line">    <span class="keyword">if</span> (mIsOut) &#123;</div><div class="line">        <span class="keyword">int32_t</span> rear = cblk-&gt;u.mStreaming.mRear;</div><div class="line">        android_atomic_release_store(stepCount + rear, &amp;cblk-&gt;u.mStreaming.mRear);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">int32_t</span> front = cblk-&gt;u.mStreaming.mFront;</div><div class="line">        android_atomic_release_store(stepCount + front, &amp;cblk-&gt;u.mStreaming.mFront);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="AudioFlinger数据读取"><a href="#AudioFlinger数据读取" class="headerlink" title="AudioFlinger数据读取"></a>AudioFlinger数据读取</h3><p>在AudioFlinger端读取数据会使用到AudioBufferProvider::Buffer和Proxy::Buffer。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/av/media/libaudioclient/include/media/AudioBufferProvider.h</span></div><div class="line">AudioBufferProvider::Buffer声明</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Buffer</span> &#123;</span></div><div class="line">    Buffer() : raw(<span class="literal">NULL</span>), frameCount(<span class="number">0</span>) &#123; &#125;</div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">void</span>*       raw;</div><div class="line">        <span class="keyword">short</span>*      i16;</div><div class="line">        <span class="keyword">int8_t</span>*     i8;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">size_t</span> frameCount;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// frameworks/av/include/private/meida/AudioTrackShared.h</span></div><div class="line"><span class="comment">// Proxy::Buffer声明</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Buffer</span> &#123;</span></div><div class="line">    <span class="keyword">size_t</span>  mFrameCount;            <span class="comment">// number of frames available in this buffer</span></div><div class="line">    <span class="keyword">void</span>*   mRaw;                   <span class="comment">// pointer to first frame</span></div><div class="line">    <span class="keyword">size_t</span>  mNonContig;             <span class="comment">// number of additional non-contiguous frames available</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>我们以DirectOutputThread/OffloadThread为例说明（MixerThread读数据也是类似的过程，由于MixerThread会有混音过程，所以读取数据会稍微复杂点，是在AudioMixer中进行的，后续有机会分析混音时在分析其读取数据的过程）。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/av/services/audioflinger/Threads.cpp</span></div><div class="line"><span class="keyword">void</span> AudioFlinger::DirectOutputThread::threadLoop_mix()</div><div class="line">&#123;</div><div class="line">    <span class="comment">// mFrameCount是硬件设备（PCM设备）处理单个数据块的帧数（周期大小）</span></div><div class="line">    <span class="comment">// 上层必须积累了足够多（mFrameCount）的数据，才写入到PCM设备所以</span></div><div class="line">    <span class="comment">// mFrameCount也就是AudioFlinger预期的数据量</span></div><div class="line">    <span class="keyword">size_t</span> frameCount = mFrameCount;</div><div class="line">    <span class="comment">// mSinkBuffer目的缓冲区，threadLoop_write() 会把mSinkBuffer上的数据写到PCM设备</span></div><div class="line">    <span class="keyword">int8_t</span> *curBuf = (<span class="keyword">int8_t</span> *)mSinkBuffer;</div><div class="line">    <span class="comment">// output audio to hardware</span></div><div class="line">    <span class="comment">// FIFO 上可读的数据量可能要比预期的要小，因此可能需要多次读取才能积累足够的数据量</span></div><div class="line">    <span class="comment">// 注意：AudioTrack和AudioFlinger是不同的进程，AudioTrack同时也在不停地生产数据</span></div><div class="line">    <span class="comment">// 所以共享内存可读的数据量是在不停变化的</span></div><div class="line">    <span class="keyword">while</span> (frameCount) &#123;</div><div class="line">        AudioBufferProvider::Buffer buffer;</div><div class="line">        buffer.frameCount = frameCount;</div><div class="line">        <span class="comment">// getNextBuffer() 从共享内存上获取可读数据块</span></div><div class="line">        <span class="keyword">status_t</span> status = mActiveTrack-&gt;getNextBuffer(&amp;buffer);</div><div class="line">        <span class="keyword">if</span> (status != NO_ERROR || buffer.raw == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="comment">// no need to pad with 0 for compressed audio</span></div><div class="line">            <span class="keyword">if</span> (audio_has_proportional_frames(mFormat)) &#123;</div><div class="line">                <span class="built_in">memset</span>(curBuf, <span class="number">0</span>, frameCount * mFrameSize);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// memcpy()把共享内存可读数据拷贝到mSinkBuffer目的缓冲区</span></div><div class="line">        <span class="built_in">memcpy</span>(curBuf, buffer.raw, buffer.frameCount * mFrameSize);</div><div class="line">        frameCount -= buffer.frameCount;</div><div class="line">        curBuf += buffer.frameCount * mFrameSize;</div><div class="line">        <span class="comment">// releaseBuffer()更新共享内存读位置</span></div><div class="line">        <span class="comment">// 对于AudioTrack来说，意味着共享内存上有更多的可用空间</span></div><div class="line">        mActiveTrack-&gt;releaseBuffer(&amp;buffer);</div><div class="line">    &#125;</div><div class="line">    mCurrentWriteLength = curBuf - (<span class="keyword">int8_t</span> *)mSinkBuffer;</div><div class="line">    mSleepTimeUs = <span class="number">0</span>;</div><div class="line">    mStandbyTimeNs = systemTime() + mStandbyDelayNs;</div><div class="line">    mActiveTrack.clear();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上面看到会先通过mActiveTrack的getNextBuffer获取可读数据，即Track类的getNextBuffer函数，然后将数据拷贝到目的mSinkBuffer，然后更新读数据指针位置。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/av/services/audioflinger/Tracks.cpp</span></div><div class="line"><span class="comment">// AudioBufferProvider interface</span></div><div class="line"><span class="keyword">status_t</span> AudioFlinger::PlaybackThread::Track::getNextBuffer(</div><div class="line">        AudioBufferProvider::Buffer* buffer)</div><div class="line">&#123;</div><div class="line">    ServerProxy::Buffer buf;</div><div class="line">    <span class="keyword">size_t</span> desiredFrames = buffer-&gt;frameCount;</div><div class="line">    buf.mFrameCount = desiredFrames;</div><div class="line">    <span class="comment">// 调用AudioTrackServerProxy的obtainBuffer函数，由于继承关系，</span></div><div class="line">	<span class="comment">// 会调用ServerProxy的obtainBuffer函数 </span></div><div class="line">    <span class="keyword">status_t</span> status = mServerProxy-&gt;obtainBuffer(&amp;buf);</div><div class="line">    <span class="comment">// Proxy::Buffer转化为AudioBufferProvider::Buffer</span></div><div class="line">    buffer-&gt;frameCount = buf.mFrameCount;</div><div class="line">    buffer-&gt;raw = buf.mRaw;</div><div class="line">    <span class="comment">// 是否处于underrun状态</span></div><div class="line">    <span class="keyword">if</span> (buf.mFrameCount == <span class="number">0</span> &amp;&amp; !isStopping() &amp;&amp; !isStopped() &amp;&amp; !isPaused()) &#123;</div><div class="line">        ALOGV(<span class="string">"underrun,  framesReady(%zu) &lt; framesDesired(%zd), state: %d"</span>,</div><div class="line">                buf.mFrameCount, desiredFrames, mState);</div><div class="line">        mAudioTrackServerProxy-&gt;tallyUnderrunFrames(desiredFrames);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        mAudioTrackServerProxy-&gt;tallyUnderrunFrames(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> status;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// AudioBufferProvider interface</span></div><div class="line"><span class="comment">// getNextBuffer() = 0;</span></div><div class="line"><span class="comment">// This implementation of releaseBuffer() is used by Track and RecordTrack</span></div><div class="line"><span class="keyword">void</span> AudioFlinger::ThreadBase::TrackBase::releaseBuffer(AudioBufferProvider::Buffer* buffer)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// AudioBufferProvider::Buffer转化为Proxy::Buffer</span></div><div class="line">    ServerProxy::Buffer buf;</div><div class="line">    buf.mFrameCount = buffer-&gt;frameCount;</div><div class="line">    buf.mRaw = buffer-&gt;raw;</div><div class="line">    buffer-&gt;frameCount = <span class="number">0</span>;</div><div class="line">    buffer-&gt;raw = <span class="literal">NULL</span>;</div><div class="line">    <span class="comment">// 调用AudioTrackServerProxy的releaseBuffer函数，由于继承关系，</span></div><div class="line">	<span class="comment">// 会调用ServerProxy的releaseBuffer函数 </span></div><div class="line">    mServerProxy-&gt;releaseBuffer(&amp;buf);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>获取可读数据及更新读数据指针位置最终会通过ServerProxy实现，同样先获取队头指针和队尾指针，然后计算可读数据，将可读数据转给传入的buffer。拷贝完数据，然后更新读数据指针，然后同步通知Client端，唤醒挂起的进程。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/av/media/libaudioclient/AudioTrackShared.cpp</span></div><div class="line">__attribute__((no_sanitize(<span class="string">"integer"</span>)))</div><div class="line"><span class="keyword">status_t</span> ServerProxy::obtainBuffer(Buffer* buffer, <span class="keyword">bool</span> ackFlush)</div><div class="line">&#123;</div><div class="line">    LOG_ALWAYS_FATAL_IF(buffer == <span class="literal">NULL</span> || buffer-&gt;mFrameCount == <span class="number">0</span>,</div><div class="line">            <span class="string">"%s: null or zero frame buffer, buffer:%p"</span>, __func__, buffer);</div><div class="line">    <span class="keyword">if</span> (mIsShutdown) &#123;</div><div class="line">        <span class="keyword">goto</span> no_init;</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">    <span class="keyword">audio_track_cblk_t</span>* cblk = mCblk;</div><div class="line">    <span class="comment">// compute number of frames available to write (AudioTrack) or read (AudioRecord),</span></div><div class="line">    <span class="comment">// or use previous cached value from framesReady(), with added barrier if it omits.</span></div><div class="line">    <span class="keyword">int32_t</span> front;</div><div class="line">    <span class="keyword">int32_t</span> rear;</div><div class="line">    <span class="comment">// See notes on barriers at ClientProxy::obtainBuffer()</span></div><div class="line">    <span class="comment">// 注意使用带内存屏障的函数android_atomic_acquire_load</span></div><div class="line">    <span class="comment">// 获取队头和队尾</span></div><div class="line">    <span class="keyword">if</span> (mIsOut) &#123;</div><div class="line">        flushBufferIfNeeded(); <span class="comment">// might modify mFront</span></div><div class="line">        rear = android_atomic_acquire_load(&amp;cblk-&gt;u.mStreaming.mRear);</div><div class="line">        front = cblk-&gt;u.mStreaming.mFront;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        front = android_atomic_acquire_load(&amp;cblk-&gt;u.mStreaming.mFront);</div><div class="line">        rear = cblk-&gt;u.mStreaming.mRear;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">ssize_t</span> filled = rear - front;</div><div class="line">    <span class="comment">// pipe should not already be overfull</span></div><div class="line">    <span class="keyword">if</span> (!(<span class="number">0</span> &lt;= filled &amp;&amp; (<span class="keyword">size_t</span>) filled &lt;= mFrameCount)) &#123;</div><div class="line">        ALOGE(<span class="string">"Shared memory control block is corrupt (filled=%zd, mFrameCount=%zu); </span></div><div class="line"><span class="string">               shutting down"</span>, filled, mFrameCount);</div><div class="line">        mIsShutdown = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (mIsShutdown) &#123;</div><div class="line">        <span class="keyword">goto</span> no_init;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// don't allow filling pipe beyond the nominal size</span></div><div class="line">    <span class="keyword">size_t</span> availToServer;</div><div class="line">    <span class="keyword">if</span> (mIsOut) &#123;</div><div class="line">        availToServer = filled;</div><div class="line">        mAvailToClient = mFrameCount - filled;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        availToServer = mFrameCount - filled;</div><div class="line">        mAvailToClient = filled;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 'availToServer' may be non-contiguous, so return only the first contiguous chunk</span></div><div class="line">    <span class="keyword">size_t</span> part1;</div><div class="line">    <span class="keyword">if</span> (mIsOut) &#123;</div><div class="line">        front &amp;= mFrameCountP2 - <span class="number">1</span>;</div><div class="line">        part1 = mFrameCountP2 - front;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        rear &amp;= mFrameCountP2 - <span class="number">1</span>;</div><div class="line">        part1 = mFrameCountP2 - rear;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (part1 &gt; availToServer) &#123;</div><div class="line">        part1 = availToServer;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">size_t</span> ask = buffer-&gt;mFrameCount;</div><div class="line">    <span class="keyword">if</span> (part1 &gt; ask) &#123;</div><div class="line">        part1 = ask;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// is assignment redundant in some cases?</span></div><div class="line">    buffer-&gt;mFrameCount = part1;</div><div class="line">    buffer-&gt;mRaw = part1 &gt; <span class="number">0</span> ?</div><div class="line">            &amp;((<span class="keyword">char</span> *) mBuffers)[(mIsOut ? front : rear) * mFrameSize] : <span class="literal">NULL</span>;</div><div class="line">    buffer-&gt;mNonContig = availToServer - part1;</div><div class="line">    <span class="comment">// After flush(), allow releaseBuffer() on a previously obtained buffer;</span></div><div class="line">    <span class="comment">// see "Acknowledge any pending flush()" in audioflinger/Tracks.cpp.</span></div><div class="line">    <span class="keyword">if</span> (!ackFlush) &#123;</div><div class="line">        mUnreleased = part1;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> part1 &gt; <span class="number">0</span> ? NO_ERROR : WOULD_BLOCK;</div><div class="line">    &#125;</div><div class="line">no_init:</div><div class="line">    buffer-&gt;mFrameCount = <span class="number">0</span>;</div><div class="line">    buffer-&gt;mRaw = <span class="literal">NULL</span>;</div><div class="line">    buffer-&gt;mNonContig = <span class="number">0</span>;</div><div class="line">    mUnreleased = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> NO_INIT;</div><div class="line">&#125;</div><div class="line"></div><div class="line">__attribute__((no_sanitize(<span class="string">"integer"</span>)))</div><div class="line"><span class="keyword">void</span> ServerProxy::releaseBuffer(Buffer* buffer)</div><div class="line">&#123;</div><div class="line">    ..... <span class="comment">// 条件检查</span></div><div class="line">    mUnreleased -= stepCount;</div><div class="line">    <span class="keyword">audio_track_cblk_t</span>* cblk = mCblk;</div><div class="line">    <span class="comment">// 释放buffer控制权，其实是移动队头（队尾），更新读数据位置，注意内存屏障的使用</span></div><div class="line">    <span class="keyword">if</span> (mIsOut) &#123;</div><div class="line">        <span class="keyword">int32_t</span> front = cblk-&gt;u.mStreaming.mFront;</div><div class="line">        android_atomic_release_store(stepCount + front, &amp;cblk-&gt;u.mStreaming.mFront);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">int32_t</span> rear = cblk-&gt;u.mStreaming.mRear;</div><div class="line">        android_atomic_release_store(stepCount + rear, &amp;cblk-&gt;u.mStreaming.mRear);</div><div class="line">    &#125;</div><div class="line">    cblk-&gt;mServer += stepCount;</div><div class="line">    mReleased += stepCount;</div><div class="line">    <span class="keyword">size_t</span> half = mFrameCount / <span class="number">2</span>;</div><div class="line">    <span class="keyword">if</span> (half == <span class="number">0</span>) &#123;</div><div class="line">        half = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">size_t</span> minimum = (<span class="keyword">size_t</span>) cblk-&gt;mMinimum;</div><div class="line">    <span class="keyword">if</span> (minimum == <span class="number">0</span>) &#123;</div><div class="line">        minimum = mIsOut ? half : <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (minimum &gt; half) &#123;</div><div class="line">        minimum = half;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// FIXME AudioRecord wakeup needs to be optimized; it currently wakes up client every time</span></div><div class="line">    <span class="keyword">if</span> (!mIsOut || (mAvailToClient + stepCount &gt;= minimum)) &#123;</div><div class="line">        <span class="keyword">int32_t</span> old = android_atomic_or(CBLK_FUTEX_WAKE, &amp;cblk-&gt;mFutex);</div><div class="line">        <span class="keyword">if</span> (!(old &amp; CBLK_FUTEX_WAKE)) &#123;</div><div class="line">            <span class="comment">// 同步控制，up (V)操作,原子性的给cblk-&gt;mFutex同步变量加1，</span></div><div class="line">            <span class="comment">// FUTEX_WAKE，原子性的检查cblk-&gt;mFutex中计数器的值是否为正值,</span></div><div class="line">            <span class="comment">// 如果不是则唤醒一个或者多个等待进程。</span></div><div class="line">            (<span class="keyword">void</span>) syscall(__NR_futex, &amp;cblk-&gt;mFutex,</div><div class="line">                    mClientInServer ? FUTEX_WAKE_PRIVATE : FUTEX_WAKE, <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    buffer-&gt;mFrameCount = <span class="number">0</span>;</div><div class="line">    buffer-&gt;mRaw = <span class="literal">NULL</span>;</div><div class="line">    buffer-&gt;mNonContig = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/12/16/Android-AudioManager-API-getDevicces原理/" rel="next" title="Android AudioManager API: getDevicces原理">
                <i class="fa fa-chevron-left"></i> Android AudioManager API: getDevicces原理
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Raycco" />
            
              <p class="site-author-name" itemprop="name">Raycco</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/raycco" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://weibo.com/SweWoo" target="_blank" title="微博">
                    
                      <i class="fa fa-fw fa-globe"></i>微博</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#通信模型"><span class="nav-number">1.</span> <span class="nav-text">通信模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#共享内存控制块"><span class="nav-number">2.</span> <span class="nav-text">共享内存控制块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#共享内存的创建"><span class="nav-number">3.</span> <span class="nav-text">共享内存的创建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#时序图"><span class="nav-number">3.1.</span> <span class="nav-text">时序图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#源代码"><span class="nav-number">3.2.</span> <span class="nav-text">源代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#匿名共享内存C-接口"><span class="nav-number">4.</span> <span class="nav-text">匿名共享内存C++接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MemoryHeapBase"><span class="nav-number">4.1.</span> <span class="nav-text">MemoryHeapBase</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MemoryBase"><span class="nav-number">4.2.</span> <span class="nav-text">MemoryBase</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MemoryDealer"><span class="nav-number">4.3.</span> <span class="nav-text">MemoryDealer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AudioTrack数据写入和AudioFlinger数据读取"><span class="nav-number">5.</span> <span class="nav-text">AudioTrack数据写入和AudioFlinger数据读取</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AudioTrack数据写入"><span class="nav-number">5.1.</span> <span class="nav-text">AudioTrack数据写入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AudioFlinger数据读取"><span class="nav-number">5.2.</span> <span class="nav-text">AudioFlinger数据读取</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Raycco</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  

    
      <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://yoursite.com/2017/12/28/AudioTrack到AudioFlinger数据传输/';
          this.page.identifier = '2017/12/28/AudioTrack到AudioFlinger数据传输/';
          this.page.title = 'AudioTrack到AudioFlinger数据传输：共享内存';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("seh2gCOupF9nMssA4XsfpjwJ-gzGzoHsz", "U2GBcKwy5DiTjcVUyKyUCCuX");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  
  

  

  

  

</body>
</html>
