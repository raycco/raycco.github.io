<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Raycco&#39;s Notes</title>
  
  <subtitle>Quick Notes</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-05T09:55:31.366Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Raycco</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android Audio HAL server启动</title>
    <link href="http://yoursite.com/2017/11/28/Android-Audio-HAL-server%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/11/28/Android-Audio-HAL-server启动过程/</id>
    <published>2017-11-28T02:41:54.000Z</published>
    <updated>2017-12-05T09:55:31.366Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道硬件抽象层（HAL）是连接driver和native的桥梁，数据会从native层到HAL层，最终写入kernel。然而8.0之前的HAL和native处于同一进程，耦合度比较高。所以在Android 8.0，google对HAL做了重构，将HAL放在独立的进程，和native通过binder通信。下面我们就看看Android Audio HAL server的启动。</p><h2 id="Audio-HAL-server启动"><a href="#Audio-HAL-server启动" class="headerlink" title="Audio HAL server启动"></a>Audio HAL server启动</h2><p>同样Android Audio HAL server（audio-hal-2-0）从init进程启动，不过audio-hal-2-0的可执行文件在vendor分区，这也是为了降低耦合度，因为HAL一般由OEM/ODM实现，google不想HAL影响到Framework的更新，所以希望尽量将OEM/ODM的实现放到vendor分区，由这些厂商自己维护。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">service audio-hal-2-0 /vendor/bin/hw/android.hardware.audio@2.0-service</div><div class="line">    class hal                                   <span class="comment"># audio-hal-2-0和class hal行为一致</span></div><div class="line">    user audioserver                            <span class="comment"># 用户归属，uid：AID_AUDIOSERVER</span></div><div class="line">    <span class="comment"># media gid needed for /dev/fm (radio) and for /data/misc/media (tee)</span></div><div class="line">    group audio camera drmrpc inet media mediadrm net_bt \</div><div class="line">                       net_bt_admin net_bw_acct <span class="comment"># 用户组归属</span></div><div class="line">    ioprio rt 4                                 <span class="comment"># io调度优先级</span></div><div class="line">    <span class="comment"># 当子进程被创建的时候，将子进程的pid写入到给定的文件中,cgroup/cpuset用法</span></div><div class="line">    writepid /dev/cpuset/foreground/tasks /dev/stune/foreground/tasks</div><div class="line">    <span class="comment"># audioflinger restarts itself when it loses connection with the hal</span></div><div class="line">    <span class="comment"># and its .rc file has an "onrestart restart audio-hal" rule, thus</span></div><div class="line">    <span class="comment"># an additional auto-restart from the init process isn't needed.</span></div><div class="line">    oneshot                                     <span class="comment"># 当此服务退出时不会自动重启</span></div></pre></td></tr></table></figure></p><p>我们看到audio-hal-2-0的启动代码有IDevicesFactory，IEffectsFactory，ISoundTriggerHw及IBroadcastRadioFactory，这和native的audioserver相对应。且代码有一种熟悉的感觉，和audioserver的启动很相似，只是具体实现有些不一样，这里通过registerPassthroughServiceImplementation将如上四个服务注册到hwservicemanager，以供native调用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> <span class="comment">/* argc */</span>, <span class="keyword">char</span>* <span class="comment">/* argv */</span> [])</span> </span>&#123;</div><div class="line">    configureRpcThreadpool(<span class="number">16</span>, <span class="literal">true</span> <span class="comment">/*callerWillJoin*/</span>);</div><div class="line">    android::<span class="keyword">status_t</span> status;</div><div class="line">    status = registerPassthroughServiceImplementation&lt;IDevicesFactory&gt;();</div><div class="line">    LOG_ALWAYS_FATAL_IF(status != OK, <span class="string">"Error while registering audio service: %d"</span>, status);</div><div class="line">    status = registerPassthroughServiceImplementation&lt;IEffectsFactory&gt;();</div><div class="line">    LOG_ALWAYS_FATAL_IF(status != OK, <span class="string">"Error while registering audio effects </span></div><div class="line"><span class="string">                                                         service: %d"</span>, status);</div><div class="line">    <span class="comment">// Soundtrigger and FM radio might be not present.</span></div><div class="line">    status = registerPassthroughServiceImplementation&lt;ISoundTriggerHw&gt;();</div><div class="line">    ALOGE_IF(status != OK, <span class="string">"Error while registering soundtrigger service: %d"</span>, status);</div><div class="line">    <span class="keyword">if</span> (useBroadcastRadioFutureFeatures) &#123;</div><div class="line">        status = registerPassthroughServiceImplementation&lt;</div><div class="line">            broadcastradio::V1_1::IBroadcastRadioFactory&gt;();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        status = registerPassthroughServiceImplementation&lt;</div><div class="line">            broadcastradio::V1_0::IBroadcastRadioFactory&gt;();</div><div class="line">    &#125;</div><div class="line">    ALOGE_IF(status != OK, <span class="string">"Error while registering fm radio service: %d"</span>, status);</div><div class="line">    joinRpcThreadpool();</div><div class="line">    <span class="keyword">return</span> status;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="IDevicesFactory注册到hwservicemanager"><a href="#IDevicesFactory注册到hwservicemanager" class="headerlink" title="IDevicesFactory注册到hwservicemanager"></a>IDevicesFactory注册到hwservicemanager</h2><p>在如上的启动代码中我们看到，HAL服务端调用registerPassthroughServiceImplementation实现注册，这函数的实现在system/libhidl/transport/include/hidl/LegacySupport.h,这是一个模板方法，这里传入IDevicesFactory接口。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Registers passthrough service implementation.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Interface</span>&gt;</span></div><div class="line"><span class="class">__<span class="title">attribute__</span>((<span class="title">warn_unused_result</span>))</span></div><div class="line"><span class="class"><span class="title">status_t</span> <span class="title">registerPassthroughServiceImplementation</span>(</span></div><div class="line"><span class="class">        <span class="title">std</span>:</span>:<span class="built_in">string</span> name = <span class="string">"default"</span>) &#123;</div><div class="line">    sp&lt;Interface&gt; service = Interface::getService(name, <span class="literal">true</span> <span class="comment">/* getStub */</span>);</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">    <span class="keyword">status_t</span> status = service-&gt;registerAsService(name);</div><div class="line">    </div><div class="line">    ......</div><div class="line"></div><div class="line">    <span class="keyword">return</span> status;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>所以首先会调用IDevicesFactory的getService方法。在IDevicesFactory.h中看到有getService方法的声明，在DevicesFactoryAll.cpp中有此方法的实现，最后会返回BsDevicesFactory实例。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span>* IDevicesFactory::descriptor(<span class="string">"android.hardware.audio@2.0::IDevicesFactory"</span>);</div><div class="line"></div><div class="line">::android::sp&lt;IDevicesFactory&gt; IDevicesFactory::getService(</div><div class="line">                       <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;serviceName, <span class="keyword">const</span> <span class="keyword">bool</span> getStub) &#123;</div><div class="line">    <span class="keyword">using</span> ::android::hardware::defaultServiceManager;</div><div class="line">    <span class="keyword">using</span> ::android::hardware::details::waitForHwService;</div><div class="line">    <span class="keyword">using</span> ::android::hardware::getPassthroughServiceManager;</div><div class="line">    <span class="keyword">using</span> ::android::hardware::Return;</div><div class="line">    <span class="keyword">using</span> ::android::sp;</div><div class="line">    <span class="keyword">using</span> Transport = ::android::hidl::manager::V1_0::IServiceManager::Transport;</div><div class="line"></div><div class="line">    sp&lt;IDevicesFactory&gt; iface = <span class="literal">nullptr</span>;</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (getStub || vintfPassthru || vintfLegacy) &#123;</div><div class="line">        <span class="keyword">const</span> sp&lt;::android::hidl::manager::V1_0::IServiceManager&gt; pm = </div><div class="line">                                             getPassthroughServiceManager();</div><div class="line">        <span class="keyword">if</span> (pm != <span class="literal">nullptr</span>) &#123;</div><div class="line">            Return&lt;sp&lt;::android::hidl::base::V1_0::IBase&gt;&gt; ret = </div><div class="line">                    pm-&gt;get(IDevicesFactory::descriptor, serviceName);</div><div class="line">            <span class="keyword">if</span> (ret.isOk()) &#123;</div><div class="line">                sp&lt;::android::hidl::base::V1_0::IBase&gt; baseInterface = ret;</div><div class="line">                <span class="keyword">if</span> (baseInterface != <span class="literal">nullptr</span>) &#123;</div><div class="line">                    iface = <span class="keyword">new</span> BsDevicesFactory(IDevicesFactory::castFrom(baseInterface));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> iface;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里getStub为true，所以前面一段代码不会执行，直接创建PassthroughServiceManager，PassthroughServiceManager的实现在system/libhidl/transport/ServiceManagement.cpp，然后执行其get方法。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line">Return&lt;sp&lt;IBase&gt;&gt; get(<span class="keyword">const</span> hidl_string&amp; fqName,</div><div class="line">                      <span class="keyword">const</span> hidl_string&amp; name) override &#123;</div><div class="line">    std::string stdFqName(fqName.c_str());</div><div class="line">    <span class="comment">//fqName looks like android.hardware.foo@1.0::IFoo</span></div><div class="line">    <span class="keyword">size_t</span> idx = stdFqName.find(<span class="string">"::"</span>);</div><div class="line">    <span class="keyword">if</span> (idx == <span class="built_in">std</span>::<span class="built_in">string</span>::npos ||</div><div class="line">            idx + <span class="built_in">strlen</span>(<span class="string">"::"</span>) + <span class="number">1</span> &gt;= stdFqName.size()) &#123;</div><div class="line">        LOG(ERROR) &lt;&lt; <span class="string">"Invalid interface name passthrough lookup: "</span> &lt;&lt; fqName;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// packageAndVersion为android.hardware.audio@2.0</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> packageAndVersion = stdFqName.substr(<span class="number">0</span>, idx);</div><div class="line"></div><div class="line">    <span class="comment">// ifaceName为IDevicesFactory</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> ifaceName = stdFqName.substr(idx + <span class="built_in">strlen</span>(<span class="string">"::"</span>));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> prefix = packageAndVersion + <span class="string">"-impl"</span>;</div><div class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> sym = <span class="string">"HIDL_FETCH_"</span> + ifaceName;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">android_namespace_t</span>* sphal_namespace = android_get_exported_namespace(<span class="string">"sphal"</span>);</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dlMode = RTLD_LAZY;</div><div class="line">    <span class="keyword">void</span> *handle = <span class="literal">nullptr</span>;</div><div class="line">    <span class="comment">// <span class="doctag">TODO:</span> lookup in VINTF instead</span></div><div class="line">    <span class="comment">// TODO(b/34135607): Remove HAL_LIBRARY_PATH_SYSTEM</span></div><div class="line">    dlerror(); <span class="comment">// clear</span></div><div class="line">    </div><div class="line">    <span class="comment">// 在/odm/lib(64)/hw/，/vendor/lib(64)/hw/，/system/lib(64)/hw/</span></div><div class="line">    <span class="comment">// 寻找android.hardware.audio@2.0-impl.so并用dlopen打开，执行</span></div><div class="line">    <span class="comment">// HIDL_FETCH_IDevicesFactory函数,创建DevicesFactory实例</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;path : &#123;</div><div class="line">        HAL_LIBRARY_PATH_ODM, HAL_LIBRARY_PATH_VENDOR, HAL_LIBRARY_PATH_SYSTEM</div><div class="line">    &#125;) &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; libs = search(path, prefix, <span class="string">".so"</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;lib : libs) &#123;</div><div class="line">            <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> fullPath = path + lib;</div><div class="line">            <span class="comment">// If sphal namespace is available, try to load from the</span></div><div class="line">            <span class="comment">// namespace first. If it fails, fall back to the original</span></div><div class="line">            <span class="comment">// dlopen, which loads from the current namespace.</span></div><div class="line">            <span class="keyword">if</span> (sphal_namespace != <span class="literal">nullptr</span> &amp;&amp; path != HAL_LIBRARY_PATH_SYSTEM) &#123;</div><div class="line">                <span class="keyword">const</span> android_dlextinfo dlextinfo = &#123;</div><div class="line">                    .flags = ANDROID_DLEXT_USE_NAMESPACE,</div><div class="line">                    <span class="comment">// const_cast is dirty but required because</span></div><div class="line">                    <span class="comment">// library_namespace field is non-const.</span></div><div class="line">                    .library_namespace = <span class="keyword">const_cast</span>&lt;<span class="keyword">android_namespace_t</span>*&gt;(sphal_namespace),</div><div class="line">                &#125;;</div><div class="line">                handle = android_dlopen_ext(fullPath.c_str(), dlMode, &amp;dlextinfo);</div><div class="line">                <span class="keyword">if</span> (handle == <span class="literal">nullptr</span>) &#123;</div><div class="line">                    <span class="keyword">const</span> <span class="keyword">char</span>* error = dlerror();</div><div class="line">                    LOG(WARNING) &lt;&lt; <span class="string">"Failed to dlopen "</span> &lt;&lt; lib &lt;&lt; <span class="string">" from sphal namespace:"</span></div><div class="line">                                 &lt;&lt; (error == <span class="literal">nullptr</span> ? <span class="string">"unknown error"</span> : error);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    LOG(DEBUG) &lt;&lt; lib &lt;&lt; <span class="string">" loaded from sphal namespace."</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (handle == <span class="literal">nullptr</span>) &#123;</div><div class="line">                handle = dlopen(fullPath.c_str(), dlMode);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (handle == <span class="literal">nullptr</span>) &#123;</div><div class="line">                <span class="keyword">const</span> <span class="keyword">char</span>* error = dlerror();</div><div class="line">                LOG(ERROR) &lt;&lt; <span class="string">"Failed to dlopen "</span> &lt;&lt; lib &lt;&lt; <span class="string">": "</span></div><div class="line">                           &lt;&lt; (error == <span class="literal">nullptr</span> ? <span class="string">"unknown error"</span> : error);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            IBase* (*generator)(<span class="keyword">const</span> <span class="keyword">char</span>* name);</div><div class="line">            *(<span class="keyword">void</span> **)(&amp;generator) = dlsym(handle, sym.c_str());</div><div class="line">            <span class="keyword">if</span>(!generator) &#123;</div><div class="line">                <span class="keyword">const</span> <span class="keyword">char</span>* error = dlerror();</div><div class="line">                LOG(ERROR) &lt;&lt; <span class="string">"Passthrough lookup opened "</span> &lt;&lt; lib</div><div class="line">                           &lt;&lt; <span class="string">" but could not find symbol "</span> &lt;&lt; sym &lt;&lt; <span class="string">": "</span></div><div class="line">                           &lt;&lt; (error == <span class="literal">nullptr</span> ? <span class="string">"unknown error"</span> : error);</div><div class="line">                dlclose(handle);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            IBase *interface = (*generator)(name.c_str());</div><div class="line">            <span class="keyword">if</span> (interface == <span class="literal">nullptr</span>) &#123;</div><div class="line">                dlclose(handle);</div><div class="line">                <span class="keyword">continue</span>; <span class="comment">// this module doesn't provide this instance name</span></div><div class="line">            &#125;</div><div class="line">            registerReference(fqName, name);</div><div class="line">            <span class="keyword">return</span> interface;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>根据android.hardware.audio@2.0::IDevicesFactory字串拼接出android.hardware.audio@2.0-impl.so并找到打开，执行HIDL_FETCH_IDevicesFactory函数创建DevicesFactory返回。得到BsDevicesFactory实例后，会执行其registerAsService。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">::android::<span class="keyword">status_t</span> IDevicesFactory::registerAsService(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;serviceName) &#123;</div><div class="line">    ::android::hardware::details::onRegistration(</div><div class="line">                       <span class="string">"android.hardware.audio@2.0"</span>, <span class="string">"IDevicesFactory"</span>, serviceName);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> ::android::sp&lt;::android::hidl::manager::V1_0::IServiceManager&gt; sm</div><div class="line">            = ::android::hardware::defaultServiceManager();</div><div class="line">    <span class="keyword">if</span> (sm == <span class="literal">nullptr</span>) &#123;</div><div class="line">        <span class="keyword">return</span> ::android::INVALID_OPERATION;</div><div class="line">    &#125;</div><div class="line">    ::android::hardware::Return&lt;<span class="keyword">bool</span>&gt; ret = sm-&gt;add(serviceName.c_str(), <span class="keyword">this</span>);</div><div class="line">    <span class="keyword">return</span> ret.isOk() &amp;&amp; ret ? ::android::OK : ::android::UNKNOWN_ERROR;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>获取HwServiceManager将自己注册到hwservicemanager。这里涉及binder通信机制，关于binder通信，是另外一个比较大的topic，在这里一两句说不清楚，所以后续有时间再专门记录。</p><h2 id="加载HAL-so"><a href="#加载HAL-so" class="headerlink" title="加载HAL so"></a>加载HAL so</h2><p>回想在AudioPolicyService启动的时候，会mDevicesFactoryHal-&gt;openDevice(name, &amp;dev),其实最终会调用DevicesFactory的loadAudioInterface，即打开audio.primary.default.so等lib。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> DevicesFactory::loadAudioInterface(<span class="keyword">const</span> <span class="keyword">char</span> *if_name, <span class="keyword">audio_hw_device_t</span> **dev)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">hw_module_t</span> *mod;</div><div class="line">    <span class="keyword">int</span> rc;</div><div class="line">    rc = hw_get_module_by_class(AUDIO_HARDWARE_MODULE_ID, if_name, &amp;mod);</div><div class="line">    <span class="keyword">if</span> (rc) &#123;</div><div class="line">        ALOGE(<span class="string">"%s couldn't load audio hw module %s.%s (%s)"</span>, __func__,</div><div class="line">                AUDIO_HARDWARE_MODULE_ID, if_name, strerror(-rc));</div><div class="line">        <span class="keyword">goto</span> out;</div><div class="line">    &#125;</div><div class="line">    rc = audio_hw_device_open(mod, dev);</div><div class="line">    <span class="keyword">if</span> (rc) &#123;</div><div class="line">        ALOGE(<span class="string">"%s couldn't open audio hw device in %s.%s (%s)"</span>, __func__,</div><div class="line">                AUDIO_HARDWARE_MODULE_ID, if_name, strerror(-rc));</div><div class="line">        <span class="keyword">goto</span> out;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> ((*dev)-&gt;common.version &lt; AUDIO_DEVICE_API_VERSION_MIN) &#123;</div><div class="line">        ALOGE(<span class="string">"%s wrong audio hw device version %04x"</span>, __func__, (*dev)-&gt;common.version);</div><div class="line">        rc = -EINVAL;</div><div class="line">        audio_hw_device_close(*dev);</div><div class="line">        <span class="keyword">goto</span> out;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">out:</div><div class="line">    *dev = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">return</span> rc;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Methods from ::android::hardware::audio::V2_0::IDevicesFactory follow.</span></div><div class="line">Return&lt;<span class="keyword">void</span>&gt; DevicesFactory::openDevice(IDevicesFactory::Device device, </div><div class="line">                                        openDevice_cb _hidl_cb)  &#123;</div><div class="line">    <span class="keyword">audio_hw_device_t</span> *halDevice;</div><div class="line">    <span class="function">Result <span class="title">retval</span><span class="params">(Result::INVALID_ARGUMENTS)</span></span>;</div><div class="line">    sp&lt;IDevice&gt; result;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* moduleName = deviceToString(device);</div><div class="line">    <span class="keyword">if</span> (moduleName != <span class="literal">nullptr</span>) &#123;</div><div class="line">        <span class="keyword">int</span> halStatus = loadAudioInterface(moduleName, &amp;halDevice);</div><div class="line">        <span class="keyword">if</span> (halStatus == OK) &#123;</div><div class="line">            <span class="keyword">if</span> (device == IDevicesFactory::Device::PRIMARY) &#123;</div><div class="line">                result = <span class="keyword">new</span> PrimaryDevice(halDevice);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                result = <span class="keyword">new</span> ::android::hardware::audio::V2_0::implementation::</div><div class="line">                    Device(halDevice);</div><div class="line">            &#125;</div><div class="line">            retval = Result::OK;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (halStatus == -EINVAL) &#123;</div><div class="line">            retval = Result::NOT_INITIALIZED;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    _hidl_cb(retval, result);</div><div class="line">    <span class="keyword">return</span> Void();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们知道硬件抽象层（HAL）是连接driver和native的桥梁，数据会从native层到HAL层，最终写入kernel。然而8.0之前的HAL和native处于同一进程，耦合度比较高。所以在Android 8.0，google对HAL做了重构，将HAL放在独立的进程，和
      
    
    </summary>
    
      <category term="Android Audio HAL" scheme="http://yoursite.com/categories/Android-Audio-HAL/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Audio HIDL C++</title>
    <link href="http://yoursite.com/2017/11/24/Android-Audio-HIDL-C++/"/>
    <id>http://yoursite.com/2017/11/24/Android-Audio-HIDL-C++/</id>
    <published>2017-11-24T01:01:24.000Z</published>
    <updated>2017-12-05T09:20:41.880Z</updated>
    
    <content type="html"><![CDATA[<p>HAL接口定义语言（简称HIDL，发音为“hide-l”）是用于指定HAL和其用户之间的接口的一种接口描述语言 (IDL)。HIDL允许指定类型和方法调用（会汇集到接口和软件包中）。从更广泛的意义上来说，HIDL是用于在可以独立编译的代码库之间进行通信的系统。</p><p>HIDL旨在用于进程间通信 (IPC)。进程之间的通信经过Binder化。对于必须与进程相关联的代码库，还可以使用直通模式（在Java中不受支持）。</p><p>HIDL可指定数据结构和方法签名，这些内容会整理归类到接口（与类相似）中，而接口会汇集到软件包中。尽管HIDL具有一系列不同的关键字，但C++和Java程序员对HIDL的语法并不陌生。此外，HIDL还使用Java样式的注释。</p><h2 id="HAL分类"><a href="#HAL分类" class="headerlink" title="HAL分类"></a>HAL分类</h2><p>为了更好地实现模块化，Android 8.0对Android操作系统底层进行了重新架构。作为此变化的一部分，运行 Android 8.0的设备必须支持绑定式或直通式HAL：</p><ul><li><strong>绑定式HAL</strong>：以HAL接口定义语言 (HIDL) 表示的HAL。这些HAL取代了早期 Android 版本中使用的传统 HAL和旧版HAL。在绑定式HAL中，Android框架和HAL之间通过Binder进程间通信 (IPC) 调用进行通信。所有在推出时即搭载了Android 8.0或后续版本的设备都必须只支持绑定式HAL。</li><li><strong>直通式HAL</strong>：以HIDL封装的传统HAL或旧版HAL。这些HAL封装了现有的HAL，可在绑定模式和 Same-Process（直通）模式下使用。升级到 Android 8.0 的设备可以使用直通式HAL。</li></ul><h2 id="HAL的发展历程"><a href="#HAL的发展历程" class="headerlink" title="HAL的发展历程"></a>HAL的发展历程</h2><p>HIDL接口具有客户端和服务器实现：</p><ul><li>HIDL接口的客户端实现是指通过在该接口上调用方法来使用该接口的代码。</li><li>服务器实现是指HIDL接口的实现，它可接收来自客户端的调用并返回结果（如有必要）。</li></ul><p>在从libhardware HAL转换为HIDL HAL的过程中，HAL实现成为服务器，而调用HAL的进程则成为客户端。默认实现可提供直通和绑定式HAL，并可能会随着时间而发生变化：<br><img src="https://i.imgur.com/j26sMR2.png" alt=""></p><h2 id="Audio-HIDL客户端和服务端"><a href="#Audio-HIDL客户端和服务端" class="headerlink" title="Audio HIDL客户端和服务端"></a>Audio HIDL客户端和服务端</h2><h3 id="客户端创建"><a href="#客户端创建" class="headerlink" title="客户端创建"></a>客户端创建</h3><p>libaudioflinger.so会依赖libaudiohal.so<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LOCAL_SHARED_LIBRARIES += \</div><div class="line">    libaudiohal</div></pre></td></tr></table></figure></p><p>libaudiohal.so依赖android.hardware.audio@2.0.so<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LOCAL_SHARED_LIBRARIES += \</div><div class="line">    android.hardware.audio@2.0</div></pre></td></tr></table></figure></p><p>记得在AudioFlinger的启动过程中，在创建libaudiohal的DevicesFactoryHalHidl时有如下以一段代码，这里就是创建Audio HIDL的客户端。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/hardware/audio/2.0/IDevicesFactory.h&gt;</span></span></div><div class="line"></div><div class="line">DevicesFactoryHalHidl::DevicesFactoryHalHidl() &#123;</div><div class="line">    mDevicesFactory = IDevicesFactory::getService();</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="服务端创建"><a href="#服务端创建" class="headerlink" title="服务端创建"></a>服务端创建</h3><p>生成可执行文件android.hardware.audio@2.0-service代表服务端，同样依赖于android.hardware.audio@2.0<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LOCAL_MODULE := android.hardware.audio@2.0-service</div><div class="line">LOCAL_SHARED_LIBRARIES += \</div><div class="line">    android.hardware.audio@2.0</div></pre></td></tr></table></figure></p><p>为了让HAL在直通模式下发挥作用（对于旧版设备），您必须具有HIDL_FETCH_IModuleName 函数（位于/system/lib(64)?/hw/android.hardware.package@3.0-impl(-$OPTIONAL_IDENTIFIER).so下），其中$OPTIONAL_IDENTIFIER是一个标识直通实现的字符串。比如对于Audio,在android.hardware.audio@2.0-impl.so中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">IDevicesFactory* <span class="title">HIDL_FETCH_IDevicesFactory</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="comment">/* name */</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DevicesFactory();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>接下来，使用功能填写存根并设置守护进程。守护进程代码（支持直通）示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hidl/LegacySupport.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> <span class="comment">/* argc */</span>, <span class="keyword">char</span>* <span class="comment">/* argv */</span> [])</span> </span>&#123;</div><div class="line">    status = registerPassthroughServiceImplementation&lt;IDevicesFactory&gt;();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>registerPassthroughServiceImplementation将对提供的-impl库执行dlopen()操作，并将其作为绑定式服务提供。守护进程代码（对于纯绑定式服务）示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> <span class="comment">/* argc */</span>, <span class="keyword">char</span>* <span class="comment">/* argv */</span> [])</span> </span>&#123;</div><div class="line">    Nfc nfc = <span class="keyword">new</span> Nfc();</div><div class="line">    nfc-&gt;registerAsService();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>此守护进程应该存在于$PACKAGE + “-service”（例如android.hardware.audio@2.0-service）中。HAL的特定类的sepolicy是属性hal_<module>（例如 hal_audio))。您必须将此属性应用到运行特定HAL 的守护进程（如果同一进程提供多个HAL，则可以将多个属性应用到该进程）。</module></p><h2 id="Audio-HIDL接口软件包"><a href="#Audio-HIDL接口软件包" class="headerlink" title="Audio HIDL接口软件包"></a>Audio HIDL接口软件包</h2><p>HIDL接口软件包位于hardware/interfaces或vendor/目录下（少数例外情况除外）。hardware/interfaces顶层会直接映射到android.hardware软件包命名空间；版本是软件包（而不是接口）命名空间下的子目录。</p><p>hidl-gen编译器会将.hal文件编译成一组.h和.cpp文件。这些自动生成的文件可用来编译客户端/服务器实现链接到的共享库。用于编译此共享库的Android.bp文件由hardware/interfaces/update-makefiles.sh 脚本自动生成。每次将新软件包添加到hardware/interfaces或在现有软件包中添加/移除.hal文件时，您都必须重新运行该脚本，以确保生成的共享库是最新的。</p><h3 id="Auido-HIDL接口定义"><a href="#Auido-HIDL接口定义" class="headerlink" title="Auido HIDL接口定义"></a>Auido HIDL接口定义</h3><p>对于Audio，.hal文件位于hardware/interfaces/audio/2.0下，我们看看客户端和服务端同时使用的IDevicesFactory接口，该定义在IDevicesFactory.hal中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">package android.hardware.audio@<span class="number">2.0</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> android.hardware.audio.common@<span class="number">2.0</span>;</div><div class="line"><span class="keyword">import</span> IDevice;</div><div class="line"></div><div class="line">interface IDevicesFactory &#123;</div><div class="line">    <span class="keyword">typedef</span> android.hardware.audio@<span class="number">2.0</span>::Result Result;</div><div class="line"></div><div class="line">    <span class="keyword">enum</span> Device : <span class="keyword">int32_t</span> &#123;</div><div class="line">        PRIMARY,</div><div class="line">        A2DP,</div><div class="line">        USB,</div><div class="line">        R_SUBMIX,</div><div class="line">        STUB</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Opens an audio device. To close the device, it is necessary to release</span></div><div class="line"><span class="comment">     * references to the returned device object.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * @param device device type.</span></div><div class="line"><span class="comment">     * @return retval operation completion status. Returns INVALID_ARGUMENTS</span></div><div class="line"><span class="comment">     *         if there is no corresponding hardware module found,</span></div><div class="line"><span class="comment">     *         NOT_INITIALIZED if an error occured while opening the hardware</span></div><div class="line"><span class="comment">     *         module.</span></div><div class="line"><span class="comment">     * @return result the interface for the created device.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    openDevice(Device device) generates (Result retval, IDevice result);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h3 id="HIDL接口转化为cpp"><a href="#HIDL接口转化为cpp" class="headerlink" title="HIDL接口转化为cpp"></a>HIDL接口转化为cpp</h3><p>如下是编译android.hardware.audio@2.0的Android.bp,由hidl-gen自动产生，不能手动编辑。IDevicesFactory.hal会生成DevicesFactoryAll.cpp，及IDevicesFactory.h，IHwDevicesFactory.h，BnHwDevicesFactory.h，BpHwDevicesFactory.h，BsDevicesFactory.h。<br>生成的.h位于out/soong/.intermediates/hardware/interfaces/audio/2.0/android.hardware.audio@2.0_genc++_headers，<br>生成的.cpp文件位于out/soong/.intermediates/hardware/interfaces/audio/2.0/android.hardware.audio@2.0_genc++。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// This file is autogenerated by hidl-gen. Do not edit manually.</span></div><div class="line">filegroup &#123;</div><div class="line">    name: <span class="string">"android.hardware.audio@2.0_hal"</span>,</div><div class="line">    srcs: [</div><div class="line">        <span class="string">"types.hal"</span>,</div><div class="line">        <span class="string">"IDevice.hal"</span>,</div><div class="line">        <span class="string">"IDevicesFactory.hal"</span>,</div><div class="line">        <span class="string">"IPrimaryDevice.hal"</span>,</div><div class="line">        <span class="string">"IStream.hal"</span>,</div><div class="line">        <span class="string">"IStreamIn.hal"</span>,</div><div class="line">        <span class="string">"IStreamOut.hal"</span>,</div><div class="line">        <span class="string">"IStreamOutCallback.hal"</span>,</div><div class="line">    ],</div><div class="line">&#125;</div><div class="line">genrule &#123;</div><div class="line">    name: <span class="string">"android.hardware.audio@2.0_genc++"</span>,</div><div class="line">    tools: [<span class="string">"hidl-gen"</span>],</div><div class="line">    cmd: <span class="string">"$(location hidl-gen) -o $(genDir) -Lc++-sources </span></div><div class="line"><span class="string">         -randroid.hardware:hardware/interfaces </span></div><div class="line"><span class="string">         -randroid.hidl:system/libhidl/transport </span></div><div class="line"><span class="string">         android.hardware.audio@2.0"</span>,</div><div class="line">    srcs: [</div><div class="line">        <span class="string">":android.hardware.audio@2.0_hal"</span>,</div><div class="line">    ],</div><div class="line">    out: [</div><div class="line">        <span class="string">"android/hardware/audio/2.0/types.cpp"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/DeviceAll.cpp"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/DevicesFactoryAll.cpp"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/PrimaryDeviceAll.cpp"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/StreamAll.cpp"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/StreamInAll.cpp"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/StreamOutAll.cpp"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/StreamOutCallbackAll.cpp"</span>,</div><div class="line">    ],</div><div class="line">&#125;</div><div class="line">genrule &#123;</div><div class="line">    name: <span class="string">"android.hardware.audio@2.0_genc++_headers"</span>,</div><div class="line">    tools: [<span class="string">"hidl-gen"</span>],</div><div class="line">    cmd: <span class="string">"$(location hidl-gen) -o $(genDir) -Lc++-headers </span></div><div class="line"><span class="string">         -randroid.hardware:hardware/interfaces </span></div><div class="line"><span class="string">         -randroid.hidl:system/libhidl/transport </span></div><div class="line"><span class="string">         android.hardware.audio@2.0"</span>,</div><div class="line">    srcs: [</div><div class="line">        <span class="string">":android.hardware.audio@2.0_hal"</span>,</div><div class="line">    ],</div><div class="line">    out: [</div><div class="line">        <span class="string">"android/hardware/audio/2.0/types.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/hwtypes.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/IDevice.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/IHwDevice.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BnHwDevice.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BpHwDevice.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BsDevice.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/IDevicesFactory.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/IHwDevicesFactory.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BnHwDevicesFactory.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BpHwDevicesFactory.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BsDevicesFactory.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/IPrimaryDevice.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/IHwPrimaryDevice.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BnHwPrimaryDevice.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BpHwPrimaryDevice.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BsPrimaryDevice.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/IStream.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/IHwStream.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BnHwStream.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BpHwStream.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BsStream.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/IStreamIn.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/IHwStreamIn.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BnHwStreamIn.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BpHwStreamIn.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BsStreamIn.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/IStreamOut.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/IHwStreamOut.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BnHwStreamOut.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BpHwStreamOut.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BsStreamOut.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/IStreamOutCallback.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/IHwStreamOutCallback.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BnHwStreamOutCallback.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BpHwStreamOutCallback.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BsStreamOutCallback.h"</span>,</div><div class="line">    ],</div><div class="line">&#125;</div><div class="line">cc_library_shared &#123;</div><div class="line">    name: <span class="string">"android.hardware.audio@2.0"</span>,</div><div class="line">    defaults: [<span class="string">"hidl-module-defaults"</span>],</div><div class="line">    generated_sources: [<span class="string">"android.hardware.audio@2.0_genc++"</span>],</div><div class="line">    generated_headers: [<span class="string">"android.hardware.audio@2.0_genc++_headers"</span>],</div><div class="line">    export_generated_headers: [<span class="string">"android.hardware.audio@2.0_genc++_headers"</span>],</div><div class="line">    vendor_available: <span class="literal">true</span>,</div><div class="line">    shared_libs: [</div><div class="line">        <span class="string">"libhidlbase"</span>,</div><div class="line">        <span class="string">"libhidltransport"</span>,</div><div class="line">        <span class="string">"libhwbinder"</span>,</div><div class="line">        <span class="string">"liblog"</span>,</div><div class="line">        <span class="string">"libutils"</span>,</div><div class="line">        <span class="string">"libcutils"</span>,</div><div class="line">        <span class="string">"android.hardware.audio.common@2.0"</span>,</div><div class="line">    ],</div><div class="line">    export_shared_lib_headers: [</div><div class="line">        <span class="string">"libhidlbase"</span>,</div><div class="line">        <span class="string">"libhidltransport"</span>,</div><div class="line">        <span class="string">"libhwbinder"</span>,</div><div class="line">        <span class="string">"libutils"</span>,</div><div class="line">        <span class="string">"android.hardware.audio.common@2.0"</span>,</div><div class="line">    ],</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://i.imgur.com/C23pi5i.png" alt=""></p><ul><li>IDevicesFactory.h - 描述C++类中的纯IDevicesFactory接口；它包含IDevicesFactory.hal文件中的IDevicesFactory接口中所定义的方法和类型，必要时会转换为C++类型。不包含与用于实现此接口的RPC机制（例如HwBinder）相关的详细信息。类的命名空间包含软件包名称和版本号，例如::android::hardware::audio::V2_0::IDevicesFactory。客户端和服务器都包含此标头：客户端用它来调用方法，服务器用它来实现这些方法。</li><li>IHwDevicesFactory.h - 头文件，其中包含用于对接口中使用的数据类型进行序列化的函数的声明。开发者不得直接包含其标头（它不包含任何类）</li><li>BpHwDevicesFactory.h - 从IDevicesFactory继承的类，可描述接口的HwBinder代理（客户端）实现。开发者不得直接引用此类。</li><li>BnHwDevicesFactory.h - 保存对IDevicesFactory实现的引用的类，可描述接口的HwBinder存根（服务器端）实现。开发者不得直接引用此类。</li><li>DevicesFactoryAll.cpp - 包含HwBinder代理和HwBinder存根的实现的类。当客户端调用接口方法时，代理会自动从客户端封送参数，并将事务发送到绑定内核驱动程序，该内核驱动程序会将事务传送到另一端的存根（该存根随后会调用实际的服务器实现）</li><li>BsDevicesFactory.h - 从IDevicesFactory继承的类，直通模式对IDevicesFactory的服务端实现。开发者不得直接引用此类。</li></ul><p>这些文件的结构类似于由aidl-cpp生成的文件。独立于HIDL使用的RPC机制的唯一一个自动生成的文件是 IDevicesFactory.h，其他所有文件都与HIDL使用的HwBinder RPC机制相关联。因此，客户端和服务器实现不得直接引用除IDevicesFactory之外的任何内容。为了满足这项要求，请只包含IDevicesFactory.h并链接到生成的共享库。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HAL接口定义语言（简称HIDL，发音为“hide-l”）是用于指定HAL和其用户之间的接口的一种接口描述语言 (IDL)。HIDL允许指定类型和方法调用（会汇集到接口和软件包中）。从更广泛的意义上来说，HIDL是用于在可以独立编译的代码库之间进行通信的系统。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="Android Audio HAL" scheme="http://yoursite.com/categories/Android-Audio-HAL/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>AudioPolicyService启动过程</title>
    <link href="http://yoursite.com/2017/11/10/AudioPolicyService%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/11/10/AudioPolicyService启动过程/</id>
    <published>2017-11-10T12:39:29.000Z</published>
    <updated>2017-11-21T12:15:30.239Z</updated>
    
    <content type="html"><![CDATA[<p>AudioPolicyService在Audio系统另一个重要的服务，是音频策略的制定者，负责音频设备切换的策略抉择、音量调节策略等。本文基于Android 8.0的代码，记录了AudioPolicyService启动的过程，介绍了其中几个比较关键的点，希望以后自己看到此文能快速回想起AudioPolicyService的启动过程。其代码位于frameworks/av/services/audiopolicy。</p><h2 id="audiopolicy的代码结构"><a href="#audiopolicy的代码结构" class="headerlink" title="audiopolicy的代码结构"></a>audiopolicy的代码结构</h2><ol><li>service目录是AudioPolicyService、AudioPolicyClient、AudioCommandThread及AudioPolicyEffects的定义及实现。</li><li>managerdefault目录提供AudioPolicyManager的基本实现。</li><li>manager目录中是一个工厂类可以根据需要生产所需的AudioPolicyManager，一般各个厂商都会自己实现自己的AudioPolicyManager。</li><li>engine目录定义了AudioPolicyManagerInterface和AudioPolicyManagerObserver接口，<br>AudioPolicyManagerInterface由Policy Engine实现，AudioPolicyManagerObserver这个观察者由AudioPolicyManager实现，以供Engine访问。</li><li>engineconfigure和enginedefault目录是Policy Engine的两种实现，可以根据需要选择其中一种。</li><li>config目录存放audio policy及音量曲线的config文件。</li><li>common目录下定义公共代码。audio_policy.conf是旧版本的audio policy config文件。</li><li>AudioPolicyInterface.h定义了AudioPolicyInterface和AudioPolicyClientInterface接口，AudioPolicyInterface由AuidoPolicyManager实现，特定平台AuidoPolicyManager通过AudioPolicyClientInterface接口的实现者AudioPolicyClient控制音频的输入输出。<br><img src="https://i.imgur.com/kZpNl4i.png" alt=""><h2 id="AudioPolicyService初始化"><a href="#AudioPolicyService初始化" class="headerlink" title="AudioPolicyService初始化"></a>AudioPolicyService初始化</h2>从Android 8.0的code发现，基本流程还是和之前一样，分别创建了ApmTone、ApmAudio、ApmOutput三个AudioCommandThread线程，分别用于播放tone音、执行audio命令和执行输出命令，创建AudioPolicyClient，创建AudioPolicyManager以及创建AudioPolicyEffects。但已经完全移除了对旧版本的AUDIO_POLICY_HARDWARE_MODULE_ID的支持（不再加载audio_policy.default.so库得到audio_policy_module模块），完全使用新模式。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">AudioPolicyService::AudioPolicyService()</div><div class="line">    : BnAudioPolicyService(), mpAudioPolicyDev(<span class="literal">NULL</span>), mpAudioPolicy(<span class="literal">NULL</span>),</div><div class="line">      mAudioPolicyManager(<span class="literal">NULL</span>), mAudioPolicyClient(<span class="literal">NULL</span>), mPhoneState(AUDIO_MODE_INVALID)</div><div class="line">&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> AudioPolicyService::onFirstRef()</div><div class="line">&#123;</div><div class="line">    &#123;</div><div class="line">        Mutex::Autolock _l(mLock);</div><div class="line"></div><div class="line">        <span class="comment">// start tone playback thread</span></div><div class="line">        mTonePlaybackThread = <span class="keyword">new</span> AudioCommandThread(String8(<span class="string">"ApmTone"</span>), <span class="keyword">this</span>);</div><div class="line">        <span class="comment">// start audio commands thread</span></div><div class="line">        mAudioCommandThread = <span class="keyword">new</span> AudioCommandThread(String8(<span class="string">"ApmAudio"</span>), <span class="keyword">this</span>);</div><div class="line">        <span class="comment">// start output activity command thread</span></div><div class="line">        mOutputCommandThread = <span class="keyword">new</span> AudioCommandThread(String8(<span class="string">"ApmOutput"</span>), <span class="keyword">this</span>);</div><div class="line"></div><div class="line">        mAudioPolicyClient = <span class="keyword">new</span> AudioPolicyClient(<span class="keyword">this</span>);</div><div class="line">        mAudioPolicyManager = createAudioPolicyManager(mAudioPolicyClient);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// load audio processing modules</span></div><div class="line">    sp&lt;AudioPolicyEffects&gt;audioPolicyEffects = <span class="keyword">new</span> AudioPolicyEffects();</div><div class="line">    &#123;</div><div class="line">        Mutex::Autolock _l(mLock);</div><div class="line">        mAudioPolicyEffects = audioPolicyEffects;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>这些类之间的大致关系如下（AudioPolicyClient和AudioCommandThread都为AudioPolicyService的内部类）：<br><img src="https://i.imgur.com/wNiugU3.png" alt=""><br>AudioPolicyService的初始化大致分为3步：<br>1.创建三个AudioCommandThread（mTonePlaybackThread，mAudioCommandThread和mOutputCommandThread）<br>2.初始化AudioPolicyManager<br> 2.1 加载并解析audio_policy_configuration.xml<br> 2.2 加载对应的HW module<br> 2.3 初始化Policy Engine<br> 2.4 打开输入输出<br> 2.5 确保所有可用输入输出设备和默认输出设备真正可用<br>3.初始化AudioPolicyEffects</p><h2 id="AudioCommandThread线程"><a href="#AudioCommandThread线程" class="headerlink" title="AudioCommandThread线程"></a>AudioCommandThread线程</h2><p>AudioCommandThread采用异步方式来执行audio command，当需要执行上表中的命令时，首先将命令投递到AudioCommandThread的mAudioCommands命令向量表中，然后通过mWaitWorkCV.signal()唤醒AudioCommandThread线程，被唤醒的AudioCommandThread线程执行完command后，又通过mWaitWorkCV.waitRelative(mLock, waitTime)睡眠等待命令到来。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> AudioPolicyService::AudioCommandThread::onFirstRef()</div><div class="line">&#123;</div><div class="line">    run(mName.<span class="built_in">string</span>(), ANDROID_PRIORITY_AUDIO);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">status_t</span> AudioPolicyService::AudioCommandThread::volumeCommand(<span class="keyword">audio_stream_type_t</span> stream,</div><div class="line">                              <span class="keyword">float</span> volume, <span class="keyword">audio_io_handle_t</span> output, <span class="keyword">int</span> delayMs)</div><div class="line">&#123;</div><div class="line">    sp&lt;AudioCommand&gt; command = <span class="keyword">new</span> AudioCommand();</div><div class="line">    command-&gt;mCommand = SET_VOLUME;</div><div class="line">    sp&lt;VolumeData&gt; data = <span class="keyword">new</span> VolumeData();</div><div class="line">    data-&gt;mStream = stream;</div><div class="line">    data-&gt;mVolume = volume;</div><div class="line">    data-&gt;mIO = output;</div><div class="line">    command-&gt;mParam = data;</div><div class="line">    command-&gt;mWaitStatus = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">return</span> sendCommand(command, delayMs);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">bool</span> AudioPolicyService::AudioCommandThread::threadLoop()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">nsecs_t</span> waitTime = <span class="number">-1</span>;</div><div class="line"></div><div class="line">    mLock.lock();</div><div class="line">    <span class="keyword">while</span> (!exitPending())</div><div class="line">    &#123;</div><div class="line">        sp&lt;AudioPolicyService&gt; svc;</div><div class="line">        <span class="keyword">while</span> (!mAudioCommands.isEmpty() &amp;&amp; !exitPending()) &#123;</div><div class="line">            <span class="keyword">nsecs_t</span> curTime = systemTime();</div><div class="line">            <span class="comment">// commands are sorted by increasing time stamp: execute them from index 0 and up</span></div><div class="line">            <span class="keyword">if</span> (mAudioCommands[<span class="number">0</span>]-&gt;mTime &lt;= curTime) &#123;</div><div class="line">                sp&lt;AudioCommand&gt; command = mAudioCommands[<span class="number">0</span>];</div><div class="line">                mAudioCommands.removeAt(<span class="number">0</span>);</div><div class="line">                mLastCommand = command;</div><div class="line"></div><div class="line">                <span class="keyword">switch</span> (command-&gt;mCommand) &#123;</div><div class="line"></div><div class="line">                ......</div><div class="line"></div><div class="line">                <span class="keyword">case</span> SET_VOLUME: &#123;</div><div class="line">                    VolumeData *data = (VolumeData *)command-&gt;mParam.get();</div><div class="line">                    ALOGV(<span class="string">"AudioCommandThread() processing set volume stream %d, \</span></div><div class="line"><span class="string">                            volume %f, output %d"</span>, data-&gt;mStream, data-&gt;mVolume, data-&gt;mIO);</div><div class="line">                    command-&gt;mStatus = AudioSystem::setStreamVolume(data-&gt;mStream,</div><div class="line">                                                                    data-&gt;mVolume,</div><div class="line">                                                                    data-&gt;mIO);</div><div class="line">                    &#125;<span class="keyword">break</span>;</div><div class="line"></div><div class="line">                ......</div><div class="line"></div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                .....</div><div class="line"></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                waitTime = mAudioCommands[<span class="number">0</span>]-&gt;mTime - curTime;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ......</div><div class="line"></div><div class="line">        <span class="comment">// At this stage we have either an empty command queue or the first command in the queue</span></div><div class="line">        <span class="comment">// has a finite delay. So unless we are exiting it is safe to wait.</span></div><div class="line">        <span class="keyword">if</span> (!exitPending()) &#123;</div><div class="line">            ALOGV(<span class="string">"AudioCommandThread() going to sleep"</span>);</div><div class="line">            <span class="keyword">if</span> (waitTime == <span class="number">-1</span>) &#123;</div><div class="line">                mWaitWorkCV.wait(mLock);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                mWaitWorkCV.waitRelative(mLock, waitTime);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ......</div><div class="line"></div><div class="line">    mLock.unlock();</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>AudioCommandThread是AudioPolicyService的内部类，AudioCommandThread在内部又定义了AudioCommand及AudioCommandData关系如下。<br><img src="https://i.imgur.com/6IUY98f.png" alt=""></p><h2 id="AudioPolicyManager初始化"><a href="#AudioPolicyManager初始化" class="headerlink" title="AudioPolicyManager初始化"></a>AudioPolicyManager初始化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">AudioPolicyManager::AudioPolicyManager(AudioPolicyClientInterface *clientInterface)</div><div class="line">    :</div><div class="line">    mLimitRingtoneVolume(<span class="literal">false</span>), mLastVoiceVolume(<span class="number">-1.0f</span>),</div><div class="line">    mA2dpSuspended(<span class="literal">false</span>),</div><div class="line">    mAudioPortGeneration(<span class="number">1</span>),</div><div class="line">    mBeaconMuteRefCount(<span class="number">0</span>),</div><div class="line">    mBeaconPlayingRefCount(<span class="number">0</span>),</div><div class="line">    mBeaconMuted(<span class="literal">false</span>),</div><div class="line">    mTtsOutputAvailable(<span class="literal">false</span>),</div><div class="line">    mMasterMono(<span class="literal">false</span>),</div><div class="line">    mMusicEffectOutput(AUDIO_IO_HANDLE_NONE),</div><div class="line">    mHasComputedSoundTriggerSupportsConcurrentCapture(<span class="literal">false</span>)</div><div class="line">&#123;</div><div class="line">    mUidCached = getuid();</div><div class="line">    mpClientInterface = clientInterface;</div><div class="line"></div><div class="line">    ...... </div><div class="line">    <span class="comment">// audio policy config加载</span></div><div class="line"></div><div class="line">    <span class="comment">// 初始化Policy Engine</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mHwModules.size(); i++) &#123;</div><div class="line">        <span class="comment">// 加载所有的HW module</span></div><div class="line">        ......</div><div class="line">        <span class="comment">// 打开音频输入输出</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 确保所有可用输入输出设备真正可用</span></div><div class="line">    ......</div><div class="line"></div><div class="line">    <span class="comment">// 确保默认输出设备真正可用</span></div><div class="line">    ALOGE_IF((mPrimaryOutput == <span class="number">0</span>), <span class="string">"Failed to open primary output"</span>);</div><div class="line">    updateDevicesAndOutputs();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="audio-policy-config加载"><a href="#audio-policy-config加载" class="headerlink" title="audio policy config加载"></a>audio policy config加载</h3><p>进入AudioPolicyManager构造函数，会首先加载audio policy config文件，对于旧版本使用audio_policy.conf，在代码中定义音量曲线，对于新版本使用audio_policy_configuration.xml。对于Android 8.0使用新版本，这个文件一般会位于/odm/etc或/vendor/etc，同时解析音量曲线xml（audio_policy_volumes.xml和default_volume_tables.xml）,比起之前的硬编码音量曲线，灵活性更好。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_XML_AUDIO_POLICY_CONF</span></div><div class="line">    mVolumeCurves = <span class="keyword">new</span> VolumeCurvesCollection();</div><div class="line">    <span class="function">AudioPolicyConfig <span class="title">config</span><span class="params">(mHwModules, mAvailableOutputDevices, mAvailableInputDevices,</span></span></div><div class="line"><span class="function"><span class="params">                             mDefaultOutputDevice, speakerDrcEnabled,</span></span></div><div class="line">                             static_cast&lt;VolumeCurvesCollection *&gt;(mVolumeCurves));</div><div class="line">    <span class="keyword">if</span> (deserializeAudioPolicyXmlConfig(config) != NO_ERROR) &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    mVolumeCurves = <span class="keyword">new</span> StreamDescriptorCollection();</div><div class="line">    <span class="function">AudioPolicyConfig <span class="title">config</span><span class="params">(mHwModules, mAvailableOutputDevices, mAvailableInputDevices,</span></span></div><div class="line"><span class="function"><span class="params">                             mDefaultOutputDevice, speakerDrcEnabled)</span></span>;</div><div class="line">    <span class="keyword">if</span> ((ConfigParsingUtils::loadConfig(AUDIO_POLICY_VENDOR_CONFIG_FILE, config) != NO_ERROR) &amp;&amp;</div><div class="line">            (ConfigParsingUtils::loadConfig(AUDIO_POLICY_CONFIG_FILE, config) != NO_ERROR)) &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">        ALOGE(<span class="string">"could not load audio policy configuration file, setting defaults"</span>);</div><div class="line">        config.setDefault();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// must be done after reading the policy (since conditionned by Speaker Drc Enabling)</span></div><div class="line">    <span class="comment">// xml模式时这里是一个空函数无实现</span></div><div class="line">    mVolumeCurves-&gt;initializeVolumeCurves(speakerDrcEnabled);</div></pre></td></tr></table></figure></p><p>当执行完deserializeAudioPolicyXmlConfig，会得到mHwModules对应各个Audio HAL模块、mAvailableOutputDevices可用的输出设备、mAvailableInputDevices可用的输入设备、mDefaultOutputDevice默认输出设备、mVolumeCurves音量曲线及speakerDrcEnabled。</p><p>audio_policy_configuration.xml同时定义了多个audio接口(HwModules)，每一个audio接口包含若干routes（通路）、devicesPorts（设备）和mixPorts（音频流），而每个mixPorts又包含多个input和output流，每个input和output流又同时支持多种输入输出模式，每种输入输出模式又支持若干种设备。<br>mixPorts：listing all output and input streams exposed by the audio HAL.<br>routes：list of possible connections between input and output devices or between stream and devices.<br>devicePorts：a list of device descriptors for all input and output devices accessible via this module.This contains both permanently attached devices and removable devices.<br><img src="https://i.imgur.com/eEXkdfk.png" alt=""><br>每个stream type会分为四种device category：DEVICE_CATEGORY_HEADSET，DEVICE_CATEGORY_SPEAKER，DEVICE_CATEGORY_EARPIECE及DEVICE_CATEGORY_EXT_MEDIA来定义音量曲线，定义的形式如下，一样是分段定义，在每一段中定义不同的衰减值以控制音量的大小。<br>It contains a list of points of this curve expressing the attenuation in Millibels for a given volume index from 0 to 100.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">volume</span> <span class="attr">stream</span>=<span class="string">"AUDIO_STREAM_VOICE_CALL"</span> <span class="attr">deviceCategory</span>=<span class="string">"DEVICE_CATEGORY_HEADSET"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">point</span>&gt;</span>0,-4200<span class="tag">&lt;/<span class="name">point</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">point</span>&gt;</span>33,-2800<span class="tag">&lt;/<span class="name">point</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">point</span>&gt;</span>66,-1400<span class="tag">&lt;/<span class="name">point</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">point</span>&gt;</span>100,0<span class="tag">&lt;/<span class="name">point</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">volume</span>&gt;</span></div></pre></td></tr></table></figure></p><h3 id="初始化Policy-Engine"><a href="#初始化Policy-Engine" class="headerlink" title="初始化Policy Engine"></a>初始化Policy Engine</h3><p>这里也算一个观察者模式吧，EngineInstance是单例模式，通过EngineInstance创建AudioPolicyManagerInterface，从而创建Policy Engine，然后设置观察者。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Once policy config has been parsed, retrieve an instance of the engine and initialize it.</span></div><div class="line">    audio_policy::EngineInstance *engineInstance = audio_policy::EngineInstance::getInstance();</div><div class="line">    <span class="keyword">if</span> (!engineInstance) &#123;</div><div class="line">        ALOGE(<span class="string">"%s:  Could not get an instance of policy engine"</span>, __FUNCTION__);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Retrieve the Policy Manager Interface</span></div><div class="line">    mEngine = engineInstance-&gt;queryInterface&lt;AudioPolicyManagerInterface&gt;();</div><div class="line">    <span class="keyword">if</span> (mEngine == <span class="literal">NULL</span>) &#123;</div><div class="line">        ALOGE(<span class="string">"%s: Failed to get Policy Engine Interface"</span>, __FUNCTION__);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    mEngine-&gt;setObserver(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">status_t</span> status = mEngine-&gt;initCheck();</div><div class="line">    (<span class="keyword">void</span>) status;</div><div class="line">    ALOG_ASSERT(status == NO_ERROR, <span class="string">"Policy engine not initialized(err=%d)"</span>, status);</div></pre></td></tr></table></figure></p><p>其大致关系如下。<br><img src="https://i.imgur.com/PDHsnQK.png" alt=""></p><h3 id="加载HW-Module"><a href="#加载HW-Module" class="headerlink" title="加载HW Module"></a>加载HW Module</h3><p>根据audio policy config加载的HwModule真正加载HAL层的HW module。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// mAvailableOutputDevices and mAvailableInputDevices now contain all attached devices</span></div><div class="line"><span class="comment">// open all output streams needed to access attached devices</span></div><div class="line"><span class="keyword">audio_devices_t</span> outputDeviceTypes = mAvailableOutputDevices.types();</div><div class="line"><span class="keyword">audio_devices_t</span> inputDeviceTypes = mAvailableInputDevices.types() &amp; ~AUDIO_DEVICE_BIT_IN;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mHwModules.size(); i++) &#123;</div><div class="line">    mHwModules[i]-&gt;mHandle = mpClientInterface-&gt;loadHwModule(mHwModules[i]-&gt;getName());</div><div class="line">    <span class="keyword">if</span> (mHwModules[i]-&gt;mHandle == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>从如上代码看出，会执行mpClientInterface-&gt;loadHwModule，即调用AudioPolicyClient的loadHwModule函数，又会转到AudioFlinger的loadHwModule。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">audio_module_handle_t</span> AudioPolicyService::AudioPolicyClient::loadHwModule(<span class="keyword">const</span> <span class="keyword">char</span> *name)</div><div class="line">&#123;</div><div class="line">    sp&lt;IAudioFlinger&gt; af = AudioSystem::get_audio_flinger();</div><div class="line">    <span class="keyword">if</span> (af == <span class="number">0</span>) &#123;</div><div class="line">        ALOGW(<span class="string">"%s: could not get AudioFlinger"</span>, __func__);</div><div class="line">        <span class="keyword">return</span> AUDIO_MODULE_HANDLE_NONE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> af-&gt;loadHwModule(name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">audio_module_handle_t</span> AudioFlinger::loadHwModule(<span class="keyword">const</span> <span class="keyword">char</span> *name)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (name == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> AUDIO_MODULE_HANDLE_NONE;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!settingsAllowed()) &#123;</div><div class="line">        <span class="keyword">return</span> AUDIO_MODULE_HANDLE_NONE;</div><div class="line">    &#125;</div><div class="line">    Mutex::Autolock _l(mLock);</div><div class="line">    <span class="keyword">return</span> loadHwModule_l(name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// loadHwModule_l() must be called with AudioFlinger::mLock held</span></div><div class="line"><span class="keyword">audio_module_handle_t</span> AudioFlinger::loadHwModule_l(<span class="keyword">const</span> <span class="keyword">char</span> *name)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mAudioHwDevs.size(); i++) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(mAudioHwDevs.valueAt(i)-&gt;moduleName(), name, <span class="built_in">strlen</span>(name)) == <span class="number">0</span>) &#123;</div><div class="line">            ALOGW(<span class="string">"loadHwModule() module %s already loaded"</span>, name);</div><div class="line">            <span class="keyword">return</span> mAudioHwDevs.keyAt(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sp&lt;DeviceHalInterface&gt; dev;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> rc = mDevicesFactoryHal-&gt;openDevice(name, &amp;dev);</div><div class="line">    <span class="keyword">if</span> (rc) &#123;</div><div class="line">        ALOGE(<span class="string">"loadHwModule() error %d loading module %s"</span>, rc, name);</div><div class="line">        <span class="keyword">return</span> AUDIO_MODULE_HANDLE_NONE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">    <span class="comment">// Check and cache this HAL's level of support for master mute and master</span></div><div class="line">    <span class="comment">// volume.  If this is the first HAL opened, and it supports the get</span></div><div class="line">    <span class="comment">// methods, use the initial values provided by the HAL as the current</span></div><div class="line">    <span class="comment">// master mute and volume settings.</span></div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">    <span class="keyword">audio_module_handle_t</span> handle = </div><div class="line">          (<span class="keyword">audio_module_handle_t</span>) nextUniqueId(AUDIO_UNIQUE_ID_USE_MODULE);</div><div class="line">    mAudioHwDevs.add(handle, <span class="keyword">new</span> AudioHwDevice(handle, name, dev, flags));</div><div class="line"></div><div class="line">    ALOGI(<span class="string">"loadHwModule() Loaded %s audio interface, handle %d"</span>, name, handle);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> handle;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>mDevicesFactoryHal-&gt;openDevice(name, &amp;dev),从前面AudioFlinger的启动，我们知道mDevicesFactoryHal是HAL进程的客户端，对于Android 8.0加载HAL so文件已经移到HAL进程中，不再与audioserver处于同一个进程中。在AudioFlinger中使用AudioHwDevice代表HW Module，AudioHwDevice会封装audio_module_handle_t和DeviceHalInterface，并以audio_module_handle_t为key将其保存在AudioFlinger的mAudioHwDevs中，以供后续查询。<br>到这里就加载系统的音频接口就加载完了，我们大致可以得出如下结果。<br><img src="https://i.imgur.com/ou4M7xS.png" alt=""></p><h3 id="打开音频输出"><a href="#打开音频输出" class="headerlink" title="打开音频输出"></a>打开音频输出</h3><p>这里的输出，即mixPorts中outputs，也就是mHwModules中所有OutputProfile（IOProfile），代表了音频输出流。所以会遍历mHwModules中所有OutputProfile，然后SwAudioOutputDescriptor来描述每一个output，最终保存在以audio_io_handle_t为key的mOutputs中，以供后续查询。不过这里会除了AUDIO_OUTPUT_FLAG_DIRECT，AUDIO_OUTPUT_FLAG_DIRECT的output会在使用的时候打开，不会预先open。在打开输出设备后还会标记可用输出设备的可用情况，以备后续确认可用输出设备真正可用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// open all output streams needed to access attached devices</span></div><div class="line"><span class="comment">// except for direct output streams that are only opened when they are actually</span></div><div class="line"><span class="comment">// required by an app.</span></div><div class="line"><span class="comment">// This also validates mAvailableOutputDevices list</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; mHwModules[i]-&gt;mOutputProfiles.size(); j++)</div><div class="line">&#123;</div><div class="line">     <span class="keyword">const</span> sp&lt;IOProfile&gt; outProfile = mHwModules[i]-&gt;mOutputProfiles[j];</div><div class="line">     <span class="keyword">if</span> (!outProfile-&gt;hasSupportedDevices()) &#123;</div><div class="line">         <span class="keyword">continue</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">if</span> ((outProfile-&gt;getFlags() &amp; AUDIO_OUTPUT_FLAG_TTS) != <span class="number">0</span>) &#123;</div><div class="line">         mTtsOutputAvailable = <span class="literal">true</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">if</span> ((outProfile-&gt;getFlags() &amp; AUDIO_OUTPUT_FLAG_DIRECT) != <span class="number">0</span>) &#123;</div><div class="line">         <span class="keyword">continue</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">audio_devices_t</span> profileType = outProfile-&gt;getSupportedDevicesType();</div><div class="line">     <span class="keyword">if</span> ((profileType &amp; mDefaultOutputDevice-&gt;type()) != AUDIO_DEVICE_NONE) &#123;</div><div class="line">         profileType = mDefaultOutputDevice-&gt;type();</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">         <span class="comment">// chose first device present in profile's SupportedDevices also part of</span></div><div class="line">         <span class="comment">// outputDeviceTypes</span></div><div class="line">         profileType = outProfile-&gt;getSupportedDeviceForType(outputDeviceTypes);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">if</span> ((profileType &amp; outputDeviceTypes) == <span class="number">0</span>) &#123;</div><div class="line">         <span class="keyword">continue</span>;</div><div class="line">     &#125;</div><div class="line">     sp&lt;SwAudioOutputDescriptor&gt; outputDesc = </div><div class="line">                       <span class="keyword">new</span> SwAudioOutputDescriptor(outProfile, mpClientInterface);</div><div class="line">     <span class="keyword">const</span> DeviceVector &amp;supportedDevices = outProfile-&gt;getSupportedDevices();</div><div class="line">     <span class="keyword">const</span> DeviceVector &amp;devicesForType = </div><div class="line">                           supportedDevices.getDevicesFromType(profileType);</div><div class="line">     String8 address = devicesForType.size() &gt; <span class="number">0</span> </div><div class="line">                       ? devicesForType.itemAt(<span class="number">0</span>)-&gt;mAddress : String8(<span class="string">""</span>);</div><div class="line">     outputDesc-&gt;mDevice = profileType;</div><div class="line">     <span class="keyword">audio_config_t</span> config = AUDIO_CONFIG_INITIALIZER;</div><div class="line">     config.sample_rate = outputDesc-&gt;mSamplingRate;</div><div class="line">     config.channel_mask = outputDesc-&gt;mChannelMask;</div><div class="line">     config.format = outputDesc-&gt;mFormat;</div><div class="line">     <span class="keyword">audio_io_handle_t</span> output = AUDIO_IO_HANDLE_NONE;</div><div class="line">     <span class="keyword">status_t</span> status = mpClientInterface-&gt;openOutput(outProfile-&gt;getModuleHandle(),</div><div class="line">                                                     &amp;output,</div><div class="line">                                                     &amp;config,</div><div class="line">                                                     &amp;outputDesc-&gt;mDevice,</div><div class="line">                                                     address,</div><div class="line">                                                     &amp;outputDesc-&gt;mLatency,</div><div class="line">                                                     outputDesc-&gt;mFlags);</div><div class="line">     <span class="keyword">if</span> (status != NO_ERROR) &#123;</div><div class="line">         ......</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">         outputDesc-&gt;mSamplingRate = config.sample_rate;</div><div class="line">         outputDesc-&gt;mChannelMask = config.channel_mask;</div><div class="line">         outputDesc-&gt;mFormat = config.format;</div><div class="line">         <span class="keyword">for</span> (<span class="keyword">size_t</span> k = <span class="number">0</span>; k  &lt; supportedDevices.size(); k++) &#123;</div><div class="line">              <span class="keyword">ssize_t</span> index = mAvailableOutputDevices.indexOf(supportedDevices[k]);</div><div class="line">              <span class="comment">// give a valid ID to an attached device once confirmed it is reachable</span></div><div class="line">              <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; !mAvailableOutputDevices[index]-&gt;isAttached()) &#123;</div><div class="line">                  mAvailableOutputDevices[index]-&gt;attach(mHwModules[i]);</div><div class="line">              &#125;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">if</span> (mPrimaryOutput == <span class="number">0</span> &amp;&amp;</div><div class="line">                     outProfile-&gt;getFlags() &amp; AUDIO_OUTPUT_FLAG_PRIMARY) &#123;</div><div class="line">             mPrimaryOutput = outputDesc;</div><div class="line">         &#125;</div><div class="line">         addOutput(output, outputDesc);</div><div class="line">         setOutputDevice(outputDesc,</div><div class="line">                         outputDesc-&gt;mDevice,</div><div class="line">                         <span class="literal">true</span>,</div><div class="line">                         <span class="number">0</span>,</div><div class="line">                         <span class="literal">NULL</span>,</div><div class="line">                         address.<span class="built_in">string</span>());</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们看到会使用到mpClientInterface打开输出，即调用AudioPolicyClient的openOutput，即调用<br>AudioFlinger的openOutput及openOutput_l。首先调用findSuitableHwDev_l查询合适的AudioHwDevice，即通过audio_module_handle_t在之前加载的mAudioHwDevs中去除对应的AudioHwDevice，调用AudioHwDevice的openOutputStream得到AudioStreamOut，然后根据output flag创建相应的Thread，最后以audio_io_handle_t为key将Thread保存在mPlaybackThreads和mMmapThreads。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line">sp&lt;AudioFlinger::ThreadBase&gt; AudioFlinger::openOutput_l(<span class="keyword">audio_module_handle_t</span> <span class="keyword">module</span>,</div><div class="line">                                                            <span class="keyword">audio_io_handle_t</span> *output,</div><div class="line">                                                            <span class="keyword">audio_config_t</span> *config,</div><div class="line">                                                            <span class="keyword">audio_devices_t</span> devices,</div><div class="line">                                                            <span class="keyword">const</span> String8&amp; address,</div><div class="line">                                                            <span class="keyword">audio_output_flags_t</span> flags)</div><div class="line">&#123;</div><div class="line">    AudioHwDevice *outHwDev = findSuitableHwDev_l(<span class="keyword">module</span>, devices);</div><div class="line">    <span class="keyword">if</span> (outHwDev == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (*output == AUDIO_IO_HANDLE_NONE) &#123;</div><div class="line">        *output = nextUniqueId(AUDIO_UNIQUE_ID_USE_OUTPUT);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    mHardwareStatus = AUDIO_HW_OUTPUT_OPEN;</div><div class="line">    <span class="comment">// FOR TESTING ONLY:</span></div><div class="line">    ......</div><div class="line"></div><div class="line">    AudioStreamOut *outputStream = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">status_t</span> status = outHwDev-&gt;openOutputStream(</div><div class="line">            &amp;outputStream,</div><div class="line">            *output,</div><div class="line">            devices,</div><div class="line">            flags,</div><div class="line">            config,</div><div class="line">            address.<span class="built_in">string</span>());</div><div class="line">    mHardwareStatus = AUDIO_HW_IDLE;</div><div class="line">    <span class="keyword">if</span> (status == NO_ERROR) &#123;</div><div class="line">        <span class="keyword">if</span> (flags &amp; AUDIO_OUTPUT_FLAG_MMAP_NOIRQ) &#123;</div><div class="line">            sp&lt;MmapPlaybackThread&gt; thread =</div><div class="line">                    <span class="keyword">new</span> MmapPlaybackThread(<span class="keyword">this</span>, *output, outHwDev, outputStream,</div><div class="line">                                          devices, AUDIO_DEVICE_NONE, mSystemReady);</div><div class="line">            mMmapThreads.add(*output, thread);</div><div class="line">            ALOGV(<span class="string">"openOutput_l() created mmap playback thread: ID %d thread %p"</span>,</div><div class="line">                  *output, thread.get());</div><div class="line">            <span class="keyword">return</span> thread;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            sp&lt;PlaybackThread&gt; thread;</div><div class="line">            <span class="keyword">if</span> (flags &amp; AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD) &#123;</div><div class="line">                thread = <span class="keyword">new</span> OffloadThread(<span class="keyword">this</span>, outputStream, *output, devices, mSystemReady);</div><div class="line">                ALOGV(<span class="string">"openOutput_l() created offload output: ID %d thread %p"</span>,</div><div class="line">                      *output, thread.get());</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((flags &amp; AUDIO_OUTPUT_FLAG_DIRECT)</div><div class="line">                    || !isValidPcmSinkFormat(config-&gt;format)</div><div class="line">                    || !isValidPcmSinkChannelMask(config-&gt;channel_mask)) &#123;</div><div class="line">                thread = <span class="keyword">new</span> DirectOutputThread(<span class="keyword">this</span>, outputStream, </div><div class="line">                                         *output, devices, mSystemReady);</div><div class="line">                ALOGV(<span class="string">"openOutput_l() created direct output: ID %d thread %p"</span>,</div><div class="line">                      *output, thread.get());</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                thread = <span class="keyword">new</span> MixerThread(<span class="keyword">this</span>, outputStream, *output, devices, mSystemReady);</div><div class="line">                ALOGV(<span class="string">"openOutput_l() created mixer output: ID %d thread %p"</span>,</div><div class="line">                      *output, thread.get());</div><div class="line">            &#125;</div><div class="line">            mPlaybackThreads.add(*output, thread);</div><div class="line">            <span class="keyword">return</span> thread;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">status_t</span> AudioFlinger::openOutput(<span class="keyword">audio_module_handle_t</span> <span class="keyword">module</span>,</div><div class="line">                                  <span class="keyword">audio_io_handle_t</span> *output,</div><div class="line">                                  <span class="keyword">audio_config_t</span> *config,</div><div class="line">                                  <span class="keyword">audio_devices_t</span> *devices,</div><div class="line">                                  <span class="keyword">const</span> String8&amp; address,</div><div class="line">                                  <span class="keyword">uint32_t</span> *latencyMs,</div><div class="line">                                  <span class="keyword">audio_output_flags_t</span> flags)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (devices == <span class="literal">NULL</span> || *devices == AUDIO_DEVICE_NONE) &#123;</div><div class="line">        <span class="keyword">return</span> BAD_VALUE;</div><div class="line">    &#125;</div><div class="line">    Mutex::Autolock _l(mLock);</div><div class="line">    sp&lt;ThreadBase&gt; thread = openOutput_l(<span class="keyword">module</span>, output, config, *devices, address, flags);</div><div class="line">    <span class="keyword">if</span> (thread != <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> ((flags &amp; AUDIO_OUTPUT_FLAG_MMAP_NOIRQ) == <span class="number">0</span>) &#123;</div><div class="line">            PlaybackThread *playbackThread = (PlaybackThread *)thread.get();</div><div class="line">            *latencyMs = playbackThread-&gt;latency();</div><div class="line">            <span class="comment">// notify client processes of the new output creation</span></div><div class="line">            playbackThread-&gt;ioConfigChanged(AUDIO_OUTPUT_OPENED);</div><div class="line">            <span class="comment">// the first primary output opened designates the primary hw device</span></div><div class="line">            <span class="keyword">if</span> ((mPrimaryHardwareDev == <span class="literal">NULL</span>) &amp;&amp; (flags &amp; AUDIO_OUTPUT_FLAG_PRIMARY)) &#123;</div><div class="line">                ALOGI(<span class="string">"Using module %d as the primary audio interface"</span>, <span class="keyword">module</span>);</div><div class="line">                mPrimaryHardwareDev = playbackThread-&gt;getOutput()-&gt;audioHwDev;</div><div class="line">                <span class="function">AutoMutex <span class="title">lock</span><span class="params">(mHardwareLock)</span></span>;</div><div class="line">                mHardwareStatus = AUDIO_HW_SET_MODE;</div><div class="line">                mPrimaryHardwareDev-&gt;hwDevice()-&gt;setMode(mMode);</div><div class="line">                mHardwareStatus = AUDIO_HW_IDLE;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            MmapThread *mmapThread = (MmapThread *)thread.get();</div><div class="line">            mmapThread-&gt;ioConfigChanged(AUDIO_OUTPUT_OPENED);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> NO_ERROR;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> NO_INIT;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们可以看到在AudioPolicyManager中有mOutputs以audio_io_handle_t为key保存SwAudioOutputDescriptor，而在AudioFlinger中mPlaybackThreads和mMmapThreads以audio_io_handle_t保存线程，所以我们可以得出如下关系图。<br><img src="https://i.imgur.com/K5J8Y6B.png" alt=""></p><h3 id="打开音频输入"><a href="#打开音频输入" class="headerlink" title="打开音频输入"></a>打开音频输入</h3><p>打开音频输入和打开音频输出很类似，只是将SwAudioOutputDescriptor、PlaybackThread及AudioStreamOut换成了AudioInputDescriptor、RecordThread及AudioStreamIn，这里就一笔带过。</p><h3 id="确保可用输入输出和默认输出真正可用"><a href="#确保可用输入输出和默认输出真正可用" class="headerlink" title="确保可用输入输出和默认输出真正可用"></a>确保可用输入输出和默认输出真正可用</h3><p>无其他。主要是移除不可达设备。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// make sure all attached devices have been allocated a unique ID</span></div><div class="line"><span class="comment">// 确保所有可用输出设备真正可用</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i  &lt; mAvailableOutputDevices.size();) &#123;</div><div class="line">    <span class="keyword">if</span> (!mAvailableOutputDevices[i]-&gt;isAttached()) &#123;</div><div class="line">        ALOGW(<span class="string">"Output device %08x unreachable"</span>, mAvailableOutputDevices[i]-&gt;type());</div><div class="line">        mAvailableOutputDevices.remove(mAvailableOutputDevices[i]);</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// The device is now validated and can be appended to the available </span></div><div class="line">    <span class="comment">// devices of the engine</span></div><div class="line">    <span class="comment">// 目前不做任何处理</span></div><div class="line">    mEngine-&gt;setDeviceConnectionState(mAvailableOutputDevices[i],</div><div class="line">                                      AUDIO_POLICY_DEVICE_STATE_AVAILABLE);</div><div class="line">    i++;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 确保所有可用输入设备真正可用</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i  &lt; mAvailableInputDevices.size();) &#123;</div><div class="line">    <span class="keyword">if</span> (!mAvailableInputDevices[i]-&gt;isAttached()) &#123;</div><div class="line">        ALOGW(<span class="string">"Input device %08x unreachable"</span>, mAvailableInputDevices[i]-&gt;type());</div><div class="line">        mAvailableInputDevices.remove(mAvailableInputDevices[i]);</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// The device is now validated and can be appended to the available devices of the engine</span></div><div class="line">    <span class="comment">// 目前不做任何处理</span></div><div class="line">    mEngine-&gt;setDeviceConnectionState(mAvailableInputDevices[i],</div><div class="line">                                      AUDIO_POLICY_DEVICE_STATE_AVAILABLE);</div><div class="line">    i++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// make sure default device is reachable</span></div><div class="line"><span class="comment">// 确保默认输出设备真正可用</span></div><div class="line"><span class="keyword">if</span> (mDefaultOutputDevice == <span class="number">0</span> || </div><div class="line">    mAvailableOutputDevices.indexOf(mDefaultOutputDevice) &lt; <span class="number">0</span>) &#123;</div><div class="line">    ALOGE(<span class="string">"Default device %08x is unreachable"</span>, mDefaultOutputDevice-&gt;type());</div><div class="line">&#125;</div><div class="line"></div><div class="line">ALOGE_IF((mPrimaryOutput == <span class="number">0</span>), <span class="string">"Failed to open primary output"</span>);</div><div class="line">updateDevicesAndOutputs();</div></pre></td></tr></table></figure></p><h2 id="AudioPolicyEffects初始化"><a href="#AudioPolicyEffects初始化" class="headerlink" title="AudioPolicyEffects初始化"></a>AudioPolicyEffects初始化</h2><p>对于音效策略，类似会先加载audio_effects.conf，这个文件可能位于system/etc/或者vendor/etc/。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">AudioPolicyEffects::AudioPolicyEffects()</div><div class="line">&#123;</div><div class="line">    <span class="comment">// load automatic audio effect modules</span></div><div class="line">    <span class="keyword">if</span> (access(AUDIO_EFFECT_VENDOR_CONFIG_FILE, R_OK) == <span class="number">0</span>) &#123;</div><div class="line">        loadAudioEffectConfig(AUDIO_EFFECT_VENDOR_CONFIG_FILE);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (access(AUDIO_EFFECT_DEFAULT_CONFIG_FILE, R_OK) == <span class="number">0</span>) &#123;</div><div class="line">        loadAudioEffectConfig(AUDIO_EFFECT_DEFAULT_CONFIG_FILE);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这个文件的格式如下。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"># List of effect libraries to load. Each library element must contain a <span class="string">"path"</span> element</div><div class="line"><span class="meta"># giving the full path of the library .so file.</span></div><div class="line"><span class="meta">#    libraries &#123;</span></div><div class="line">#        &lt;lib name&gt; &#123;</div><div class="line"><span class="meta">#          path <span class="meta-string">&lt;lib path&gt;</span></span></div><div class="line">#        &#125;</div><div class="line">#    &#125;</div><div class="line"><span class="meta"># list of effects to load. Each effect element must contain a <span class="meta-string">"library"</span> and a <span class="meta-string">"uuid"</span> element.</span></div><div class="line"># The value of the <span class="string">"library"</span> element must correspond to the name of one library element in the</div><div class="line"># <span class="string">"libraries"</span> element.</div><div class="line"># The name of the effect element is indicative, only the value of the <span class="string">"uuid"</span> element</div><div class="line"><span class="meta"># designates the effect.</span></div><div class="line"># The uuid is the implementation specific UUID as specified by the effect vendor. This is <span class="keyword">not</span> the</div><div class="line"><span class="meta"># generic effect type UUID.</span></div><div class="line"><span class="meta">#    effects &#123;</span></div><div class="line">#        &lt;fx name&gt; &#123;</div><div class="line"><span class="meta">#            library <span class="meta-string">&lt;lib name&gt;</span></span></div><div class="line"><span class="meta">#            uuid <span class="meta-string">&lt;effect uuid&gt;</span></span></div><div class="line">#        &#125;</div><div class="line">#        ...</div><div class="line">#    &#125;</div></pre></td></tr></table></figure></p><p>到这里AudioPolicyService的启动流程已经完结，且篇幅已经挺长，其他的知识点，学习到时再补上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AudioPolicyService在Audio系统另一个重要的服务，是音频策略的制定者，负责音频设备切换的策略抉择、音量调节策略等。本文基于Android 8.0的代码，记录了AudioPolicyService启动的过程，介绍了其中几个比较关键的点，希望以后自己看到此文
      
    
    </summary>
    
      <category term="Android Audio" scheme="http://yoursite.com/categories/Android-Audio/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>AudioFlinger启动过程</title>
    <link href="http://yoursite.com/2017/11/09/AudioFlinger%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/11/09/AudioFlinger启动过程/</id>
    <published>2017-11-09T07:58:02.000Z</published>
    <updated>2017-11-21T12:16:09.589Z</updated>
    
    <content type="html"><![CDATA[<p>AudioFlinger以media.audio_flinger为名注册到ServiceManager，是Android Audio系统的一个核心服务，是音频策略的执行者，负责输入输出流设备的管理及音频流数据的处理传输。本文以Android 8.0的代码为基础，记录了其启动过程以及AudioFlinger主要类的关系。其代码位于frameworks/av/services/audioflinger。</p><h2 id="AudioFlinger的启动过程"><a href="#AudioFlinger的启动过程" class="headerlink" title="AudioFlinger的启动过程"></a>AudioFlinger的启动过程</h2><p>Android 8.0中与7.0相比，在初始化过程中，主要是实例化了mDevicesFactoryHal和mEffectsFactoryHal，作为HAL进程的客户端与HAL进程交互。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">AudioFlinger::AudioFlinger()</div><div class="line">    <span class="comment">//变量初始化</span></div><div class="line">    : BnAudioFlinger(),</div><div class="line">      mMediaLogNotifier(<span class="keyword">new</span> AudioFlinger::MediaLogNotifier()),</div><div class="line">      mPrimaryHardwareDev(<span class="literal">NULL</span>),</div><div class="line">      mAudioHwDevs(<span class="literal">NULL</span>),</div><div class="line">      mHardwareStatus(AUDIO_HW_IDLE),</div><div class="line">      mMasterVolume(<span class="number">1.0f</span>),</div><div class="line">      mMasterMute(<span class="literal">false</span>),</div><div class="line">      <span class="comment">// mNextUniqueId(AUDIO_UNIQUE_ID_USE_MAX),</span></div><div class="line">      mMode(AUDIO_MODE_INVALID),</div><div class="line">      mBtNrecIsOff(<span class="literal">false</span>),</div><div class="line">      mIsLowRamDevice(<span class="literal">true</span>),</div><div class="line">      mIsDeviceTypeKnown(<span class="literal">false</span>),</div><div class="line">      mGlobalEffectEnableTime(<span class="number">0</span>),</div><div class="line">      mSystemReady(<span class="literal">false</span>)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line"></div><div class="line">    mDevicesFactoryHal = DevicesFactoryHalInterface::create();</div><div class="line">    mEffectsFactoryHal = EffectsFactoryHalInterface::create();</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里我们主要看一下DevicesFactoryHalInterface关系图。EffectsFactoryHalInterface也是类似的情况。<br><img src="https://i.imgur.com/urJudFp.png" alt=""><br>阅读每个类的代码实现，我们发现只有DevicesFactoryHalHybrid实现了DevicesFactoryHalInterface接口的create()函数，所以这里会创建DevicesFactoryHalHybrid实例，而DevicesFactoryHalHybrid会创建DevicesFactoryHalLocal和DevicesFactoryHalHidl实例。DevicesFactoryHalLocal用于直接加载HAL的lib，是为了兼容8.0之前的版本，而DevicesFactoryHalHidl通过binder通信从hwservicemanager中返回IDevicesFactory实例，通过IDevicesFactory的openDevice函数返回具体的Device，并且用DeviceHalHidl封装返回的Device，这里不再会直接加载HAL的lib，后续和HAL的通信完全通过IDevicesFactory接口，具体在AudioPolicyService加载HW module时会更清楚明白。</p><p>第一次初始化还会执行onFirstRef()，创建PatchPanel实例且将AudioFlinger实例传入PatchPanel，设置Audio Mode为AUDIO_MODE_NORMAL,并将自己保存在全局变量gAudioFlinger。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> AudioFlinger::onFirstRef()</div><div class="line">&#123;</div><div class="line">    Mutex::Autolock _l(mLock);</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">    mPatchPanel = <span class="keyword">new</span> PatchPanel(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    mMode = AUDIO_MODE_NORMAL;</div><div class="line"></div><div class="line">    gAudioFlinger = <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Mutex是互斥类，用于多线程访问同一个资源的时候，保证一次只有一个线程能访问该资源。它的工作原理是某一个线程要访问公共资源的时候先锁定这个Mutex，完成操作之后对Mutex解锁，在此期间如果有其它的线程也要访问公共资源，它就先要去锁Mutex，当它发现Mutex已经被锁住了，那么这个线程就是阻塞在那儿。等Mutex解锁之后所有阻塞在Mutex的线程都会醒来，只有第一个醒来的会抢到Mutex，其它没有抢到的发现自己晚了一步，只能继续阻塞在那儿，等待下次机会。Mutex源码位置/system/core/libutils/include/utils。</p><p>为了简化一般的Mutex操作，在class Mutex中定义了一个内部类Autolock，它利用{}作用域实现自动解锁，看一下它的构造函数就知道了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Autolock</span> &#123;</span></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        inline explicit Autolock(Mutex&amp; mutex) : mLock(mutex)  &#123; mLock.lock(); &#125;</div><div class="line">        inline explicit Autolock(Mutex* mutex) : mLock(*mutex) &#123; mLock.lock(); &#125;</div><div class="line">        <span class="keyword">inline</span> ~Autolock() &#123; mLock.unlock(); &#125;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        Mutex&amp; mLock;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>我们知道在{}中创建的变量，变开这个大括号时就要销毁，于是就自动调用析构函数了。</p><h2 id="AudioFlinger中放音录音线程"><a href="#AudioFlinger中放音录音线程" class="headerlink" title="AudioFlinger中放音录音线程"></a>AudioFlinger中放音录音线程</h2><p>AudioFlinger作为音频的核心服务，主要责任是负责放音与录音，下面我们可以大致看看放音与录音线程的关系，在AudioPolicyServic启动过程中我们会看到这些线程的创建。<br><img src="https://i.imgur.com/FiwGgwV.png" alt=""></p><ul><li>ThreadBase：ThreadBase以Thread为基类，而又是PlaybackThread、RecordThread和MmapThread的基类。</li><li>RecordThread：音频录音线程，负责音频的录音，没有子类。</li><li>PlaybackThread：代表放音线程，有两个直接子类MixerThread和DirectOutputThread。</li><li>MixerThread：混音放音线程，有子类DuplicatingThread，负责处理标识为<br>AUDIO_OUTPUT_FLAG_PRIMARY、AUDIO_OUTPUT_FLAG_FAST、AUDIO_OUTPUT_FLAG_DEEP_BUFFER的音频流，MixerThread 可以把多个音轨的数据混音后再输出。</li><li>DirectOutputThread：直接输出放音线程，有子类OffloadThread，负责处理标识为AUDIO_OUTPUT_FLAG_DIRECT的音频流，这种音频流数据不需要软件混音，直接输出到音频设备即可。</li><li>DuplicatingThread：复制输出放音线程，负责复制音频流数据到其他输出设备，使用场景如主声卡设备、蓝牙耳机设备、USB声卡设备同时输出。</li><li>OffloadThread：硬解回放线程，负责处理标识为AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD的音频流，这种音频流未经软件解码的（一般是MP3、AAC等格式的数据），需要输出到硬件解码器，由硬件解码器解码成PCM 数据。</li><li>MmapThread：这个线程是Android 8.0新加入的，用于低延迟的放音与录音，与AAudio有关系，有MmapPlaybackThread和MmapCaptureThread两个子类。</li><li>MmapPlaybackThread：MMAP放音线程，负责处理标识为AUDIO_OUTPUT_FLAG_MMAP_NOIRQ的音频流。</li><li>MmapcaptureThread：MMAP录音线程，负责处理标识为AUDIO_INPUT_FLAG_MMAP_NOIRQ的音频流。<h2 id="AudioFlinger中Tracks"><a href="#AudioFlinger中Tracks" class="headerlink" title="AudioFlinger中Tracks"></a>AudioFlinger中Tracks</h2>Track：音轨，是AudioFlinger中另一个重要的将角色，下面我们可以看看其关系。<br><img src="https://i.imgur.com/HHP2bZp.png" alt=""><br>对于播放对应Track，OutputTrack，TrackHandle及BnAudioTrack，TrackHandle和BnAudioTrack主要用于和Client端Binder通信，真正代表输出音轨的为Track。同样对应录音音轨的是RecordTrack，RecordHandle及BnAudioRecord，RecordHandle和BnAudioRecord也用于Binder通信，真正录音音轨为RecordTrack。而对于MmapTrack稍微不太样，而是定义通用接口MmapStreamInterface封装MmapThread，再封装MmapTrack，不是通过XXXHandle继承BnXXX，这也许是出于latency上的考虑。<h2 id="AudioFlinger中的Streams"><a href="#AudioFlinger中的Streams" class="headerlink" title="AudioFlinger中的Streams"></a>AudioFlinger中的Streams</h2>我们看到在AudioFlinger中以AudioHwDevice封装HAL的DeviceHalHidl，而DeviceHalHidl封装从HAL返回的具体的Device，这就和HAL层的so文件连接在一起，且AudioHwDevice直接或间接依赖AudioStreamOut和AudioStreanIn这样也和HAL层中stream关联上，后续打开音频输入输出以及打开输入音频流及输出音频流做好准备。具体我们可以在AudioPolicyService启动的时候看的更清楚。<br><img src="https://i.imgur.com/bIsUSZO.png" alt=""><br>AudioFlinger中还有很多其他的知识点，后续学到时再慢慢补上。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AudioFlinger以media.audio_flinger为名注册到ServiceManager，是Android Audio系统的一个核心服务，是音频策略的执行者，负责输入输出流设备的管理及音频流数据的处理传输。本文以Android 8.0的代码为基础，记录了其启动
      
    
    </summary>
    
      <category term="Android Audio" scheme="http://yoursite.com/categories/Android-Audio/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Audio Server启动</title>
    <link href="http://yoursite.com/2017/11/08/Android-Audio-Server%E5%90%AF%E5%8A%A8/"/>
    <id>http://yoursite.com/2017/11/08/Android-Audio-Server启动/</id>
    <published>2017-11-08T02:44:20.000Z</published>
    <updated>2017-11-19T09:55:49.540Z</updated>
    
    <content type="html"><![CDATA[<p>Android audioserver是Audio系统native的服务，也是连接Audio Framework和Audio HAL的一个纽带，其中包含了AudioFlinger、AudioPolicyService、AAudioService、RadioService、SoundTriggerHwService等服务。源代码位于frameworks/av/media/audioserver</p><p>从Android 7.0开始，Audio相关的service从mediaserver中转移到audioserver，把audio，camera及mediaplayerservice做了一个拆分，这样不会显得臃肿、职能更加独立且安全性更高。拆分之后audioserver还是一个native service，还是从init进程中启动，如下是其在audioserver.rc中的启动代码。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">service audioserver /system/bin/audioserver</div><div class="line">    class main                                   <span class="comment"># audioserver和class main行为一致</span></div><div class="line">    user audioserver                             <span class="comment"># 用户归属，uid：AID_AUDIOSERVER</span></div><div class="line">    <span class="comment"># media gid needed for /dev/fm (radio) and for /data/misc/media (tee)</span></div><div class="line">    group audio camera drmrpc inet media mediadrm net_bt \</div><div class="line">          net_bt_admin net_bw_acct oem_2901                         <span class="comment"># 用户组归属</span></div><div class="line">    ioprio rt 4                                                     <span class="comment"># io调度优先级</span></div><div class="line">    <span class="comment"># 当子进程被创建的时候，将子进程的pid写入到给定的文件中,cgroup/cpuset用法</span></div><div class="line">    writepid /dev/cpuset/foreground/tasks /dev/stune/foreground/tasks                </div><div class="line">    onrestart restart audio-hal-2-0                     <span class="comment"># audioserver重启会重启hal</span></div></pre></td></tr></table></figure><p>我们看到Android 8.0当重启audioserver时，会重启audio-hal-2-0，这个服务是audio hal的服务，在android 8.0中，framework native进程与hal分离，hal不在和framework native处于同一个进程，而是独立进程，进程间通过binder通信。先不讲HAL binder化，我们先看看audioserver中包含哪几个服务。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc __unused, <span class="keyword">char</span> **argv)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">   signal(SIGPIPE, SIG_IGN);</div><div class="line"></div><div class="line">   <span class="keyword">bool</span> doLog = (<span class="keyword">bool</span>) property_get_bool(<span class="string">"ro.test_harness"</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">   <span class="keyword">pid_t</span> childPid;</div><div class="line"></div><div class="line">   ......</div><div class="line"></div><div class="line">   <span class="keyword">if</span> (doLog &amp;&amp; (childPid = fork()) != <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">      ......</div><div class="line"></div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">      sp&lt;ProcessState&gt; proc(ProcessState::self());</div><div class="line">      sp&lt;IServiceManager&gt; sm = defaultServiceManager();</div><div class="line">      ALOGI(<span class="string">"ServiceManager: %p"</span>, sm.get());</div><div class="line">      AudioFlinger::instantiate();</div><div class="line">      AudioPolicyService::instantiate();</div><div class="line">      AAudioService::instantiate();</div><div class="line">      RadioService::instantiate();</div><div class="line">      SoundTriggerHwService::instantiate();</div><div class="line"></div><div class="line">      ProcessState::self()-&gt;startThreadPool();</div><div class="line"></div><div class="line"><span class="comment">// <span class="doctag">FIXME:</span> remove when BUG 31748996 is fixed</span></div><div class="line">      android::hardware::ProcessState::self()-&gt;startThreadPool();</div><div class="line"></div><div class="line">      IPCThreadState::self()-&gt;joinThreadPool();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>从如上代码可以看出，audioserver中回依次执行AudioFlinger、AudioPolicyService、AAudioService、RadioService、SoundTriggerHwService的instantiate函数。通过阅读源代码，由于继承的缘故这个五个service最终会调用BinderService的instantiate函数且将自己注册到ServiceManager中，后续client端可以通过service注册时用的name从ServiceManager返回server端。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> SERVICE&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinderService</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> status_t <span class="title">publish</span><span class="params">(<span class="keyword">bool</span> allowIsolated = <span class="literal">false</span>)</span> </span>&#123;</div><div class="line">        sp&lt;IServiceManager&gt; sm(defaultServiceManager());</div><div class="line">        <span class="keyword">return</span> sm-&gt;addService(</div><div class="line">                String16(SERVICE::getServiceName()),</div><div class="line">                <span class="keyword">new</span> SERVICE(), allowIsolated);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publishAndJoinThreadPool</span><span class="params">(<span class="keyword">bool</span> allowIsolated = <span class="literal">false</span>)</span> </span>&#123;</div><div class="line">        publish(allowIsolated);</div><div class="line">        joinThreadPool();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">instantiate</span><span class="params">()</span> </span>&#123; publish(); &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> status_t <span class="title">shutdown</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> NO_ERROR; &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">joinThreadPool</span><span class="params">()</span> </span>&#123;</div><div class="line">        sp&lt;ProcessState&gt; ps(ProcessState::self());</div><div class="line">        ps-&gt;startThreadPool();</div><div class="line">        ps-&gt;giveThreadPoolName();</div><div class="line">        IPCThreadState::self()-&gt;joinThreadPool();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>AudioFlinger（media.audio_flinger）：Audio系统的一个核心服务，是音频策略的执行者，负责输入输出流设备的管理及音频流数据的处理传输。</p><p>AudioPolicyService（media.audio_policy）：音频策略的制定者，负责音频设备切换的策略抉择、音量调节策略等。</p><p>AAudioService（media.aaudio）：这是Android 8.0加入角色，是OpenSL ES的另外一种选择，需要低延迟的高性能音频应用的另外一种选择。</p><p>RadioService（media.radio）：与FM相关的一个服务。</p><p>SoundTriggerHwService（media.sound_trigger_hw）：Android语音识别的native服务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android audioserver是Audio系统native的服务，也是连接Audio Framework和Audio HAL的一个纽带，其中包含了AudioFlinger、AudioPolicyService、AAudioService、RadioService、S
      
    
    </summary>
    
      <category term="Android Audio" scheme="http://yoursite.com/categories/Android-Audio/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>GitHub搭建个人的博客</title>
    <link href="http://yoursite.com/2017/10/30/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2017/10/30/GitHub搭建自己的博客/</id>
    <published>2017-10-30T09:34:27.481Z</published>
    <updated>2017-11-19T09:52:02.501Z</updated>
    
    <content type="html"><![CDATA[<p>最近突然间发现，自己过去看过的东西，没过多久就忘得一干二净，每当要用时，又得从头来一遍，真是好记性不如烂笔头，所以有了写笔记的想法，GitHub上可以方便记录自己一切想记录的，于是就在GitHub上开始写笔记，希望自己不要把知识忘得太快。本文记录在Windows环境下使用Hexo搭建GitHub博客的过程。</p><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>在nodejs官网下载对应的版本安装<br>下载地址：<a href="https://nodejs.org/en/download" target="_blank" rel="external">https://nodejs.org/en/download</a></p><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>下载地址：<a href="https://git-for-windows.github.io" target="_blank" rel="external">https://git-for-windows.github.io</a></p><h2 id="创建GitHub账户"><a href="#创建GitHub账户" class="headerlink" title="创建GitHub账户"></a>创建GitHub账户</h2><p>进入GitHub主页<a href="https://github.com/" target="_blank" rel="external">https://github.com/</a>，依次输入用户名、邮箱、密码，然后点击注册，按默认点击“Finish sign up”。然后进行邮箱验证。</p><h2 id="创建GitHub仓库"><a href="#创建GitHub仓库" class="headerlink" title="创建GitHub仓库"></a>创建GitHub仓库</h2><p>点击“New repository”，新建一个仓库，仓库名为“[yourname].github.io”，这样<a href="https://[yourname].github.io" target="_blank" rel="external">https://[yourname].github.io</a> 就是你的博客地址了。默认这仓库只有master分支，新建一个hexo分支。</p><h2 id="配置Hexo"><a href="#配置Hexo" class="headerlink" title="配置Hexo"></a>配置Hexo</h2><p>接下来的命令都在Git Bash中执行。</p><p>在自己喜欢的位置新建一个blog文件夹，在这个文件夹下打开Git Bash，因为npm是国外服务器，可能执行比较慢，可以使用淘宝镜像，命令如下：</p><pre><code>$ npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>执行成功后使用淘宝NPM安装Hexo</p><pre><code>$ cnpm install -g hexo-cli$ cnmp install hexo --save$ hexo -vhexo: 3.4.0hexo-cli: 1.0.4os: Windows_NT 6.1.7600 win32 ia32http_parser: 2.7.0node: 8.7.0v8: 6.1.534.42uv: 1.15.0zlib: 1.2.11ares: 1.10.1-DEVmodules: 57nghttp2: 1.25.0openssl: 1.0.2licu: 59.1unicode: 9.0cldr: 31.0.1tz: 2017b</code></pre><p>到这里hexo已经安装好了</p><h2 id="配置ssh-key"><a href="#配置ssh-key" class="headerlink" title="配置ssh key"></a>配置ssh key</h2><pre><code>ssh-keygen -t rsa -C &quot;Github的注册邮箱地址&quot;</code></pre><p>在C:\Users\yourname\.ssh下会得到密钥id_rsa和id_rsa.pub，用nodepad++打开id_rsa.pub复制全文，打开<a href="https://github.com/settings/ssh" target="_blank" rel="external">https://github.com/settings/ssh</a>，Add SSH key，粘贴进去保存。 </p><p>测试是否配置成功</p><pre><code>$ ssh -T git@github.comHi [yourname]! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</code></pre><h2 id="配置git信息"><a href="#配置git信息" class="headerlink" title="配置git信息"></a>配置git信息</h2><pre><code>$ git config --global user.name &quot;你的用户名&quot;$ git config --global user.email &quot;你的邮箱&quot;</code></pre><h2 id="使用Hexo管理博客"><a href="#使用Hexo管理博客" class="headerlink" title="使用Hexo管理博客"></a>使用Hexo管理博客</h2><h3 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h3><pre><code>$ hexo init &lt;nodejs-hexo&gt; //初始化nodejs-hexo（文件夹名随意）$ git clone -b hexo https://github.com/[yourname]/[yourname].github.io</code></pre><p>将[yourname].github.io文件夹下的.git文件夹拷贝到nodejs-hexo文件夹。</p><pre><code>$ cnpm install //安装生成器$ hexo server //运行（Ctrl + C停止运行）</code></pre><p>在浏览器输入localhost:4000，这样就可以在本地看到博客了。</p><h3 id="配置博客"><a href="#配置博客" class="headerlink" title="配置博客"></a>配置博客</h3><p>_config.yml中配置基本信息</p><pre><code>title: #博客标题subtitle: #博客副标题description: #博客描述author: #博客作者language: zh-Hanstimezone: Asia/Shanghai</code></pre><p>_config.yml中配置主题</p><pre><code>theme: next</code></pre><p>_config.yml中配置部署</p><pre><code>deploy:  type: git  repo: https://github.com/[yourname]/[yourname].github.io  branch: master</code></pre><p>注意：这里的设置冒号后面必须有空格</p><h3 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h3><pre><code>$ hexo new &quot;博客名&quot; //增加新文章$ cnpm install hexo-deployer-git --save //安装hexo git插件$ git add .$ git commit -m &quot;message&quot;$ git push origin hexo$ hexo generate //生成静态文件$ hexo deploy   //部署</code></pre><h3 id="换PC管理博客"><a href="#换PC管理博客" class="headerlink" title="换PC管理博客"></a>换PC管理博客</h3><pre><code>$ git clone -b hexo https://github.com/[yourname]/[yourname].github.io</code></pre><p>在[yourname].github.io中从新安装hexo，就可以写博客及发布博客了。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>Next主题配置参考：<a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="external">http://theme-next.iissnan.com/theme-settings.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近突然间发现，自己过去看过的东西，没过多久就忘得一干二净，每当要用时，又得从头来一遍，真是好记性不如烂笔头，所以有了写笔记的想法，GitHub上可以方便记录自己一切想记录的，于是就在GitHub上开始写笔记，希望自己不要把知识忘得太快。本文记录在Windows环境下使用H
      
    
    </summary>
    
      <category term="搭建博客" scheme="http://yoursite.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
  </entry>
  
</feed>
