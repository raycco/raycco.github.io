<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Raycco&#39;s Notes</title>
  
  <subtitle>Quick Notes</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-25T12:11:53.058Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Raycco</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AudioTrack到AudioFlinger数据传输：共享内存</title>
    <link href="http://yoursite.com/2017/12/28/AudioTrack%E5%88%B0AudioFlinger%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/"/>
    <id>http://yoursite.com/2017/12/28/AudioTrack到AudioFlinger数据传输/</id>
    <published>2017-12-28T07:49:05.000Z</published>
    <updated>2018-01-25T12:11:53.058Z</updated>
    
    <content type="html"><![CDATA[<p>从前面AudioFlinger启动知道，其运行在audioserver进程，而创建AudioTrack一般在APP端创建，APP一般运行在单独的进程，所以这里说AudioTrack到AudioFlinger数据传输，其实也是两个进程之间数据传输，这篇笔记就记录了AudioTrack是怎么将Audio数据转移到AudioFlinger的。</p><h2 id="通信模型"><a href="#通信模型" class="headerlink" title="通信模型"></a>通信模型</h2><p>在AudioTrack和AudioFlinger通信过程中，有两种情形：MODE_STATIC和MODE_STREAM。</p><p>MODE_STATIC主要针对数据量较小及延迟要求高的音频，比如短促的游戏音乐，这种情况下，共享内存的创建在Client进程，且一般也不会动态处理这段buffer，AudioTrack会一次性将数据通过共享内存传递到AudioFlinger。</p><p>MODE_STREAM适用于大多数应用场景，是Android主要的音频播放方式，如下图，就是MODE_STREAM模式下，AudioTrack到AudioFlinger数据传输的模式，同样使用共享内存，且是环形buffer，通过生产者-消费者模式进行数据传输。与MODE_STATIC的主要区别在于共享内存的创建方式及对共享内存的控制方式不太一样。<br><img src="https://i.imgur.com/uFXUT2x.png" alt=""></p><h2 id="共享内存控制块"><a href="#共享内存控制块" class="headerlink" title="共享内存控制块"></a>共享内存控制块</h2><p>对于共享内存的通信方式，涉及到两个进程对于共享内存的读写，这就会有进程间的同步，所以共享内存控制块起着关键性的作用，所以下面我们看看其定义：frameworks/av/include/private/media/AudioTrackShared.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// for audio_track_cblk_t::mFlags</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CBLK_UNDERRUN   0x01 <span class="comment">// set by server immediately on output underrun, cleared by client</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CBLK_FORCEREADY 0x02 <span class="comment">// set: track is considered ready immediately by AudioFlinger,</span></span></div><div class="line">                             <span class="comment">// clear: track is ready when buffer full</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CBLK_INVALID    0x04 <span class="comment">// track buffer invalidated by AudioFlinger, need to re-create</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CBLK_DISABLED   0x08 <span class="comment">// output track disabled by AudioFlinger due to underrun,</span></span></div><div class="line">                             <span class="comment">// need to re-start.  Unlike CBLK_UNDERRUN, this is not set</span></div><div class="line">                             <span class="comment">// immediately, but only after a long string of underruns.</span></div><div class="line"><span class="comment">// 0x10 unused</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CBLK_LOOP_CYCLE 0x20 <span class="comment">// set by server each time a loop </span></span></div><div class="line">                             <span class="comment">// cycle other than final one completes</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CBLK_LOOP_FINAL 0x40 <span class="comment">// set by server when the final loop cycle completes</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CBLK_BUFFER_END 0x80 <span class="comment">// set by server when the position </span></span></div><div class="line">                             <span class="comment">// reaches end of buffer if not looping</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CBLK_OVERRUN   0x100 <span class="comment">// set by server immediately on input overrun, cleared by client</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CBLK_INTERRUPT 0x200 <span class="comment">// set by client on interrupt(), cleared by client in obtainBuffer()</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CBLK_STREAM_END_DONE 0x400 <span class="comment">// set by server on render completion, cleared by client</span></span></div></pre></td></tr></table></figure></p><p>如上是对于传输的状态的定义。</p><ul><li>CBLK_UNDERRUN：AudioTrack写入数据的速度跟不上AudioFlinger读取数据的速度，使得 AudioFlinger不能及时获取到预期的数据量，反映到现实的后果就是声音断续；这种情况的根本原因大多是应用程序不能及时写入数据或者缓冲区分配过小，AudioTrack本身并没有错；AudioFlinger针对这点做了容错处理：当发现underrun时，先陷入短时间的睡眠，不急着读取数据，让应用程序准备更多的数据。</li><li>CBLK_OVERRUN：刚好和CBLK_UNDERRUN相反，主要对于AudioRecord，底层写数据的速度太快，AudioRecord读取数据比较慢，数据传输就会处于超负荷的运行。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Important: do not add any virtual methods, including ~</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">audio_track_cblk_t</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">                <span class="comment">// Since the control block is always located in shared memory, this constructor</span></div><div class="line">                <span class="comment">// is only used for placement new(). It is never used for regular new() or stack.</span></div><div class="line">                            <span class="keyword">audio_track_cblk_t</span>();</div><div class="line">                <span class="comment">/*virtual*/</span> ~<span class="keyword">audio_track_cblk_t</span>() &#123; &#125;</div><div class="line">                ......               <span class="comment">// friend classes of Proxy</span></div><div class="line">    <span class="comment">// The data members are grouped so that members accessed frequently and in the same context</span></div><div class="line">    <span class="comment">// are in the same line of data cache.</span></div><div class="line">                <span class="keyword">uint32_t</span>    mServer; <span class="comment">// Number of filled frames consumed by server (mIsOut),</span></div><div class="line">                                     <span class="comment">// or filled frames provided by server (!mIsOut).</span></div><div class="line">                                     <span class="comment">// It is updated asynchronously by server without </span></div><div class="line">                                     <span class="comment">// a barrier. The value should be used</span></div><div class="line">                                     <span class="comment">// "for entertainment purposes only",</span></div><div class="line">                                     <span class="comment">// which means don't make important decisions based on it.</span></div><div class="line">    <span class="keyword">volatile</span>    <span class="keyword">int32_t</span>     mFutex;  <span class="comment">// event flag: down (P) by client,</span></div><div class="line">                                     <span class="comment">// up (V) by server or binderDied() or interrupt()</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CBLK_FUTEX_WAKE 1        <span class="comment">// if event flag bit is set, then a deferred wake is pending</span></span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">                <span class="comment">// This field should be a size_t, but since it is located in shared </span></div><div class="line">                <span class="comment">// memory we force to 32-bit. The client and server may have </span></div><div class="line">                <span class="comment">// different typedefs for size_t.</span></div><div class="line">                <span class="keyword">uint32_t</span>    mMinimum;    <span class="comment">// server wakes up client if available &gt;= mMinimum</span></div><div class="line">                <span class="comment">// Stereo gains for AudioTrack only, not used by AudioRecord.</span></div><div class="line">                <span class="keyword">gain_minifloat_packed_t</span> mVolumeLR;</div><div class="line">                <span class="keyword">uint32_t</span>    mSampleRate; <span class="comment">// AudioTrack only: client's requested </span></div><div class="line">                                         <span class="comment">// sample rate in Hz or 0 == default. </span></div><div class="line">                                         <span class="comment">// Write-only client, read-only server.</span></div><div class="line">                PlaybackRateQueue::Shared mPlaybackRateQueue;</div><div class="line">                <span class="comment">// client write-only, server read-only</span></div><div class="line">                <span class="keyword">uint16_t</span>    mSendLevel;      <span class="comment">// Fixed point U4.12 so 0x1000 means 1.0</span></div><div class="line">                <span class="comment">// server write-only, client read</span></div><div class="line">                ExtendedTimestampQueue::Shared mExtendedTimestampQueue;</div><div class="line">                <span class="comment">// This is set by AudioTrack.setBufferSizeInFrames().</span></div><div class="line">                <span class="comment">// A write will not fill the buffer above this limit.</span></div><div class="line">    <span class="keyword">volatile</span>    <span class="keyword">uint32_t</span>   mBufferSizeInFrames;  <span class="comment">// effective size of the buffer</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">volatile</span>    <span class="keyword">int32_t</span>     mFlags;         <span class="comment">// combinations of CBLK_*</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">                <span class="keyword">union</span> &#123;</div><div class="line">                    AudioTrackSharedStreaming   mStreaming;</div><div class="line">                    AudioTrackSharedStatic      mStatic;</div><div class="line">                    <span class="keyword">int</span>                         mAlign[<span class="number">8</span>];</div><div class="line">                &#125; u;</div><div class="line">                <span class="comment">// Cache line boundary (32 bytes)</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>我们比较关注的mFutex，用于进程的同步，mMinimum唤醒server最小值，mFlags标记当前传输处于什么样的状态，没有直接看到环形buffer相关控制变量，但是有一个联合体。</p><p>对于MODE_STREAM：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AudioTrackSharedStreaming</span> &#123;</span></div><div class="line">    <span class="comment">// similar to NBAIO MonoPipe</span></div><div class="line">    <span class="comment">// in continuously incrementing frame units, take modulo buffer size, </span></div><div class="line">    <span class="comment">// which must be a power of 2</span></div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span> mFront;    <span class="comment">// read by consumer (output: server, input: client)</span></div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span> mRear;     <span class="comment">// written by producer (output: client, input: server)</span></div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span> mFlush;    <span class="comment">// incremented by client to indicate a request to flush;</span></div><div class="line">                                <span class="comment">// server notices and discards all data between mFront and mRear</span></div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">uint32_t</span> mUnderrunFrames; <span class="comment">// server increments for each unavailable </span></div><div class="line">                                       <span class="comment">// but desired frame</span></div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">uint32_t</span> mUnderrunCount;  <span class="comment">// server increments for each underrun occurrence</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="共享内存的创建"><a href="#共享内存的创建" class="headerlink" title="共享内存的创建"></a>共享内存的创建</h2><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p>首先通过时序图看看匿名共享内存的创建过程，对于MODE_STREAM，匿名共享内创建在AudioFlinger中，即在audioserver中，其中会通过Binder通信将创建好的共享内存随Track的返回而返回到AudioTrack的client中，通过获取共享内存地址再重新映射到client进程，这样两个进程就可以操作这块内存传输数据了。<br><img src="https://i.imgur.com/azF90j1.png" alt=""></p><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><p>看完时序图，大致看看源代码，看看其创建过程。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">status_t</span> AudioTrack::<span class="built_in">set</span>(</div><div class="line">        ......</div><div class="line">        <span class="keyword">const</span> sp&lt;IMemory&gt;&amp; sharedBuffer,</div><div class="line">        ......)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    mSharedBuffer = sharedBuffer;</div><div class="line">    ......</div><div class="line">    <span class="comment">// create the IAudioTrack</span></div><div class="line">    <span class="keyword">status_t</span> status = createTrack_l();</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在创建AudioTrack的时候，有一个比较重要的参数sharedBuffer，这个参数决定了创建共享内存的进程，若为空，则会在AudioFlinger创建，否则在创建AudioTrack之前就创建。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">status_t</span> AudioTrack::createTrack_l()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">const</span> sp&lt;IAudioFlinger&gt;&amp; audioFlinger = AudioSystem::get_audio_flinger();</div><div class="line">    ......</div><div class="line">    <span class="keyword">audio_io_handle_t</span> output;</div><div class="line">    <span class="keyword">audio_stream_type_t</span> streamType = mStreamType;</div><div class="line">    ......</div><div class="line">    status = AudioSystem::getOutputForAttr(attr, &amp;output,</div><div class="line">                                           mSessionId, &amp;streamType, mClientUid,</div><div class="line">                                           &amp;config,</div><div class="line">                                           mFlags, mSelectedDeviceId, &amp;mPortId);</div><div class="line">    ......</div><div class="line">    sp&lt;IAudioTrack&gt; track = audioFlinger-&gt;createTrack(streamType,</div><div class="line">                                                      mSampleRate,</div><div class="line">                                                      mFormat,</div><div class="line">                                                      mChannelMask,</div><div class="line">                                                      &amp;temp,</div><div class="line">                                                      &amp;flags,</div><div class="line">                                                      mSharedBuffer,</div><div class="line">                                                      output,</div><div class="line">                                                      mClientPid,</div><div class="line">                                                      tid,</div><div class="line">                                                      &amp;mSessionId,</div><div class="line">                                                      mClientUid,</div><div class="line">                                                      &amp;status,</div><div class="line">                                                      mPortId);</div><div class="line">    ......</div><div class="line">    sp&lt;IMemory&gt; iMem = track-&gt;getCblk(); <span class="comment">// 这里获取整个匿名共享内存IMemory</span></div><div class="line">    ......</div><div class="line">    <span class="keyword">void</span> *iMemPointer = iMem-&gt;pointer(); <span class="comment">// 映射匿名共享内存到当前进程，获取共享内存首地址</span></div><div class="line">    ......</div><div class="line">    mAudioTrack = track; <span class="comment">// 保存AudioFlinger::PlaybackThread::Track的代理对象 IAudioTrack</span></div><div class="line">    mCblkMemory = iMem;  <span class="comment">// 保存匿名共享内存</span></div><div class="line"></div><div class="line">    <span class="comment">// 控制块位于匿名共享内存的首部</span></div><div class="line">    <span class="keyword">audio_track_cblk_t</span>* cblk = <span class="keyword">static_cast</span>&lt;<span class="keyword">audio_track_cblk_t</span>*&gt;(iMemPointer);</div><div class="line">    mCblk = cblk;</div><div class="line">    ......</div><div class="line">    <span class="keyword">void</span>* buffers;</div><div class="line">    <span class="keyword">if</span> (mSharedBuffer == <span class="number">0</span>) &#123;</div><div class="line">        buffers = cblk + <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        buffers = mSharedBuffer-&gt;pointer();</div><div class="line">        <span class="keyword">if</span> (buffers == <span class="literal">NULL</span>) &#123;</div><div class="line">            ALOGE(<span class="string">"Could not get buffer pointer"</span>);</div><div class="line">            <span class="keyword">return</span> NO_INIT;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">    mServer = <span class="number">0</span>;</div><div class="line">    <span class="comment">// update proxy</span></div><div class="line">    <span class="keyword">if</span> (mSharedBuffer == <span class="number">0</span>) &#123;</div><div class="line">        mStaticProxy.clear();</div><div class="line">        <span class="comment">// 当mSharedBuffer为空，意味着音轨数据模式为MODE_STREAM，那么创建</span></div><div class="line">        <span class="comment">// AudioTrackClientProxy对象</span></div><div class="line">        mProxy = <span class="keyword">new</span> AudioTrackClientProxy(cblk, buffers, frameCount, mFrameSize);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 当mSharedBuffer非空，意味着音轨数据模式为MODE_STATIC，那么创建</span></div><div class="line">        <span class="comment">// StaticAudioTrackClientProxy对象</span></div><div class="line">        mStaticProxy = <span class="keyword">new</span> StaticAudioTrackClientProxy(cblk, buffers, frameCount, mFrameSize);</div><div class="line">        mProxy = mStaticProxy;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在AudioPolicyService启动的时候在AudioPolicyService中会保存着与放音线程PlaybackThread对应的output，这里首先通过streamType等参数获取audio_io_handle_t代表的output，然后进入AudioFlinger创建IAudioTrack。通过IAudioTrack获取整个匿名共享内存IMemory，然后再映射匿名共享内存到当前进程，保存到mCblkMemory，mCblkMemory的首部是匿名共享内存控制块audio_track_cblk_t，最后创建AudioTrackClientProxy，后续通过AudioTrackClientProxy操作共享内存写数据。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/av/services/audioflinger/AudioFlinger.cpp</span></div><div class="line">sp&lt;IAudioTrack&gt; AudioFlinger::createTrack(</div><div class="line">        ......</div><div class="line">        <span class="keyword">const</span> sp&lt;IMemory&gt;&amp; sharedBuffer,</div><div class="line">        <span class="keyword">audio_io_handle_t</span> output,</div><div class="line">        ......)</div><div class="line">&#123;</div><div class="line">    sp&lt;PlaybackThread::Track&gt; track;</div><div class="line">    sp&lt;TrackHandle&gt; trackHandle;</div><div class="line">    sp&lt;Client&gt; client;</div><div class="line">    ......</div><div class="line">    &#123;</div><div class="line">        Mutex::Autolock _l(mLock);</div><div class="line">        <span class="comment">// 根据传入来的audio_io_handle_t，找到对应的PlaybackThread</span></div><div class="line">        PlaybackThread *thread = checkPlaybackThread_l(output);</div><div class="line">        <span class="keyword">if</span> (thread == <span class="literal">NULL</span>) &#123;</div><div class="line">            ALOGE(<span class="string">"no playback thread found for output handle %d"</span>, output);</div><div class="line">            lStatus = BAD_VALUE;</div><div class="line">            <span class="keyword">goto</span> Exit;</div><div class="line">        &#125;</div><div class="line">        client = registerPid(pid);</div><div class="line">        ......</div><div class="line">        track = thread-&gt;createTrack_l(client, streamType, sampleRate, format,</div><div class="line">                channelMask, frameCount, sharedBuffer, lSessionId, flags, tid,</div><div class="line">                clientUid, &amp;lStatus, portId);</div><div class="line">        ......</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// return handle to client</span></div><div class="line">    trackHandle = <span class="keyword">new</span> TrackHandle(track);<span class="comment">// 创建Track的代理TrackHandle并返回</span></div><div class="line">Exit:</div><div class="line">    *status = lStatus;</div><div class="line">    <span class="keyword">return</span> trackHandle;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在AudioFlinger中首先根据audio_io_handle_t找到相应的放音线程PlaybackThread，创建Client保存对应的客户端，在PlaybackThread中创建Track，最后创建Track的代理TrackHandle并返回到AudioTrack。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/av/services/audioflinger/Threads.cpp</span></div><div class="line">sp&lt;AudioFlinger::PlaybackThread::Track&gt; AudioFlinger::PlaybackThread::createTrack_l(</div><div class="line">        <span class="keyword">const</span> sp&lt;AudioFlinger::Client&gt;&amp; client,</div><div class="line">        ......</div><div class="line">        <span class="keyword">const</span> sp&lt;IMemory&gt;&amp; sharedBuffer,</div><div class="line">        ......)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">size_t</span> frameCount = *pFrameCount;</div><div class="line">    sp&lt;Track&gt; track;</div><div class="line">    <span class="keyword">status_t</span> lStatus;</div><div class="line">    ......</div><div class="line">    <span class="comment">// For normal PCM streaming tracks, update minimum frame count.</span></div><div class="line">    <span class="comment">// For compatibility with AudioTrack calculation, buffer depth is forced</span></div><div class="line">    <span class="comment">// to be at least 2 x the normal mixer frame count and cover audio hardware latency.</span></div><div class="line">    <span class="comment">// This is probably too conservative, but legacy application code may depend on it.</span></div><div class="line">    <span class="comment">// If you change this calculation, also review the start threshold which is related.</span></div><div class="line">    <span class="keyword">if</span> (!(*flags &amp; AUDIO_OUTPUT_FLAG_FAST)</div><div class="line">            &amp;&amp; audio_has_proportional_frames(format) &amp;&amp; sharedBuffer == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// this must match AudioTrack.cpp calculateMinFrameCount().</span></div><div class="line">        <span class="comment">// <span class="doctag">TODO:</span> Move to a common library</span></div><div class="line">        <span class="keyword">uint32_t</span> latencyMs = <span class="number">0</span>;</div><div class="line">        lStatus = mOutput-&gt;stream-&gt;getLatency(&amp;latencyMs);</div><div class="line">        <span class="keyword">if</span> (lStatus != OK) &#123;</div><div class="line">            ALOGE(<span class="string">"Error when retrieving output stream latency: %d"</span>, lStatus);</div><div class="line">            <span class="keyword">goto</span> Exit;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">uint32_t</span> minBufCount = latencyMs / ((<span class="number">1000</span> * mNormalFrameCount) / mSampleRate);</div><div class="line">        <span class="keyword">if</span> (minBufCount &lt; <span class="number">2</span>) &#123;</div><div class="line">            minBufCount = <span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// For normal mixing tracks, if speed is &gt; 1.0f (normal), AudioTrack</span></div><div class="line">        <span class="comment">// or the client should compute and pass in a larger buffer request.</span></div><div class="line">        <span class="keyword">size_t</span> minFrameCount =</div><div class="line">                minBufCount * sourceFramesNeededWithTimestretch(</div><div class="line">                        sampleRate, mNormalFrameCount,</div><div class="line">                        mSampleRate, AUDIO_TIMESTRETCH_SPEED_NORMAL <span class="comment">/*speed*/</span>);</div><div class="line">        <span class="keyword">if</span> (frameCount &lt; minFrameCount) &#123; <span class="comment">// including frameCount == 0</span></div><div class="line">            frameCount = minFrameCount;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">    &#123; <span class="comment">// scope for mLock</span></div><div class="line">        Mutex::Autolock _l(mLock);</div><div class="line">        ......</div><div class="line">        track = <span class="keyword">new</span> Track(<span class="keyword">this</span>, client, streamType, sampleRate, format,</div><div class="line">                          channelMask, frameCount, <span class="literal">NULL</span>, sharedBuffer,</div><div class="line">                          sessionId, uid, *flags, TrackBase::TYPE_DEFAULT, portId);</div><div class="line">        ......</div><div class="line">    &#125;</div><div class="line">    lStatus = NO_ERROR;</div><div class="line">Exit:</div><div class="line">    *status = lStatus;</div><div class="line">    <span class="keyword">return</span> track;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>根据HAL的参数获取延迟latencyMs，mNormalFrameCount是在放音线程PlaybackThread创建时，预先初始化的frame count，根据这两个值得出播放当前音频需要的最小的buffer count，继而的到最小的frame count，然后创建Track。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/av/services/audioflinger/Tracks.cpp</span></div><div class="line">AudioFlinger::PlaybackThread::Track::Track(</div><div class="line">            PlaybackThread *thread,</div><div class="line">            <span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</div><div class="line">            <span class="keyword">audio_stream_type_t</span> streamType,</div><div class="line">            <span class="keyword">uint32_t</span> sampleRate,</div><div class="line">            <span class="keyword">audio_format_t</span> format,</div><div class="line">            <span class="keyword">audio_channel_mask_t</span> channelMask,</div><div class="line">            <span class="keyword">size_t</span> frameCount,</div><div class="line">            <span class="keyword">void</span> *buffer,</div><div class="line">            <span class="keyword">const</span> sp&lt;IMemory&gt;&amp; sharedBuffer,</div><div class="line">            <span class="keyword">audio_session_t</span> sessionId,</div><div class="line">            <span class="keyword">uid_t</span> uid,</div><div class="line">            <span class="keyword">audio_output_flags_t</span> flags,</div><div class="line">            track_type type,</div><div class="line">            <span class="keyword">audio_port_handle_t</span> portId)</div><div class="line">    :   TrackBase(thread, client, sampleRate, format, channelMask, frameCount,</div><div class="line">                  (sharedBuffer != <span class="number">0</span>) ? sharedBuffer-&gt;pointer() : buffer,</div><div class="line">                  sessionId, uid, <span class="literal">true</span> <span class="comment">/*isOut*/</span>, (type == TYPE_PATCH) ? </div><div class="line">                  ( buffer == <span class="literal">NULL</span> ? ALLOC_LOCAL : ALLOC_NONE) : ALLOC_CBLK,</div><div class="line">                  type, portId),</div><div class="line">    mFillingUpStatus(FS_INVALID),</div><div class="line">    <span class="comment">// mRetryCount initialized later when needed</span></div><div class="line">    mSharedBuffer(sharedBuffer),</div><div class="line">    ......</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    <span class="keyword">if</span> (sharedBuffer == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 数据传输模式为MODE_STREAM模式，创建一个AudioTrackServerProxy对象</span></div><div class="line">        <span class="comment">// PlaybackThread将持续使用它从环形buffer上取得可读数据的位置</span></div><div class="line">        mAudioTrackServerProxy = <span class="keyword">new</span> AudioTrackServerProxy(mCblk, mBuffer, frameCount,</div><div class="line">                mFrameSize, !isExternalTrack(), sampleRate);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Is the shared buffer of sufficient size?</span></div><div class="line">        <span class="comment">// (frameCount * mFrameSize) is &lt;= SIZE_MAX, checked in TrackBase.</span></div><div class="line">        <span class="keyword">if</span> (sharedBuffer-&gt;size() &lt; frameCount * mFrameSize) &#123;</div><div class="line">            <span class="comment">// Workaround: clear out mCblk to indicate track hasn't been properly created.</span></div><div class="line">            mCblk-&gt;~<span class="keyword">audio_track_cblk_t</span>();   <span class="comment">// destroy our shared-structure.</span></div><div class="line">            <span class="keyword">if</span> (mClient == <span class="number">0</span>) &#123;</div><div class="line">                <span class="built_in">free</span>(mCblk);</div><div class="line">            &#125;</div><div class="line">            mCblk = <span class="literal">NULL</span>;</div><div class="line">            mSharedBuffer.clear(); <span class="comment">// release shared buffer early</span></div><div class="line">            android_errorWriteLog(<span class="number">0x534e4554</span>, <span class="string">"38340117"</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 数据传输模式为MODE_STATIC模式，创建一个StaticAudioTrackServerProxy对象</span></div><div class="line">        mAudioTrackServerProxy = <span class="keyword">new</span> StaticAudioTrackServerProxy(mCblk, mBuffer, frameCount,</div><div class="line">                mFrameSize);</div><div class="line">    &#125;</div><div class="line">    mServerProxy = mAudioTrackServerProxy;</div><div class="line">    ......</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// frameworks/av/services/audioflinger/Tracks.cpp</span></div><div class="line">AudioFlinger::ThreadBase::TrackBase::TrackBase(</div><div class="line">            ThreadBase *thread,</div><div class="line">            <span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</div><div class="line">            <span class="keyword">uint32_t</span> sampleRate,</div><div class="line">            <span class="keyword">audio_format_t</span> format,</div><div class="line">            <span class="keyword">audio_channel_mask_t</span> channelMask,</div><div class="line">            <span class="keyword">size_t</span> frameCount,</div><div class="line">            <span class="keyword">void</span> *buffer,</div><div class="line">            <span class="keyword">audio_session_t</span> sessionId,</div><div class="line">            <span class="keyword">uid_t</span> clientUid,</div><div class="line">            <span class="keyword">bool</span> isOut,</div><div class="line">            alloc_type alloc,</div><div class="line">            track_type type,</div><div class="line">            <span class="keyword">audio_port_handle_t</span> portId)</div><div class="line">    :   RefBase(),</div><div class="line">        mThread(thread),</div><div class="line">        mClient(client),</div><div class="line">        mFrameSize(audio_has_proportional_frames(format) ?</div><div class="line">                mChannelCount * audio_bytes_per_sample(format) : <span class="keyword">sizeof</span>(<span class="keyword">int8_t</span>))</div><div class="line">        ......</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    <span class="keyword">size_t</span> bufferSize = buffer == <span class="literal">NULL</span> ? roundup(frameCount) : frameCount;</div><div class="line">    bufferSize *= mFrameSize;</div><div class="line">    <span class="keyword">size_t</span> size = <span class="keyword">sizeof</span>(<span class="keyword">audio_track_cblk_t</span>);</div><div class="line">    <span class="keyword">if</span> (buffer == <span class="literal">NULL</span> &amp;&amp; alloc == ALLOC_CBLK) &#123;</div><div class="line">        <span class="comment">// check overflow when computing allocation size for streaming tracks.</span></div><div class="line">        <span class="keyword">if</span> (size &gt; SIZE_MAX - bufferSize) &#123;</div><div class="line">            android_errorWriteLog(<span class="number">0x534e4554</span>, <span class="string">"34749571"</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        size += bufferSize;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (client != <span class="number">0</span>) &#123;</div><div class="line">        mCblkMemory = client-&gt;heap()-&gt;allocate(size); <span class="comment">// 创建共享内存并映射当前进程</span></div><div class="line">        <span class="keyword">if</span> (mCblkMemory == <span class="number">0</span> ||</div><div class="line">                (mCblk = <span class="keyword">static_cast</span>&lt;<span class="keyword">audio_track_cblk_t</span> *&gt;(mCblkMemory-&gt;pointer())) == <span class="literal">NULL</span>) &#123;</div><div class="line">            ALOGE(<span class="string">"not enough memory for AudioTrack size=%zu"</span>, size);</div><div class="line">            client-&gt;heap()-&gt;dump(<span class="string">"AudioTrack"</span>);</div><div class="line">            mCblkMemory.clear();</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line">    ......</div><div class="line">    <span class="comment">// construct the shared structure in-place.</span></div><div class="line">    <span class="keyword">if</span> (mCblk != <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="comment">// 这是C++的placement new（定位创建对象）语法：new(@BUFFER) @CLASS();</span></div><div class="line">        <span class="comment">// 可以在特定内存位置上构造一个对象</span></div><div class="line">        <span class="comment">// 这里，在匿名共享内存首地址上构造了一个audio_track_cblk_ 对象</span></div><div class="line">        <span class="comment">// 这样AudioTrack与AudioFlinger都能访问这个audio_track_cblk_t对象了</span></div><div class="line">        <span class="keyword">new</span>(mCblk) <span class="keyword">audio_track_cblk_t</span>();</div><div class="line">        <span class="keyword">switch</span> (alloc) &#123;</div><div class="line">        ......</div><div class="line">        <span class="keyword">case</span> ALLOC_CBLK:</div><div class="line">            <span class="comment">// clear all buffers</span></div><div class="line">            <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>) &#123;</div><div class="line">                <span class="comment">// 数据传输模式为MODE_STREAM时，数据buffer的分配</span></div><div class="line">                <span class="comment">// 数据buffer的首地址紧靠控制块（audio_track_cblk_t）之后</span></div><div class="line">                mBuffer = (<span class="keyword">char</span>*)mCblk + <span class="keyword">sizeof</span>(<span class="keyword">audio_track_cblk_t</span>);</div><div class="line">                <span class="built_in">memset</span>(mBuffer, <span class="number">0</span>, bufferSize);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 数据传输模式为MODE_STATIC时，直接指向sharedBuffer</span></div><div class="line">                <span class="comment">// sharedBuffer是应用进程分配的匿名共享内存，应用进程已经一次性把数据</span></div><div class="line">                <span class="comment">// 写到sharedBuffer来了，AudioFlinger可以直接从这里读取</span></div><div class="line">                mBuffer = buffer;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        ......</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// system/meida/audio/include/system/audio.h</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> size_t <span class="title">audio_bytes_per_sample</span><span class="params">(<span class="keyword">audio_format_t</span> format)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">size_t</span> size = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (format) &#123;</div><div class="line">    <span class="keyword">case</span> AUDIO_FORMAT_PCM_32_BIT:</div><div class="line">    <span class="keyword">case</span> AUDIO_FORMAT_PCM_8_24_BIT:</div><div class="line">        size = <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> AUDIO_FORMAT_PCM_24_BIT_PACKED:</div><div class="line">        size = <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>) * <span class="number">3</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> AUDIO_FORMAT_PCM_16_BIT:</div><div class="line">    <span class="keyword">case</span> AUDIO_FORMAT_IEC61937:</div><div class="line">        size = <span class="keyword">sizeof</span>(<span class="keyword">int16_t</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> AUDIO_FORMAT_PCM_8_BIT:</div><div class="line">        size = <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> AUDIO_FORMAT_PCM_FLOAT:</div><div class="line">        size = <span class="keyword">sizeof</span>(<span class="keyword">float</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> size;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Track从TrackBase继承而来，所以会先执行TrackBase构造函数，mFrameSize会根据format和channel count计算而得，比如双声道，forma为AUDIO_FORMAT_PCM_16_BIT，则mFrameSize为4Byte。计算共享内存大小，其大小为控制块大小加上真正数据大小。<br>size = sizeof(audio_track_cblk_t) + framecount * mFrameSize<br>然后会创建匿名共享内存并且映射到当前进程mCblkMemory = client-&gt;heap()-&gt;allocate(size);<br>然后使用C++的placement new（定位创建对象）在匿名共享内存上创建共享内存控制块。最后将mBuffer清空，创建AudioTrackServerProxy，后续一次操作共享内存读取数据。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">sp&lt;AudioFlinger::Client&gt; AudioFlinger::registerPid(<span class="keyword">pid_t</span> pid)</div><div class="line">&#123;</div><div class="line">    Mutex::Autolock _cl(mClientLock);</div><div class="line">    <span class="comment">// If pid is already in the mClients wp&lt;&gt; map, then use that entry</span></div><div class="line">    <span class="comment">// (for which promote() is always != 0), otherwise create a new entry and Client.</span></div><div class="line">    sp&lt;Client&gt; client = mClients.valueFor(pid).promote();</div><div class="line">    <span class="keyword">if</span> (client == <span class="number">0</span>) &#123;</div><div class="line">        client = <span class="keyword">new</span> Client(<span class="keyword">this</span>, pid);</div><div class="line">        mClients.add(pid, client);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> client;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Max shared memory size for audio tracks and audio records per client process</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kClientSharedHeapSizeBytes = <span class="number">1024</span>*<span class="number">1024</span>;</div><div class="line"><span class="comment">// Shared memory size multiplier for non low ram devices</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kClientSharedHeapSizeMultiplier = <span class="number">4</span>;</div><div class="line"></div><div class="line">AudioFlinger::Client::Client(<span class="keyword">const</span> sp&lt;AudioFlinger&gt;&amp; audioFlinger, <span class="keyword">pid_t</span> pid)</div><div class="line">    :   RefBase(),</div><div class="line">        mAudioFlinger(audioFlinger),</div><div class="line">        mPid(pid)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">size_t</span> heapSize = property_get_int32(<span class="string">"ro.af.client_heap_size_kbyte"</span>, <span class="number">0</span>);</div><div class="line">    heapSize *= <span class="number">1024</span>;</div><div class="line">    <span class="keyword">if</span> (!heapSize) &#123;</div><div class="line">        heapSize = kClientSharedHeapSizeBytes;</div><div class="line">        <span class="comment">// Increase heap size on non low ram devices to limit risk of reconnection </span></div><div class="line">        <span class="comment">// failure for invalidated tracks</span></div><div class="line">        <span class="comment">// 目前一般的设备都不是RAM比较小的设备，所以一般默认申请4M内存</span></div><div class="line">        <span class="keyword">if</span> (!audioFlinger-&gt;isLowRamDevice()) &#123;</div><div class="line">            heapSize *= kClientSharedHeapSizeMultiplier;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    mMemoryDealer = <span class="keyword">new</span> MemoryDealer(heapSize, <span class="string">"AudioFlinger::Client"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>创建共享内存使用了Client类，client-&gt;heap()-&gt;allocate(size)，创建Client即创建内存管理接口MemoryDealer，即MemoryHeapBase。下一节分析匿名共享内存的C++接口，再具体分析匿名共享内存的管理。</p><h2 id="匿名共享内存C-接口"><a href="#匿名共享内存C-接口" class="headerlink" title="匿名共享内存C++接口"></a>匿名共享内存C++接口</h2><h3 id="MemoryHeapBase"><a href="#MemoryHeapBase" class="headerlink" title="MemoryHeapBase"></a>MemoryHeapBase</h3><p>MemoryHeapBase类的对象可以作为Binder对象在进程间传输，作为一个Binder对象，就有Server端对象和Client端引用的概念。下面先看Server端的实现。<br><img src="https://i.imgur.com/fWwABNR.png" alt=""><br>共同基类RefBase，主要用于智能指针的使用。在ProcessState中打开Binder驱动，IPCThreadState通过ProcessState和Binder驱动交互，当有服务请求时，会先调用IPCThreadState的transact函数，进而调用BBinder的transact函数，根据继承关系会调动BnMemoryHeap的onTransact函数，根据code决定调用具体实现函数，从而进入MemoryHeapBase。这就是一次通信在服务端的运行流程。</p><p>MemoryHeapBase要创建共享内存，接下来看看其中一个构造函数具体实现。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/native/libs/binder/MemoryHeapBase.cpp</span></div><div class="line">MemoryHeapBase::MemoryHeapBase(<span class="keyword">size_t</span> size, <span class="keyword">uint32_t</span> flags, <span class="keyword">char</span> <span class="keyword">const</span> * name)</div><div class="line">    : mFD(<span class="number">-1</span>), mSize(<span class="number">0</span>), mBase(MAP_FAILED), mFlags(flags),</div><div class="line">      mDevice(<span class="number">0</span>), mNeedUnmap(<span class="literal">false</span>), mOffset(<span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 获得系统中一页大小的内存</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> pagesize = getpagesize();</div><div class="line">    <span class="comment">// 内存页对齐</span></div><div class="line">    size = ((size + pagesize<span class="number">-1</span>) &amp; ~(pagesize<span class="number">-1</span>));</div><div class="line">    <span class="comment">// 创建一块匿名共享内存</span></div><div class="line">    <span class="keyword">int</span> fd = ashmem_create_region(name == <span class="literal">NULL</span> ? <span class="string">"MemoryHeapBase"</span> : name, size);</div><div class="line">    ALOGE_IF(fd&lt;<span class="number">0</span>, <span class="string">"error creating ashmem region: %s"</span>, strerror(errno));</div><div class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 将创建的匿名共享内存映射到当前进程地址空间中</span></div><div class="line">        <span class="keyword">if</span> (mapfd(fd, size) == NO_ERROR) &#123;</div><div class="line">            <span class="comment">// 如果地址映射成功，修改匿名共享内存的访问属性</span></div><div class="line">            <span class="keyword">if</span> (flags &amp; READ_ONLY) &#123;</div><div class="line">                ashmem_set_prot_region(fd, PROT_READ);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在以上构造函数中根据参数，利用匿名共享内存提供的C语言接口创建一块匿名共享内存，并映射到当前进程的虚拟地址空间，参数size是指定匿名共享内存的大小，flags指定匿名共享内存的访问属性，name指定匿名共享内存的名称，如果没有指定名称，默认命名为MemoryHeapBase。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/native/libs/binder/MemoryHeapBase.cpp</span></div><div class="line"><span class="keyword">status_t</span> MemoryHeapBase::mapfd(<span class="keyword">int</span> fd, <span class="keyword">size_t</span> size, <span class="keyword">uint32_t</span> offset)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// try to figure out the size automatically</span></div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></div><div class="line">        <span class="keyword">if</span> (fstat(fd, &amp;sb) == <span class="number">0</span>)</div><div class="line">            size = sb.st_size;</div><div class="line">        <span class="comment">// if it didn't work, let mmap() fail.</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> ((mFlags &amp; DONT_MAP_LOCALLY) == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 通过mmap系统调用进入内核空间的匿名共享内存驱动，</span></div><div class="line">        <span class="comment">// 并调用ashmem_mmap函数将匿名共享内存映射到当前进程</span></div><div class="line">        <span class="keyword">void</span>* base = (<span class="keyword">uint8_t</span>*)mmap(<span class="number">0</span>, size,</div><div class="line">                PROT_READ|PROT_WRITE, MAP_SHARED, fd, offset);</div><div class="line">        <span class="keyword">if</span> (base == MAP_FAILED) &#123;</div><div class="line">            ALOGE(<span class="string">"mmap(fd=%d, size=%u) failed (%s)"</span>,</div><div class="line">                    fd, <span class="keyword">uint32_t</span>(size), strerror(errno));</div><div class="line">            close(fd);</div><div class="line">            <span class="keyword">return</span> -errno;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//ALOGD("mmap(fd=%d, base=%p, size=%lu)", fd, base, size);</span></div><div class="line">        mBase = base;</div><div class="line">        mNeedUnmap = <span class="literal">true</span>;</div><div class="line">    &#125; <span class="keyword">else</span>  &#123;</div><div class="line">        mBase = <span class="number">0</span>; <span class="comment">// not MAP_FAILED</span></div><div class="line">        mNeedUnmap = <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    mFD = fd;</div><div class="line">    mSize = size;</div><div class="line">    mOffset = offset;</div><div class="line">    <span class="keyword">return</span> NO_ERROR;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>mmap函数的第一个参数0表示由内核来决定这个匿名共享内存文件在进程地址空间的起始位置，第二个参数size表示要映射的匿名共享内文件的大小，第三个参数PROT_READ|PROT_WRITE表示这个匿名共享内存是可读写的，第四个参数fd指定要映射的匿名共享内存的文件描述符，第五个参数offset表示要从这个文件的哪个偏移位置开始映射。调用了这个函数之后，最后会进入到内核空间的ashmem驱动程序模块中去执行ashmem_mmap函数，调用mmap函数返回之后，就得这块匿名共享内存在本进程地址空间中的起始访问地址了，将这个地址保存在成员变量mBase中，最后，还将这个匿名共享内存的文件描述符和以及大小分别保存在成员变量mFD和mSize，并提供了相应接口函数来访问这些变量值。通过构造MemoryHeapBase对象就可以创建一块匿名共享内存，或者映射一块已经创建的匿名共享内存到当前进程的地址空间。</p><p>接下来我们再来看一下MemoryHeapBase在Client端实现。<br><img src="https://i.imgur.com/RATRreG.png" alt=""><br>在和匿名共享内存操作相关的类中，BpMemoryHeap类是前面分析的MemoryHeapBase类在Client端进程的远接接口类，当Client端进程从Service Manager或者其它途径获得了一个MemoryHeapBase对象的引用之后，就会在本地创建一个BpMemoryHeap对象来代表这个引用。BpMemoryHeap类同样是要实现IMemoryHeap接口，Client端将调用传递给BpMemoryHeap，BpMemoryHeap的基类BpRefBase有一个mRemote对象，指向BpBinder,所以通过调用BpBinder的transact函数进而调用IPCThreadState，将请求传递给Server端。</p><p>BpMemoryHeap的声明如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/native/libs/binder/IMemory.cpp</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BpMemoryHeap</span> :</span> <span class="keyword">public</span> BpInterface&lt;IMemoryHeap&gt;</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BpMemoryHeap</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; impl)</span></span>;</div><div class="line">    <span class="keyword">virtual</span> ~BpMemoryHeap();</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getHeapID</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>* <span class="title">getBase</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> size_t <span class="title">getSize</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> uint32_t <span class="title">getFlags</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> uint32_t <span class="title">getOffset</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">IMemory</span>;</span></div><div class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapCache</span>;</span></div><div class="line">    <span class="comment">// for debugging in this module</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> sp&lt;IMemoryHeap&gt; find_heap(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder) &#123;</div><div class="line">        <span class="keyword">return</span> gHeapCache-&gt;find_heap(binder);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">free_heap</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder)</span> </span>&#123;</div><div class="line">        gHeapCache-&gt;free_heap(binder);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> sp&lt;IMemoryHeap&gt; get_heap(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder) &#123;</div><div class="line">        <span class="keyword">return</span> gHeapCache-&gt;get_heap(binder);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dump_heaps</span><span class="params">()</span> </span>&#123;</div><div class="line">        gHeapCache-&gt;dump_heaps();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">assertMapped</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">assertReallyMapped</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::atomic&lt;<span class="keyword">int32_t</span>&gt; mHeapId;</div><div class="line">    <span class="keyword">mutable</span> <span class="keyword">void</span>*       mBase;</div><div class="line">    <span class="keyword">mutable</span> <span class="keyword">size_t</span>      mSize;</div><div class="line">    <span class="keyword">mutable</span> <span class="keyword">uint32_t</span>    mFlags;</div><div class="line">    <span class="keyword">mutable</span> <span class="keyword">uint32_t</span>    mOffset;</div><div class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span>        mRealHeap;</div><div class="line">    <span class="keyword">mutable</span> Mutex       mLock;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>先来看构造函数BpMemoryHeap的实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">BpMemoryHeap::BpMemoryHeap(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; impl)</div><div class="line">    : BpInterface&lt;IMemoryHeap&gt;(impl),</div><div class="line">        mHeapId(<span class="number">-1</span>), mBase(MAP_FAILED), mSize(<span class="number">0</span>), mFlags(<span class="number">0</span>), mOffset(<span class="number">0</span>), mRealHeap(<span class="literal">false</span>)</div><div class="line">&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>它的实现很简单，只是初始化一下各个成员变量，例如，表示匿名共享内存文件描述符的mHeapId值初化为-1、表示匿名内共享内存基地址的mBase值初始化为MAP_FAILED以及表示匿名共享内存大小的mSize初始为为0，它们都表示在Client端进程中，这个匿名共享内存还未准备就绪，要等到第一次使用时才会去创建。这里还需要注意的一点，参数impl指向的是一个BpBinder对象，它里面包含了一个指向Server端Binder对象，即MemoryHeapBase对象的引用。</p><p>以获取共享内存基地址为例，看看Client端如何获取服务端创建的共享内存。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/native/libs/binder/IMemory.cpp</span></div><div class="line"><span class="keyword">void</span>* BpMemoryHeap::getBase() <span class="keyword">const</span> &#123;</div><div class="line">    assertMapped();</div><div class="line">    <span class="keyword">return</span> mBase;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> BpMemoryHeap::assertMapped() <span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int32_t</span> heapId = mHeapId.load(memory_order_acquire);</div><div class="line">    <span class="comment">// 如果还没有请求服务创建匿名共享内存</span></div><div class="line">    <span class="keyword">if</span> (heapId == <span class="number">-1</span>) &#123;</div><div class="line">        <span class="comment">// 将当前BpMemoryHeap对象转换为IBinder对象</span></div><div class="line">        sp&lt;IBinder&gt; binder(IInterface::asBinder(<span class="keyword">const_cast</span>&lt;BpMemoryHeap*&gt;(<span class="keyword">this</span>)));</div><div class="line">        <span class="comment">// 从成员变量gHeapCache中查找对应的BpMemoryHeap对象</span></div><div class="line">        sp&lt;BpMemoryHeap&gt; heap(<span class="keyword">static_cast</span>&lt;BpMemoryHeap*&gt;(find_heap(binder).get()));</div><div class="line">        <span class="comment">// 向服务端请求获取匿名共享内存信息</span></div><div class="line">        heap-&gt;assertReallyMapped();</div><div class="line">        <span class="comment">// 判断该匿名共享内存是否映射成功</span></div><div class="line">        <span class="keyword">if</span> (heap-&gt;mBase != MAP_FAILED) &#123;</div><div class="line">            Mutex::Autolock _l(mLock);</div><div class="line">            <span class="comment">// 保存服务端返回回来的匿名共享内存信息</span></div><div class="line">            <span class="keyword">if</span> (mHeapId.load(memory_order_relaxed) == <span class="number">-1</span>) &#123;</div><div class="line">                mBase   = heap-&gt;mBase;</div><div class="line">                mSize   = heap-&gt;mSize;</div><div class="line">                mOffset = heap-&gt;mOffset;</div><div class="line">                <span class="keyword">int</span> fd = fcntl(heap-&gt;mHeapId.load(memory_order_relaxed), F_DUPFD_CLOEXEC, <span class="number">0</span>);</div><div class="line">                ALOGE_IF(fd==<span class="number">-1</span>, <span class="string">"cannot dup fd=%d"</span>,</div><div class="line">                        heap-&gt;mHeapId.load(memory_order_relaxed));</div><div class="line">                mHeapId.store(fd, memory_order_release);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// something went wrong</span></div><div class="line">            free_heap(binder);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>mHeapId等于-1，表示匿名共享内存还为准备就绪，因此请求服务端MemoryHeapBase创建匿名共享内存，否则该函数不作任何处理。只有第一次使用匿名共享时才会请求服务端创建匿名共享内存。由于在客户端进程中使用同一个BpBinder代理对象可以创建多个与匿名共享内存业务相关的BpMemoryHeap对象，因此定义了类型为HeapCache的全局变量gHeapCache用来保存创建的所有BpMemoryHeap对象，assertMapped函数首先将当前BpMemoryHeap对象强制转换为IBinder类型对象，然后调用find_heap()函数从全局变量gHeapCache中查找出对应的BpMemoryHeap对象，并调用assertReallyMapped()函数向服务进程的BnemoryHeap请求创建匿名共享内存。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/native/libs/binder/IMemory.cpp</span></div><div class="line"><span class="keyword">void</span> BpMemoryHeap::assertReallyMapped() <span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int32_t</span> heapId = mHeapId.load(memory_order_acquire);</div><div class="line">    <span class="comment">// 再次判断是否已经请求创建过匿名共享内存</span></div><div class="line">    <span class="keyword">if</span> (heapId == <span class="number">-1</span>) &#123;</div><div class="line">        <span class="comment">// remote call without mLock held, worse case scenario, we end up</span></div><div class="line">        <span class="comment">// calling transact() from multiple threads, but that's not a problem,</span></div><div class="line">        <span class="comment">// only mmap below must be in the critical section.</span></div><div class="line">        Parcel data, reply;</div><div class="line">        data.writeInterfaceToken(IMemoryHeap::getInterfaceDescriptor());</div><div class="line">        <span class="comment">// 向服务端BnMemoryHeap发起请求</span></div><div class="line">        <span class="keyword">status_t</span> err = remote()-&gt;transact(HEAP_ID, data, &amp;reply);</div><div class="line">        <span class="keyword">int</span> parcel_fd = reply.readFileDescriptor();</div><div class="line">        <span class="keyword">ssize_t</span> size = reply.readInt32();</div><div class="line">        <span class="keyword">uint32_t</span> flags = reply.readInt32();</div><div class="line">        <span class="keyword">uint32_t</span> offset = reply.readInt32();</div><div class="line">        ALOGE_IF(err, <span class="string">"binder=%p transaction failed fd=%d, size=%zd, err=%d (%s)"</span>,</div><div class="line">                IInterface::asBinder(<span class="keyword">this</span>).get(),</div><div class="line">                parcel_fd, size, err, strerror(-err));</div><div class="line">        Mutex::Autolock _l(mLock);</div><div class="line">        <span class="keyword">if</span> (mHeapId.load(memory_order_relaxed) == <span class="number">-1</span>) &#123;</div><div class="line">            <span class="keyword">int</span> fd = fcntl(parcel_fd, F_DUPFD_CLOEXEC, <span class="number">0</span>);</div><div class="line">            ALOGE_IF(fd==<span class="number">-1</span>, <span class="string">"cannot dup fd=%d, size=%zd, err=%d (%s)"</span>,</div><div class="line">                    parcel_fd, size, err, strerror(errno));</div><div class="line">            <span class="keyword">int</span> access = PROT_READ;</div><div class="line">            <span class="keyword">if</span> (!(flags &amp; READ_ONLY)) &#123;</div><div class="line">                access |= PROT_WRITE;</div><div class="line">            &#125;</div><div class="line">            mRealHeap = <span class="literal">true</span>;</div><div class="line">            <span class="comment">// 将服务进程创建的匿名共享内存映射到当前客户进程的地址空间中</span></div><div class="line">            mBase = mmap(<span class="number">0</span>, size, access, MAP_SHARED, fd, offset);</div><div class="line">            <span class="keyword">if</span> (mBase == MAP_FAILED) &#123;</div><div class="line">                ALOGE(<span class="string">"cannot map BpMemoryHeap (binder=%p), size=%zd, fd=%d (%s)"</span>,</div><div class="line">                        IInterface::asBinder(<span class="keyword">this</span>).get(), size, fd, strerror(errno));</div><div class="line">                close(fd);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 映射成功后，将匿名共享内存信息保存到BpMemoryHeap的成员变量中，供其他接口函数访问</span></div><div class="line">                mSize = size;</div><div class="line">                mFlags = flags;</div><div class="line">                mOffset = offset;</div><div class="line">                mHeapId.store(fd, memory_order_release);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>该函数首先通过Binder通信方式向服务进程请求创建匿名共享内存，当服务端BnMemoryHeap对象创建完匿名共享内存后，并将共享内存信息返回到客户进程后，客户进程通过系统调用mmap函数将匿名共享内存映射到当前进程的地址空间，这样客户进程就可以访问服务进程创建的匿名共享内存了。当了解Binder通信机制，就知道BpMemoryHeap对象通过transact函数向服务端发起请求后，服务端的BnMemoryHeap的onTransact函数会被调用。</p><p>在上面获取共享内存的过程中，有一个类型为HeapCache的全局变量gHeapCache。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/native/libs/binder/IMemory.cpp</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapCache</span> :</span> <span class="keyword">public</span> IBinder::DeathRecipient</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    HeapCache();</div><div class="line">    <span class="keyword">virtual</span> ~HeapCache();</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">(<span class="keyword">const</span> wp&lt;IBinder&gt;&amp; who)</span></span>;</div><div class="line">    sp&lt;IMemoryHeap&gt; find_heap(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder);</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">free_heap</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder)</span></span>;</div><div class="line">    sp&lt;IMemoryHeap&gt; get_heap(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder);</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dump_heaps</span><span class="params">()</span></span>;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">// For IMemory.cpp</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">heap_info_t</span> &#123;</span></div><div class="line">        sp&lt;IMemoryHeap&gt; heap;</div><div class="line">        <span class="keyword">int32_t</span>         count;</div><div class="line">        <span class="comment">// Note that this cannot be meaningfully copied.</span></div><div class="line">    &#125;;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">free_heap</span><span class="params">(<span class="keyword">const</span> wp&lt;IBinder&gt;&amp; binder)</span></span>;</div><div class="line">    Mutex mHeapCacheLock;  <span class="comment">// Protects entire vector below.</span></div><div class="line">    KeyedVector&lt; wp&lt;IBinder&gt;, <span class="keyword">heap_info_t</span> &gt; mHeapCache;</div><div class="line">    <span class="comment">// We do not use the copy-on-write capabilities of KeyedVector.</span></div><div class="line">    <span class="comment">// <span class="doctag">TODO:</span> Reimplemement based on standard C++ container?</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">static</span> sp&lt;HeapCache&gt; gHeapCache = <span class="keyword">new</span> HeapCache();</div></pre></td></tr></table></figure></p><p>它里面定义了一个成员变量mHeapCache，用来维护本进程中的所有BpMemoryHeap对象，同时还提供了find_heap和get_heap函数来查找内部所维护的BpMemoryHeap对象的功能。函数find_heap和get_heap的区别是，在find_heap函数中，如果在mHeapCache找不到相应的BpMemoryHeap对象，就会把这个BpMemoryHeap对象加入到mHeapCache中去，而在get_heap函数中，则不会自动把这个BpMemoryHeap对象加入到mHeapCache中去。</p><p>这里，我们主要看一下find_heap函数的实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/native/libs/binder/IMemory.cpp</span></div><div class="line">sp&lt;IMemoryHeap&gt; HeapCache::find_heap(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder)</div><div class="line">&#123;</div><div class="line">    Mutex::Autolock _l(mHeapCacheLock);</div><div class="line">    <span class="keyword">ssize_t</span> i = mHeapCache.indexOfKey(binder);</div><div class="line">    <span class="keyword">if</span> (i&gt;=<span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">heap_info_t</span>&amp; info = mHeapCache.editValueAt(i);</div><div class="line">        ALOGD_IF(VERBOSE,</div><div class="line">                <span class="string">"found binder=%p, heap=%p, size=%zu, fd=%d, count=%d"</span>,</div><div class="line">                binder.get(), info.heap.get(),</div><div class="line">                <span class="keyword">static_cast</span>&lt;BpMemoryHeap*&gt;(info.heap.get())-&gt;mSize,</div><div class="line">                <span class="keyword">static_cast</span>&lt;BpMemoryHeap*&gt;(info.heap.get())</div><div class="line">                    -&gt;mHeapId.load(memory_order_relaxed),</div><div class="line">                info.count);</div><div class="line">        ++info.count;</div><div class="line">        <span class="keyword">return</span> info.heap;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">heap_info_t</span> info;</div><div class="line">        info.heap = interface_cast&lt;IMemoryHeap&gt;(binder);</div><div class="line">        info.count = <span class="number">1</span>;</div><div class="line">        <span class="comment">//ALOGD("adding binder=%p, heap=%p, count=%d",</span></div><div class="line">        <span class="comment">//      binder.get(), info.heap.get(), info.count);</span></div><div class="line">        mHeapCache.add(binder, info);</div><div class="line">        <span class="keyword">return</span> info.heap;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p> 这个函数很简单，首先它以传进来的参数binder为关键字，在mHeapCache中查找，看看是否有对应的heap_info对象info存在，如果有的话，就增加它的引用计数info.count值，表示这个BpBinder对象多了一个使用者；如果没有的话，那么就需要创建一个heap_info对象info，并且将它加放到mHeapCache中去了。</p><h3 id="MemoryBase"><a href="#MemoryBase" class="headerlink" title="MemoryBase"></a>MemoryBase</h3><p>MemoryBase接口是建立在MemoryHeapBase接口的基础上的，它们都可以作为一个Binder对象来在进程间进行数据共享，它们的关系如下所示：<br><img src="https://i.imgur.com/Ws4jiXt.png" alt=""><br>MemoryBase类包含了一个成员变量mHeap，它的类型的IMemoryHeap，MemoryBase类所代表的匿名共享内存就是通过这个成员变量来实现的。</p><p>MemoryBase类在Server端的实现与MemoryHeapBase类在Server端的实现是类似的，这里只要把IMemory类换成IMemoryHeap类、把BnMemory类换成BnMemoryHeap类以及MemoryBase类换成MemoryHeapBase类就变成是MemoryHeapBase类在Server端的实现了，因此，我们这里只简单分析IMemory类和MemoryBase类的实现。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">IMemory</span> :</span> <span class="keyword">public</span> IInterface</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    DECLARE_META_INTERFACE(Memory)</div><div class="line">    <span class="keyword">virtual</span> sp&lt;IMemoryHeap&gt; getMemory(<span class="keyword">ssize_t</span>* offset=<span class="number">0</span>, <span class="keyword">size_t</span>* size=<span class="number">0</span>) <span class="keyword">const</span> = <span class="number">0</span>;</div><div class="line">    <span class="comment">// helpers</span></div><div class="line">    <span class="function"><span class="keyword">void</span>* <span class="title">fastPointer</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; heap, <span class="keyword">ssize_t</span> offset)</span> <span class="keyword">const</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span>* <span class="title">pointer</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">    <span class="keyword">size_t</span> size() <span class="keyword">const</span>;</div><div class="line">    <span class="keyword">ssize_t</span> offset() <span class="keyword">const</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>成员函数getMemory用来获取内部的MemoryHeapBase对象的IMemoryHeap接口；成员函数pointer()用来获取内部所维护的匿名共享内存的基地址；成员函数size()用来获取内部所维护的匿名共享内存的大小；成员函数offset()用来获取内部所维护的这部分匿名共享内存在整个匿名共享内存中的偏移量。</p><p>IMemory类本身实现了pointer、size和offset三个成员函数，因此，它的子类，即MemoryBase类，只需要实现getMemory成员函数就可以了。IMemory类的实现定义在frameworks/native/libs/binder/IMemory.cpp文件中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span>* IMemory::fastPointer(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder, <span class="keyword">ssize_t</span> offset) <span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">    sp&lt;IMemoryHeap&gt; realHeap = BpMemoryHeap::get_heap(binder);</div><div class="line">    <span class="keyword">void</span>* <span class="keyword">const</span> base = realHeap-&gt;base();</div><div class="line">    <span class="keyword">if</span> (base == MAP_FAILED)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(base) + offset;</div><div class="line">&#125;</div><div class="line"><span class="keyword">void</span>* IMemory::pointer() <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">ssize_t</span> offset;</div><div class="line">    sp&lt;IMemoryHeap&gt; heap = getMemory(&amp;offset);</div><div class="line">    <span class="keyword">void</span>* <span class="keyword">const</span> base = heap!=<span class="number">0</span> ? heap-&gt;base() : MAP_FAILED;</div><div class="line">    <span class="keyword">if</span> (base == MAP_FAILED)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(base) + offset;</div><div class="line">&#125;</div><div class="line"><span class="keyword">size_t</span> IMemory::size() <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">size_t</span> size;</div><div class="line">    getMemory(<span class="literal">NULL</span>, &amp;size);</div><div class="line">    <span class="keyword">return</span> size;</div><div class="line">&#125;</div><div class="line"><span class="keyword">ssize_t</span> IMemory::offset() <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">ssize_t</span> offset;</div><div class="line">    getMemory(&amp;offset);</div><div class="line">    <span class="keyword">return</span> offset;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当客户端的BpMemory向服务端MemoryBase发起RPC请求后，服务端的BnMemory对象的onTransact函数被调用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">status_t</span> BnMemory::onTransact(</div><div class="line">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">switch</span>(code) &#123;</div><div class="line">        <span class="keyword">case</span> GET_MEMORY: &#123;</div><div class="line">            <span class="comment">// 根据客户端发送过来的接口描述进行检查确认</span></div><div class="line">            CHECK_INTERFACE(IMemory, data, reply);</div><div class="line">            <span class="keyword">ssize_t</span> offset;</div><div class="line">            <span class="keyword">size_t</span> size;</div><div class="line">            <span class="comment">// 调用服务端的getMemory函数获取匿名共享内存对象MemoryHeapBase</span></div><div class="line">            <span class="comment">// 及匿名共享内存大小，偏移，并返回给客户端</span></div><div class="line">            reply-&gt;writeStrongBinder( IInterface::asBinder(getMemory(&amp;offset, &amp;size)) );</div><div class="line">            <span class="comment">// 将偏移量返回给客户端</span></div><div class="line">            reply-&gt;writeInt32(offset);</div><div class="line">             <span class="comment">// 将匿名共享内存大小返回给客户端</span></div><div class="line">            reply-&gt;writeInt32(size);</div><div class="line">            <span class="keyword">return</span> NO_ERROR;</div><div class="line">        &#125; <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> BBinder::onTransact(code, data, reply, flags);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>服务端的getMemory函数由BnMemory的子类MemoryBase实现。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">sp&lt;IMemoryHeap&gt; MemoryBase::getMemory(<span class="keyword">ssize_t</span>* offset, <span class="keyword">size_t</span>* size) <span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (offset) *offset = mOffset;</div><div class="line">    <span class="keyword">if</span> (size)   *size = mSize;</div><div class="line">    <span class="keyword">return</span> mHeap;</div><div class="line">&#125;</div><div class="line"></div><div class="line">MemoryBase::MemoryBase(<span class="keyword">const</span> sp&lt;IMemoryHeap&gt;&amp; heap,</div><div class="line">        <span class="keyword">ssize_t</span> offset, <span class="keyword">size_t</span> size)</div><div class="line">    : mSize(size), mOffset(offset), mHeap(heap)</div><div class="line">&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在它的构造函数中，接受三个参数，参数heap指向的是一个MemoryHeapBase对象，真正的匿名共享内存就是由它来维护的，参数offset表示这个MemoryBase对象所要维护的这部分匿名共享内存在整个匿名共享内存块中的起始位置，参数size表示这个MemoryBase对象所要维护的这部分匿名共享内存的大小。</p><p>成员函数getMemory的实现很简单，只是简单地返回内部的MemoryHeapBase对象的IMemoryHeap接口，如果传进来的参数offset和size不为NULL，还会把其内部维护的这部分匿名共享内存在整个匿名共享内存块中的偏移位置以及这部分匿名共享内存的大小返回给调用者。</p><p>这里可以看出，MemoryBase在Server端的实现只是简单地封装了MemoryHeapBase的实现。</p><p>MemoryBase类在Client端的实现与MemoryHeapBase类在Client端的实现是类似的，这里只要把IMemory类换成IMemoryHeap类以及把BpMemory类换成BpMemoryHeap类就变成是MemoryHeapBase类在Client端的实现了，因此，我们这里只简单分析BpMemory类的实现，前面已经分析过IMemory类的实现了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BpMemory</span> :</span> <span class="keyword">public</span> BpInterface&lt;IMemory&gt;</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BpMemory</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; impl)</span></span>;</div><div class="line">    <span class="keyword">virtual</span> ~BpMemory();</div><div class="line">    <span class="keyword">virtual</span> sp&lt;IMemoryHeap&gt; getMemory(<span class="keyword">ssize_t</span>* offset=<span class="number">0</span>, <span class="keyword">size_t</span>* size=<span class="number">0</span>) <span class="keyword">const</span>;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">mutable</span> sp&lt;IMemoryHeap&gt; mHeap;</div><div class="line">    <span class="keyword">mutable</span> <span class="keyword">ssize_t</span> mOffset;</div><div class="line">    <span class="keyword">mutable</span> <span class="keyword">size_t</span> mSize;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>下面就看一下BpMemory类的成员函数getMemory的实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">sp&lt;IMemoryHeap&gt; BpMemory::getMemory(<span class="keyword">ssize_t</span>* offset, <span class="keyword">size_t</span>* size) <span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// 指向的匿名共享内存MemoryHeapBase为空</span></div><div class="line">    <span class="keyword">if</span> (mHeap == <span class="number">0</span>) &#123;</div><div class="line">        Parcel data, reply;</div><div class="line">        data.writeInterfaceToken(IMemory::getInterfaceDescriptor());</div><div class="line">        <span class="comment">// 向服务端MemoryBase发起RPC请求</span></div><div class="line">        <span class="keyword">if</span> (remote()-&gt;transact(GET_MEMORY, data, &amp;reply) == NO_ERROR) &#123;</div><div class="line">            <span class="comment">// 读取服务端返回来的结果</span></div><div class="line">            <span class="comment">// 读取匿名共享内存MemoryHeapBase的IBinder对象</span></div><div class="line">            sp&lt;IBinder&gt; heap = reply.readStrongBinder(); </div><div class="line">            <span class="keyword">ssize_t</span> o = reply.readInt32(); <span class="comment">// 读取匿名共享内存中的偏移量</span></div><div class="line">            <span class="keyword">size_t</span> s = reply.readInt32();  <span class="comment">// 读取匿名共享内存的大小</span></div><div class="line">            <span class="comment">// 如果服务端返回来的用于描述整块匿名共享内存的MemoryHeapBase不为空</span></div><div class="line">            <span class="keyword">if</span> (heap != <span class="number">0</span>) &#123;</div><div class="line">                mHeap = interface_cast&lt;IMemoryHeap&gt;(heap);</div><div class="line">                <span class="keyword">if</span> (mHeap != <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">size_t</span> heapSize = mHeap-&gt;getSize();</div><div class="line">                    <span class="comment">// 将匿名共享内存的偏移和大小保存到成员变量中</span></div><div class="line">                    <span class="keyword">if</span> (s &lt;= heapSize</div><div class="line">                            &amp;&amp; o &gt;= <span class="number">0</span></div><div class="line">                            &amp;&amp; (<span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(o) &lt;= heapSize - s)) &#123;</div><div class="line">                        mOffset = o;</div><div class="line">                        mSize = s;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="comment">// Hm.</span></div><div class="line">                        android_errorWriteWithInfoLog(<span class="number">0x534e4554</span>,</div><div class="line">                            <span class="string">"26877992"</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</div><div class="line">                        mOffset = <span class="number">0</span>;</div><div class="line">                        mSize = <span class="number">0</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 将成员变量赋值给传进来的参数，从而修改参数值</span></div><div class="line">    <span class="keyword">if</span> (offset) *offset = mOffset;</div><div class="line">    <span class="keyword">if</span> (size) *size = mSize;</div><div class="line">    <span class="keyword">return</span> (mSize &gt; <span class="number">0</span>) ? mHeap : <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果成员变量mHeap的值为NULL，就表示这个BpMemory对象尚未建立好匿名共享内存，于是，就会通过一个Binder进程间调用去Server端请求匿名共享内存信息，在这些信息中，最重要的就是这个Server端的MemoryHeapBase对象的引用heap了，通过这个引用可以在Client端进程中创建一个BpMemoryHeap远程接口，最后将这个BpMemoryHeap远程接口保存在成员变量mHeap中，同时，从Server端获得的信息还包括这块匿名共享内存在整个匿名共享内存中的偏移位置以及大小。这样，这个BpMemory对象中的匿名共享内存就准备就绪了。</p><h3 id="MemoryDealer"><a href="#MemoryDealer" class="headerlink" title="MemoryDealer"></a>MemoryDealer</h3><p>在AudioFlinger创建Client过程中，使用MemoryDealer申请共享内存,其实MemoryDealer工具类就是对MemoryHeapBase和MemoryBase的封装。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mMemoryDealer = <span class="keyword">new</span> MemoryDealer(heapSize, <span class="string">"AudioFlinger::Client"</span>);</div></pre></td></tr></table></figure></p><p>下面看看MemoryDealer的构造函数，这里会创建MemoryHeapBase，即分配4M共享内存，还会创建与一个简单分配器，后续每次通信需要的具体内存由SimpleBestFitAllocator从4M内存上分配。在SimpleBestFitAllocator中维护一个双向链表来管理这4M的内存。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">MemoryDealer::MemoryDealer(<span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">uint32_t</span> flags)</div><div class="line">    : mHeap(<span class="keyword">new</span> MemoryHeapBase(size, flags, name)),</div><div class="line">    mAllocator(<span class="keyword">new</span> SimpleBestFitAllocator(size))</div><div class="line">&#123;    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// align all the memory blocks on a cache-line boundary</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> SimpleBestFitAllocator::kMemoryAlign = <span class="number">32</span>;</div><div class="line">SimpleBestFitAllocator::SimpleBestFitAllocator(<span class="keyword">size_t</span> size)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">size_t</span> pagesize = getpagesize();</div><div class="line">    mHeapSize = ((size + pagesize<span class="number">-1</span>) &amp; ~(pagesize<span class="number">-1</span>));</div><div class="line">    <span class="keyword">chunk_t</span>* node = <span class="keyword">new</span> <span class="keyword">chunk_t</span>(<span class="number">0</span>, mHeapSize / kMemoryAlign);</div><div class="line">    mList.insertHead(node);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>前面我们看到最终申请内存通过MemoryDealer的allocate的函数，返回的是IMemory类型。从代码看，会返回Allocation，继承自MemoryBase。分配时，最终调用SimpleBestFitAllocator的alloc函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">sp&lt;IMemory&gt; MemoryDealer::allocate(<span class="keyword">size_t</span> size)</div><div class="line">&#123;</div><div class="line">    sp&lt;IMemory&gt; memory;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">ssize_t</span> offset = allocator()-&gt;allocate(size);</div><div class="line">    <span class="keyword">if</span> (offset &gt;= <span class="number">0</span>) &#123;</div><div class="line">        memory = <span class="keyword">new</span> Allocation(<span class="keyword">this</span>, heap(), offset, size);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> memory;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SimpleBestFitAllocator* MemoryDealer::allocator() <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> mAllocator;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">size_t</span> SimpleBestFitAllocator::allocate(<span class="keyword">size_t</span> size, <span class="keyword">uint32_t</span> flags)</div><div class="line">&#123;</div><div class="line">    Mutex::Autolock _l(mLock);</div><div class="line">    <span class="keyword">ssize_t</span> offset = alloc(size, flags);</div><div class="line">    <span class="keyword">return</span> offset;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> SimpleBestFitAllocator::alloc(<span class="keyword">size_t</span> size, <span class="keyword">uint32_t</span> flags)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    size = (size + kMemoryAlign<span class="number">-1</span>) / kMemoryAlign;</div><div class="line">    <span class="keyword">chunk_t</span>* free_chunk = <span class="number">0</span>;</div><div class="line">    <span class="keyword">chunk_t</span>* cur = mList.head();</div><div class="line">    <span class="keyword">size_t</span> pagesize = getpagesize();</div><div class="line">    <span class="keyword">while</span> (cur) &#123;</div><div class="line">        <span class="keyword">int</span> extra = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (flags &amp; PAGE_ALIGNED)</div><div class="line">            extra = ( -cur-&gt;start &amp; ((pagesize/kMemoryAlign)<span class="number">-1</span>) ) ;</div><div class="line">        <span class="comment">// best fit</span></div><div class="line">        <span class="keyword">if</span> (cur-&gt;<span class="built_in">free</span> &amp;&amp; (cur-&gt;size &gt;= (size+extra))) &#123;</div><div class="line">            <span class="keyword">if</span> ((!free_chunk) || (cur-&gt;size &lt; free_chunk-&gt;size)) &#123;</div><div class="line">                free_chunk = cur;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (cur-&gt;size == size) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        cur = cur-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (free_chunk) &#123;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">size_t</span> free_size = free_chunk-&gt;size;</div><div class="line">        free_chunk-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</div><div class="line">        free_chunk-&gt;size = size;</div><div class="line">        <span class="keyword">if</span> (free_size &gt; size) &#123;</div><div class="line">            <span class="keyword">int</span> extra = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> (flags &amp; PAGE_ALIGNED)</div><div class="line">                extra = ( -free_chunk-&gt;start &amp; ((pagesize/kMemoryAlign)<span class="number">-1</span>) ) ;</div><div class="line">            <span class="keyword">if</span> (extra) &#123;</div><div class="line">                <span class="keyword">chunk_t</span>* split = <span class="keyword">new</span> <span class="keyword">chunk_t</span>(free_chunk-&gt;start, extra);</div><div class="line">                free_chunk-&gt;start += extra;</div><div class="line">                mList.insertBefore(free_chunk, split);</div><div class="line">            &#125;</div><div class="line">            ALOGE_IF((flags&amp;PAGE_ALIGNED) &amp;&amp; </div><div class="line">                    ((free_chunk-&gt;start*kMemoryAlign)&amp;(pagesize<span class="number">-1</span>)),</div><div class="line">                    <span class="string">"PAGE_ALIGNED requested, but page is not aligned!!!"</span>);</div><div class="line">            <span class="keyword">const</span> <span class="keyword">ssize_t</span> tail_free = free_size - (size+extra);</div><div class="line">            <span class="keyword">if</span> (tail_free &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">chunk_t</span>* split = <span class="keyword">new</span> <span class="keyword">chunk_t</span>(</div><div class="line">                        free_chunk-&gt;start + free_chunk-&gt;size, tail_free);</div><div class="line">                mList.insertAfter(free_chunk, split);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (free_chunk-&gt;start)*kMemoryAlign;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> NO_MEMORY;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>链表节点，每次从4M空间挖取一段内存作为一个节点，不用时再释放删除节点，通过这种简单的方式来管理这段内存。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk_t</span> &#123;</span></div><div class="line">        <span class="keyword">chunk_t</span>(<span class="keyword">size_t</span> start, <span class="keyword">size_t</span> size)</div><div class="line">        : start(start), size(size), <span class="built_in">free</span>(<span class="number">1</span>), prev(<span class="number">0</span>), next(<span class="number">0</span>) &#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">size_t</span>              start;                  <span class="comment">// 起始地址</span></div><div class="line">        <span class="keyword">size_t</span>              size : <span class="number">28</span>;              <span class="comment">// 内存大小</span></div><div class="line">        <span class="keyword">int</span>                 <span class="built_in">free</span> : <span class="number">4</span>;               <span class="comment">// 是否占用</span></div><div class="line">        <span class="keyword">mutable</span> <span class="keyword">chunk_t</span>*    prev;</div><div class="line">        <span class="keyword">mutable</span> <span class="keyword">chunk_t</span>*    next;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p><h2 id="AudioTrack数据写入和AudioFlinger数据读取"><a href="#AudioTrack数据写入和AudioFlinger数据读取" class="headerlink" title="AudioTrack数据写入和AudioFlinger数据读取"></a>AudioTrack数据写入和AudioFlinger数据读取</h2><p>AudioTrack实例构造后，应用程序接着可以写入音频数据了。AudioTrack与AudioFlinger是生产者-消费者的关系：</p><ul><li>AudioTrack：AudioTrack在共享内存中找到一块可用空间，把用户传入的音频数据写入到这块可用空间上，然后更新写位置（对于AudioFinger来说，意味共享内存上有更多的可读数据了）；如果用户传入的数据量比可用空间要大，那么要把用户传入的数据拆分多次写入到共享中（AudioTrack和AudioFlinger是不同的进程，AudioFlinger同时也在不停地读取数据，所以共享内存可用空间是在不停变化的）。</li><li>AudioFlinger：AudioFlinger在共享内存中找到一块可读数据块，把可读数据拷贝到目的缓冲区上，然后更新读位置（对于AudioTrack来说，意味着共享内存上有更多的可用空间了）；如果共享内存上可读数据量比预期的要小，那么要进行多次的读取，才能积累到预期的数据量（AudioTrack和AudioFlinger是不同的进程，AudioTrack同时也在不停地写入数据，所以共享内存可读的数据量是在不停变化的）。</li></ul><p>在AudioTrack和AudioFlinger操作共享内存的时使用Proxy来管理。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/av/include/private/meida/AudioTrackShared.h</span></div><div class="line"><span class="comment">// Proxy for shared memory control block, to isolate callers </span></div><div class="line"><span class="comment">// from needing to know the details. There is exactly one</span></div><div class="line"><span class="comment">// ClientProxy and one ServerProxy per shared memory control block.</span></div><div class="line"><span class="comment">// The proxies are located in normal memory, </span></div><div class="line"><span class="comment">// and are not multi-thread safe within a given side.</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> :</span> <span class="keyword">public</span> RefBase &#123;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    Proxy(<span class="keyword">audio_track_cblk_t</span>* cblk, <span class="keyword">void</span> *buffers, <span class="keyword">size_t</span> frameCount, </div><div class="line">          <span class="keyword">size_t</span> frameSize, <span class="keyword">bool</span> isOut, <span class="keyword">bool</span> clientInServer);</div><div class="line">    <span class="keyword">virtual</span> ~Proxy() &#123; &#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">size_t</span> frameCount() <span class="keyword">const</span> &#123; <span class="keyword">return</span> mFrameCount; &#125;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="comment">// These refer to shared memory, and are virtual addresses with respect to the </span></div><div class="line">    <span class="comment">// current process. They may have different virtual addresses within the other process.</span></div><div class="line">    <span class="keyword">audio_track_cblk_t</span>* <span class="keyword">const</span>   mCblk;  <span class="comment">// the control block</span></div><div class="line">    <span class="keyword">void</span>* <span class="keyword">const</span>     mBuffers;           <span class="comment">// starting address of buffers</span></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span>    mFrameCount;        <span class="comment">// not necessarily a power of 2</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span>    mFrameSize;         <span class="comment">// in bytes</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span>    mFrameCountP2;      <span class="comment">// mFrameCount rounded to power of 2, streaming mode</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">bool</span>      mIsOut;             <span class="comment">// true for AudioTrack, false for AudioRecord</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">bool</span>      mClientInServer;    <span class="comment">// true for OutputTrack, </span></div><div class="line">                                        <span class="comment">// false for AudioTrack &amp; AudioRecord</span></div><div class="line">    <span class="keyword">bool</span>            mIsShutdown;        <span class="comment">// latch set to true when </span></div><div class="line">                                        <span class="comment">// shared memory corruption detected</span></div><div class="line">    <span class="keyword">size_t</span>          mUnreleased;        <span class="comment">// unreleased frames remaining </span></div><div class="line">                                        <span class="comment">// from most recent obtainBuffer</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>如下是Proxy的类图：<br><img src="https://i.imgur.com/z0xTk2d.png" alt=""></p><ul><li>AudioTrackClientProxy：MODE_STREAM模式下，生产者AudioTrack使用它在共享内存中找到可用空间的位置</li><li><p>AudioTrackServerProxy：MODE_STREAM模式下，消费者AudioFlinger::PlaybackThread使用它在 共享内存中找到可读数据的位置</p></li><li><p>StaticAudioTrackClientProxy：MODE_STATIC模式下，生产者AudioTrack使用它在共享内存中找到可用空间的位置</p></li><li><p>StaticAudioTrackServerProxy：MODE_STATIC模式下，消费者AudioFlinger::PlaybackThread 使用它在共享内存中找到可读数据的位置</p></li><li><p>AudioRecordClientProxy：消费者AudioRecord使用它在共享内存中找到可读数据的位置</p></li><li>AudioTrackServerProxy：生产者AudioFlinger::RecordThread使用它在共享内存中找到可用空间的位置</li></ul><h3 id="AudioTrack数据写入"><a href="#AudioTrack数据写入" class="headerlink" title="AudioTrack数据写入"></a>AudioTrack数据写入</h3><p>在写数据的过程中会用到两个buffer，分别是AudioTrack::Buffer和Proxy::Buffer，它们声明如下。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/av/media/libaudioclient/include/media/AudioTrack.h</span></div><div class="line"><span class="comment">// AudioTrack::Buffer声明</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buffer</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// FIXME use m prefix</span></div><div class="line">    <span class="keyword">size_t</span>      frameCount;   <span class="comment">// number of sample frames corresponding to size;</span></div><div class="line">                              <span class="comment">// on input to obtainBuffer() it is the number of frames desired,</span></div><div class="line">                              <span class="comment">// on output from obtainBuffer() it is the number of available</span></div><div class="line">                              <span class="comment">//    [empty slots for] frames to be filled</span></div><div class="line">                              <span class="comment">// on input to releaseBuffer() it is currently ignored</span></div><div class="line">    <span class="keyword">size_t</span>      size;         <span class="comment">// input/output in bytes == frameCount * frameSize</span></div><div class="line">                              <span class="comment">// on input to obtainBuffer() it is ignored</span></div><div class="line">                              <span class="comment">// on output from obtainBuffer() it is the number of available</span></div><div class="line">                              <span class="comment">//    [empty slots for] bytes to be filled,</span></div><div class="line">                              <span class="comment">//    which is frameCount * frameSize</span></div><div class="line">                              <span class="comment">// on input to releaseBuffer() it is the number of bytes to</span></div><div class="line">                              <span class="comment">//    release</span></div><div class="line">                              <span class="comment">// FIXME This is redundant with respect to frameCount.  Consider</span></div><div class="line">                              <span class="comment">//    removing size and making frameCount the primary field.</span></div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">void</span>*       raw;</div><div class="line">        <span class="keyword">short</span>*      i16;      <span class="comment">// signed 16-bit</span></div><div class="line">        <span class="keyword">int8_t</span>*     i8;       <span class="comment">// unsigned 8-bit, offset by 0x80</span></div><div class="line">    &#125;;                        <span class="comment">// input to obtainBuffer(): unused, output: pointer to buffer</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// frameworks/av/include/private/meida/AudioTrackShared.h</span></div><div class="line"><span class="comment">// Proxy::Buffer声明</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Buffer</span> &#123;</span></div><div class="line">    <span class="keyword">size_t</span>  mFrameCount;            <span class="comment">// number of frames available in this buffer</span></div><div class="line">    <span class="keyword">void</span>*   mRaw;                   <span class="comment">// pointer to first frame</span></div><div class="line">    <span class="keyword">size_t</span>  mNonContig;             <span class="comment">// number of additional non-contiguous frames available</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>当创建好AudioTrack，Client端会执行写数据，则会调用AudioTrack的write函数向硬件写数据，首先会获取可用的共享内存空间，将数据拷贝到这块可用空间，然后更新共享内存写数据的位置。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/av/media/libaudioclient/AudioTrack.cpp</span></div><div class="line"><span class="keyword">ssize_t</span> AudioTrack::write(<span class="keyword">const</span> <span class="keyword">void</span>* buffer, <span class="keyword">size_t</span> userSize, <span class="keyword">bool</span> blocking)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 条件检查</span></div><div class="line">    ......</div><div class="line">    <span class="keyword">size_t</span> written = <span class="number">0</span>;</div><div class="line">    Buffer audioBuffer; <span class="comment">//如上声明</span></div><div class="line">    <span class="keyword">while</span> (userSize &gt;= mFrameSize) &#123;</div><div class="line">        <span class="comment">// 单帧数据量 frameSize = channelCount * bytesPerSample</span></div><div class="line">        <span class="comment">// 对于双声道，16位采样的音频数据来说，frameSize = 2 * 2 = 4(bytes)</span></div><div class="line">        <span class="comment">// 用户传入的数据帧数 frameCount = userSize / frameSize</span></div><div class="line">        audioBuffer.frameCount = userSize / mFrameSize;</div><div class="line">        <span class="comment">// obtainBuffer() 从共享内存上得到一块可用区间</span></div><div class="line">        <span class="keyword">status_t</span> err = obtainBuffer(&amp;audioBuffer,</div><div class="line">                blocking ? &amp;ClientProxy::kForever : &amp;ClientProxy::kNonBlocking);</div><div class="line">        </div><div class="line">        ......</div><div class="line">        <span class="comment">// toWrite 是共享内存上可用区间的大小，可能比userSize（用户传入数据的大小）要小</span></div><div class="line">        <span class="comment">// 因此用户传入的数据可能要拆分多次拷贝到共享内存上</span></div><div class="line">        <span class="comment">// 注意：AudioTrack和AudioFlinger是不同的进程，AudioFlinger同时也在不停地</span></div><div class="line">        <span class="comment">// 消耗数据，所以共享内存可用区间是在不停变化的</span></div><div class="line">        <span class="keyword">size_t</span> toWrite = audioBuffer.size;</div><div class="line">        <span class="built_in">memcpy</span>(audioBuffer.i8, buffer, toWrite);    <span class="comment">// 把用户数据拷贝到共享内存可用区间</span></div><div class="line">        buffer = ((<span class="keyword">const</span> <span class="keyword">char</span> *) buffer) + toWrite; <span class="comment">// 未拷贝数据的位置</span></div><div class="line">        userSize -= toWrite;                        <span class="comment">// 未拷贝数据的大小</span></div><div class="line">        written += toWrite;                         <span class="comment">// 已拷贝数据的大小</span></div><div class="line">        </div><div class="line">        <span class="comment">// releaseBuffer() 更新共享内存写位置</span></div><div class="line">        <span class="comment">// 对于AudioFinger来说，意味共享内存上有更多的可读数据</span></div><div class="line">        releaseBuffer(&amp;audioBuffer);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (written &gt; <span class="number">0</span>) &#123;</div><div class="line">        mFramesWritten += written / mFrameSize;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> written;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在AudioTrack内部会先设置进程睡眠时间，然后调用AudioTrackClientProxy的obtainBuffer函数获取Proxy::Buffer，然后将其转换为AudioTrack::Buffer，然后通过参数返回。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/av/media/libaudioclient/AudioTrack.cpp</span></div><div class="line"><span class="keyword">status_t</span> AudioTrack::obtainBuffer(Buffer* audioBuffer, <span class="keyword">int32_t</span> waitCount, <span class="keyword">size_t</span> *nonContig)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 条件检查</span></div><div class="line">    .....</div><div class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> *<span class="title">requested</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">timeout</span>;</span></div><div class="line">    <span class="comment">// 通过waitCount的值计算是否需要等待，若要等待则等待多久</span></div><div class="line">    .....</div><div class="line">    <span class="keyword">return</span> obtainBuffer(audioBuffer, requested, <span class="literal">NULL</span> <span class="comment">/*elapsed*/</span>, nonContig);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">status_t</span> AudioTrack::obtainBuffer(Buffer* audioBuffer, <span class="keyword">const</span> struct timespec *requested,</div><div class="line">        struct timespec *elapsed, <span class="keyword">size_t</span> *nonContig)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// previous and new IAudioTrack sequence numbers are used to detect track re-creation</span></div><div class="line">    <span class="keyword">uint32_t</span> oldSequence = <span class="number">0</span>;</div><div class="line">    <span class="keyword">uint32_t</span> newSequence;</div><div class="line">    Proxy::Buffer buffer;</div><div class="line">    <span class="keyword">status_t</span> status = NO_ERROR;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int32_t</span> kMaxTries = <span class="number">5</span>; <span class="comment">// 最多5次尝试获取可用空间</span></div><div class="line">    <span class="keyword">int32_t</span> tryCounter = kMaxTries;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="comment">// obtainBuffer() is called with mutex unlocked, so keep extra references </span></div><div class="line">        <span class="comment">// to these fields to keep them from going away </span></div><div class="line">        <span class="comment">// if another thread re-creates the track during obtainBuffer()</span></div><div class="line">        sp&lt;AudioTrackClientProxy&gt; proxy;</div><div class="line">        sp&lt;IMemory&gt; iMem;</div><div class="line"></div><div class="line">        ...... <span class="comment">// 对异常状况，stop状态等情况的处理，并获取AudioTrackClientProxy</span></div><div class="line"></div><div class="line">        <span class="comment">// 调用AudioTrackClientProxy的obtainBuffer函数，由于继承关系，</span></div><div class="line"><span class="comment">// 会调用ClientProxy的obtainBuffer函数</span></div><div class="line">        buffer.mFrameCount = audioBuffer-&gt;frameCount;</div><div class="line">        <span class="comment">// FIXME starts the requested timeout and elapsed over from scratch</span></div><div class="line">        status = proxy-&gt;obtainBuffer(&amp;buffer, requested, elapsed);</div><div class="line">    &#125; <span class="keyword">while</span> (((status == DEAD_OBJECT) || (status == NOT_ENOUGH_DATA)) &amp;&amp; (tryCounter-- &gt; <span class="number">0</span>));</div><div class="line"></div><div class="line">    将Proxy::Buffer转为AudioTrack::Buffer</div><div class="line">    audioBuffer-&gt;frameCount = buffer.mFrameCount;</div><div class="line">    audioBuffer-&gt;size = buffer.mFrameCount * mFrameSize;</div><div class="line">    audioBuffer-&gt;raw = buffer.mRaw;</div><div class="line">    <span class="keyword">if</span> (nonContig != <span class="literal">NULL</span>) &#123;</div><div class="line">        *nonContig = buffer.mNonContig;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> status;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在ClientProxy中，首先设置timeout类型，然后从共享内存读取队头和队尾指针，从而计算已经使用的区域，结合共享内存的大小计算可用空间，最后找到一块合适的空间返回。在其中还会通过系统调用进行进程间的同步控制，看具体情况将进程挂起。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/av/media/libaudioclient/AudioTrackShared.cpp</span></div><div class="line">__attribute__((no_sanitize(<span class="string">"integer"</span>)))</div><div class="line"><span class="keyword">status_t</span> ClientProxy::obtainBuffer(Buffer* buffer, <span class="keyword">const</span> struct timespec *requested,</div><div class="line">        struct timespec *elapsed)</div><div class="line">&#123;</div><div class="line">    LOG_ALWAYS_FATAL_IF(buffer == <span class="literal">NULL</span> || buffer-&gt;mFrameCount == <span class="number">0</span>);</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">total</span>;</span>          <span class="comment">// total elapsed time spent waiting</span></div><div class="line">    total.tv_sec = <span class="number">0</span>;</div><div class="line">    total.tv_nsec = <span class="number">0</span>;</div><div class="line">    <span class="keyword">bool</span> measure = elapsed != <span class="literal">NULL</span>; <span class="comment">// whether to measure total elapsed time spent waiting</span></div><div class="line">    <span class="keyword">status_t</span> status;</div><div class="line">    <span class="keyword">enum</span> &#123;</div><div class="line">        TIMEOUT_ZERO,       <span class="comment">// requested == NULL || *requested == 0</span></div><div class="line">        TIMEOUT_INFINITE,   <span class="comment">// *requested == infinity</span></div><div class="line">        TIMEOUT_FINITE,     <span class="comment">// 0 &lt; *requested &lt; infinity</span></div><div class="line">        TIMEOUT_CONTINUE,   <span class="comment">// additional chances after TIMEOUT_FINITE</span></div><div class="line">    &#125; timeout;</div><div class="line"></div><div class="line">    ...... <span class="comment">// 根据requested设置timeout类型</span></div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">before</span>;</span></div><div class="line">    <span class="keyword">bool</span> beforeIsValid = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">audio_track_cblk_t</span>* cblk = mCblk;</div><div class="line">    <span class="keyword">bool</span> ignoreInitialPendingInterrupt = <span class="literal">true</span>;</div><div class="line">    <span class="comment">// check for shared memory corruption</span></div><div class="line">    <span class="keyword">if</span> (mIsShutdown) &#123;</div><div class="line">        status = NO_INIT;</div><div class="line">        <span class="keyword">goto</span> end;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line"></div><div class="line">        ...... <span class="comment">// 基本条件检查</span></div><div class="line"></div><div class="line">        <span class="keyword">int32_t</span> front;</div><div class="line">        <span class="keyword">int32_t</span> rear;</div><div class="line">        <span class="comment">// 注意使用带内存屏障的函数android_atomic_acquire_load</span></div><div class="line">        <span class="comment">// 获取队头和队尾</span></div><div class="line">        <span class="keyword">if</span> (mIsOut) &#123; <span class="comment">// 对应AudioTrack</span></div><div class="line">            <span class="comment">// The barrier following the read of mFront is probably redundant.</span></div><div class="line">            <span class="comment">// We're about to perform a conditional branch based on 'filled',</span></div><div class="line">            <span class="comment">// which will force the processor to observe the read of mFront</span></div><div class="line">            <span class="comment">// prior to allowing data writes starting at mRaw.</span></div><div class="line">            <span class="comment">// However, the processor may support speculative execution,</span></div><div class="line">            <span class="comment">// and be unable to undo speculative writes into shared memory.</span></div><div class="line">            <span class="comment">// The barrier will prevent such speculative execution.</span></div><div class="line">            front = android_atomic_acquire_load(&amp;cblk-&gt;u.mStreaming.mFront);</div><div class="line">            rear = cblk-&gt;u.mStreaming.mRear;</div><div class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 对应AudioRecord</span></div><div class="line">            <span class="comment">// On the other hand, this barrier is required.</span></div><div class="line">            rear = android_atomic_acquire_load(&amp;cblk-&gt;u.mStreaming.mRear);</div><div class="line">            front = cblk-&gt;u.mStreaming.mFront;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// write to rear, read from front</span></div><div class="line">        <span class="comment">// 已经使用的区域</span></div><div class="line">        <span class="keyword">ssize_t</span> filled = rear - front;</div><div class="line">        <span class="comment">// pipe should not be overfull</span></div><div class="line">        <span class="comment">// 当已经使用的空间大于预先设置的帧数，对于播放来讲出错了，</span></div><div class="line">        <span class="comment">// 而对于录音来说目前处于overrun,写入的速度太快，读取熟读跟不上</span></div><div class="line">        <span class="keyword">if</span> (!(<span class="number">0</span> &lt;= filled &amp;&amp; (<span class="keyword">size_t</span>) filled &lt;= mFrameCount)) &#123;</div><div class="line">            <span class="keyword">if</span> (mIsOut) &#123;</div><div class="line">                ALOGE(<span class="string">"Shared memory control block is corrupt (filled=%zd, mFrameCount=%zu); "</span></div><div class="line">                        <span class="string">"shutting down"</span>, filled, mFrameCount);</div><div class="line">                mIsShutdown = <span class="literal">true</span>;</div><div class="line">                status = NO_INIT;</div><div class="line">                <span class="keyword">goto</span> end;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// for input, sync up on overrun</span></div><div class="line">            filled = <span class="number">0</span>;</div><div class="line">            cblk-&gt;u.mStreaming.mFront = rear;</div><div class="line">            (<span class="keyword">void</span>) android_atomic_or(CBLK_OVERRUN, &amp;cblk-&gt;mFlags);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// Don't allow filling pipe beyond the user settable size.</span></div><div class="line">        <span class="comment">// The calculation for avail can go negative if the buffer size</span></div><div class="line">        <span class="comment">// is suddenly dropped below the amount already in the buffer.</span></div><div class="line">        <span class="comment">// So use a signed calculation to prevent a numeric overflow abort.</span></div><div class="line">        <span class="comment">// 有符号运算可用空间</span></div><div class="line">        <span class="keyword">ssize_t</span> adjustableSize = (<span class="keyword">ssize_t</span>) getBufferSizeInFrames();</div><div class="line">        <span class="keyword">ssize_t</span> avail =  (mIsOut) ? adjustableSize - filled : filled;</div><div class="line">        <span class="keyword">if</span> (avail &lt; <span class="number">0</span>) &#123;</div><div class="line">            avail = <span class="number">0</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (avail &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 'avail' may be non-contiguous, so return only the first contiguous chunk</span></div><div class="line">            <span class="keyword">size_t</span> part1;</div><div class="line">            <span class="keyword">if</span> (mIsOut) &#123;</div><div class="line">                rear &amp;= mFrameCountP2 - <span class="number">1</span>;</div><div class="line">                part1 = mFrameCountP2 - rear;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                front &amp;= mFrameCountP2 - <span class="number">1</span>;</div><div class="line">                part1 = mFrameCountP2 - front;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (part1 &gt; (<span class="keyword">size_t</span>)avail) &#123;</div><div class="line">                part1 = avail;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (part1 &gt; buffer-&gt;mFrameCount) &#123;</div><div class="line">                part1 = buffer-&gt;mFrameCount;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 赋值Proxy::Buffer</span></div><div class="line">            buffer-&gt;mFrameCount = part1;</div><div class="line">            buffer-&gt;mRaw = part1 &gt; <span class="number">0</span> ?</div><div class="line">                    &amp;((<span class="keyword">char</span> *) mBuffers)[(mIsOut ? rear : front) * mFrameSize] : <span class="literal">NULL</span>;</div><div class="line">            buffer-&gt;mNonContig = avail - part1;</div><div class="line">            mUnreleased = part1;</div><div class="line">            status = NO_ERROR;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">remaining</span>;</span></div><div class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> *<span class="title">ts</span>;</span></div><div class="line"></div><div class="line">        ...... <span class="comment">// 根据timeout类型计算剩余等待的时间ts</span></div><div class="line"></div><div class="line">        <span class="keyword">int32_t</span> old = android_atomic_and(~CBLK_FUTEX_WAKE, &amp;cblk-&gt;mFutex);</div><div class="line">        <span class="keyword">if</span> (!(old &amp; CBLK_FUTEX_WAKE)) &#123;</div><div class="line">            <span class="keyword">if</span> (measure &amp;&amp; !beforeIsValid) &#123;</div><div class="line">                clock_gettime(CLOCK_MONOTONIC, &amp;before);</div><div class="line">                beforeIsValid = <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">            errno = <span class="number">0</span>;</div><div class="line">            <span class="comment">// 同步控制，down (P)操作,原子性的给cblk-&gt;mFutex同步变量减1，</span></div><div class="line">            <span class="comment">// FUTEX_WAIT，原子性的检查cblk-&gt;mFutex中计数器的值是否为负值,</span></div><div class="line">            <span class="comment">// 如果是则让进程休眠，直到FUTEX_WAKE或者超时(time-out)。也就是</span></div><div class="line">            <span class="comment">// 把进程挂到cblk-&gt;mFutex相对应的等待队列上去。</span></div><div class="line">            (<span class="keyword">void</span>) syscall(__NR_futex, &amp;cblk-&gt;mFutex,</div><div class="line">                    mClientInServer ? FUTEX_WAIT_PRIVATE : FUTEX_WAIT, </div><div class="line">                    old &amp; ~CBLK_FUTEX_WAKE, ts);</div><div class="line">            <span class="keyword">status_t</span> error = errno; <span class="comment">// clock_gettime can affect errno</span></div><div class="line">            <span class="comment">// update total elapsed time spent waiting</span></div><div class="line">            ......</div><div class="line">            <span class="keyword">switch</span> (error) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="number">0</span>:            <span class="comment">// normal wakeup by server, or by binderDied()</span></div><div class="line">            <span class="keyword">case</span> EWOULDBLOCK:  <span class="comment">// benign race condition with server</span></div><div class="line">            <span class="keyword">case</span> EINTR:        <span class="comment">// wait was interrupted by signal or other spurious wakeup</span></div><div class="line">            <span class="keyword">case</span> ETIMEDOUT:    <span class="comment">// time-out expired</span></div><div class="line">                <span class="comment">// FIXME these error/non-0 status are being dropped</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                status = error;</div><div class="line">                ALOGE(<span class="string">"%s unexpected error %s"</span>, __func__, strerror(status));</div><div class="line">                <span class="keyword">goto</span> end;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">end:</div><div class="line">    ...... <span class="comment">// 善后处理</span></div><div class="line">    <span class="keyword">return</span> status;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Client端拷贝完会更新共享内存的写数据指针，这一步通过ClientProxy的releaseBuffer实现。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/av/media/libaudioclient/AudioTrack.cpp</span></div><div class="line"><span class="keyword">void</span> AudioTrack::releaseBuffer(<span class="keyword">const</span> Buffer* audioBuffer)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// FIXME add error checking on mode, by adding an internal version</span></div><div class="line">    ..... <span class="comment">// 条件检查</span></div><div class="line"></div><div class="line">    <span class="comment">// 数据写入完毕，将数据从AudioTrack::Buffer转入Proxy::Buffer，</span></div><div class="line">    <span class="comment">// 调用AudioTrackClientProxy的releaseBuffer函数释放buffer控制权</span></div><div class="line">    Proxy::Buffer buffer;</div><div class="line">    buffer.mFrameCount = stepCount;</div><div class="line">    buffer.mRaw = audioBuffer-&gt;raw;</div><div class="line">    <span class="function">AutoMutex <span class="title">lock</span><span class="params">(mLock)</span></span>;</div><div class="line">    mReleased += stepCount;</div><div class="line">    mInUnderrun = <span class="literal">false</span>;</div><div class="line">    mProxy-&gt;releaseBuffer(&amp;buffer);</div><div class="line">    <span class="comment">// restart track if it was disabled by audioflinger due to previous underrun</span></div><div class="line">    restartIfDisabled();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// frameworks/av/media/libaudioclient/AudioTrackShared.cpp</span></div><div class="line">__attribute__((no_sanitize(<span class="string">"integer"</span>)))</div><div class="line"><span class="keyword">void</span> ClientProxy::releaseBuffer(Buffer* buffer)</div><div class="line">&#123;</div><div class="line">    LOG_ALWAYS_FATAL_IF(buffer == <span class="literal">NULL</span>);</div><div class="line">    <span class="keyword">size_t</span> stepCount = buffer-&gt;mFrameCount;</div><div class="line">    <span class="keyword">if</span> (stepCount == <span class="number">0</span> || mIsShutdown) &#123;</div><div class="line">        <span class="comment">// prevent accidental re-use of buffer</span></div><div class="line">        buffer-&gt;mFrameCount = <span class="number">0</span>;</div><div class="line">        buffer-&gt;mRaw = <span class="literal">NULL</span>;</div><div class="line">        buffer-&gt;mNonContig = <span class="number">0</span>;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    LOG_ALWAYS_FATAL_IF(!(stepCount &lt;= mUnreleased &amp;&amp; mUnreleased &lt;= mFrameCount));</div><div class="line">    mUnreleased -= stepCount;</div><div class="line">    <span class="keyword">audio_track_cblk_t</span>* cblk = mCblk;</div><div class="line">    <span class="comment">// Both of these barriers are required</span></div><div class="line">    <span class="comment">// 释放buffer控制权，其实是移动队尾（队头），更新写数据位置，注意内存屏障的使用</span></div><div class="line">    <span class="keyword">if</span> (mIsOut) &#123;</div><div class="line">        <span class="keyword">int32_t</span> rear = cblk-&gt;u.mStreaming.mRear;</div><div class="line">        android_atomic_release_store(stepCount + rear, &amp;cblk-&gt;u.mStreaming.mRear);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">int32_t</span> front = cblk-&gt;u.mStreaming.mFront;</div><div class="line">        android_atomic_release_store(stepCount + front, &amp;cblk-&gt;u.mStreaming.mFront);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="AudioFlinger数据读取"><a href="#AudioFlinger数据读取" class="headerlink" title="AudioFlinger数据读取"></a>AudioFlinger数据读取</h3><p>在AudioFlinger端读取数据会使用到AudioBufferProvider::Buffer和Proxy::Buffer。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/av/media/libaudioclient/include/media/AudioBufferProvider.h</span></div><div class="line">AudioBufferProvider::Buffer声明</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Buffer</span> &#123;</span></div><div class="line">    Buffer() : raw(<span class="literal">NULL</span>), frameCount(<span class="number">0</span>) &#123; &#125;</div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">void</span>*       raw;</div><div class="line">        <span class="keyword">short</span>*      i16;</div><div class="line">        <span class="keyword">int8_t</span>*     i8;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">size_t</span> frameCount;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// frameworks/av/include/private/meida/AudioTrackShared.h</span></div><div class="line"><span class="comment">// Proxy::Buffer声明</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Buffer</span> &#123;</span></div><div class="line">    <span class="keyword">size_t</span>  mFrameCount;            <span class="comment">// number of frames available in this buffer</span></div><div class="line">    <span class="keyword">void</span>*   mRaw;                   <span class="comment">// pointer to first frame</span></div><div class="line">    <span class="keyword">size_t</span>  mNonContig;             <span class="comment">// number of additional non-contiguous frames available</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>我们以DirectOutputThread/OffloadThread为例说明（MixerThread读数据也是类似的过程，由于MixerThread会有混音过程，所以读取数据会稍微复杂点，是在AudioMixer中进行的，后续有机会分析混音时在分析其读取数据的过程）。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/av/services/audioflinger/Threads.cpp</span></div><div class="line"><span class="keyword">void</span> AudioFlinger::DirectOutputThread::threadLoop_mix()</div><div class="line">&#123;</div><div class="line">    <span class="comment">// mFrameCount是硬件设备（PCM设备）处理单个数据块的帧数（周期大小）</span></div><div class="line">    <span class="comment">// 上层必须积累了足够多（mFrameCount）的数据，才写入到PCM设备所以</span></div><div class="line">    <span class="comment">// mFrameCount也就是AudioFlinger预期的数据量</span></div><div class="line">    <span class="keyword">size_t</span> frameCount = mFrameCount;</div><div class="line">    <span class="comment">// mSinkBuffer目的缓冲区，threadLoop_write() 会把mSinkBuffer上的数据写到PCM设备</span></div><div class="line">    <span class="keyword">int8_t</span> *curBuf = (<span class="keyword">int8_t</span> *)mSinkBuffer;</div><div class="line">    <span class="comment">// output audio to hardware</span></div><div class="line">    <span class="comment">// FIFO 上可读的数据量可能要比预期的要小，因此可能需要多次读取才能积累足够的数据量</span></div><div class="line">    <span class="comment">// 注意：AudioTrack和AudioFlinger是不同的进程，AudioTrack同时也在不停地生产数据</span></div><div class="line">    <span class="comment">// 所以共享内存可读的数据量是在不停变化的</span></div><div class="line">    <span class="keyword">while</span> (frameCount) &#123;</div><div class="line">        AudioBufferProvider::Buffer buffer;</div><div class="line">        buffer.frameCount = frameCount;</div><div class="line">        <span class="comment">// getNextBuffer() 从共享内存上获取可读数据块</span></div><div class="line">        <span class="keyword">status_t</span> status = mActiveTrack-&gt;getNextBuffer(&amp;buffer);</div><div class="line">        <span class="keyword">if</span> (status != NO_ERROR || buffer.raw == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="comment">// no need to pad with 0 for compressed audio</span></div><div class="line">            <span class="keyword">if</span> (audio_has_proportional_frames(mFormat)) &#123;</div><div class="line">                <span class="built_in">memset</span>(curBuf, <span class="number">0</span>, frameCount * mFrameSize);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// memcpy()把共享内存可读数据拷贝到mSinkBuffer目的缓冲区</span></div><div class="line">        <span class="built_in">memcpy</span>(curBuf, buffer.raw, buffer.frameCount * mFrameSize);</div><div class="line">        frameCount -= buffer.frameCount;</div><div class="line">        curBuf += buffer.frameCount * mFrameSize;</div><div class="line">        <span class="comment">// releaseBuffer()更新共享内存读位置</span></div><div class="line">        <span class="comment">// 对于AudioTrack来说，意味着共享内存上有更多的可用空间</span></div><div class="line">        mActiveTrack-&gt;releaseBuffer(&amp;buffer);</div><div class="line">    &#125;</div><div class="line">    mCurrentWriteLength = curBuf - (<span class="keyword">int8_t</span> *)mSinkBuffer;</div><div class="line">    mSleepTimeUs = <span class="number">0</span>;</div><div class="line">    mStandbyTimeNs = systemTime() + mStandbyDelayNs;</div><div class="line">    mActiveTrack.clear();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>从上面看到会先通过mActiveTrack的getNextBuffer获取可读数据，即Track类的getNextBuffer函数，然后将数据拷贝到目的mSinkBuffer，然后更新读数据指针位置。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/av/services/audioflinger/Tracks.cpp</span></div><div class="line"><span class="comment">// AudioBufferProvider interface</span></div><div class="line"><span class="keyword">status_t</span> AudioFlinger::PlaybackThread::Track::getNextBuffer(</div><div class="line">        AudioBufferProvider::Buffer* buffer)</div><div class="line">&#123;</div><div class="line">    ServerProxy::Buffer buf;</div><div class="line">    <span class="keyword">size_t</span> desiredFrames = buffer-&gt;frameCount;</div><div class="line">    buf.mFrameCount = desiredFrames;</div><div class="line">    <span class="comment">// 调用AudioTrackServerProxy的obtainBuffer函数，由于继承关系，</span></div><div class="line"><span class="comment">// 会调用ServerProxy的obtainBuffer函数 </span></div><div class="line">    <span class="keyword">status_t</span> status = mServerProxy-&gt;obtainBuffer(&amp;buf);</div><div class="line">    <span class="comment">// Proxy::Buffer转化为AudioBufferProvider::Buffer</span></div><div class="line">    buffer-&gt;frameCount = buf.mFrameCount;</div><div class="line">    buffer-&gt;raw = buf.mRaw;</div><div class="line">    <span class="comment">// 是否处于underrun状态</span></div><div class="line">    <span class="keyword">if</span> (buf.mFrameCount == <span class="number">0</span> &amp;&amp; !isStopping() &amp;&amp; !isStopped() &amp;&amp; !isPaused()) &#123;</div><div class="line">        ALOGV(<span class="string">"underrun,  framesReady(%zu) &lt; framesDesired(%zd), state: %d"</span>,</div><div class="line">                buf.mFrameCount, desiredFrames, mState);</div><div class="line">        mAudioTrackServerProxy-&gt;tallyUnderrunFrames(desiredFrames);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        mAudioTrackServerProxy-&gt;tallyUnderrunFrames(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> status;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// AudioBufferProvider interface</span></div><div class="line"><span class="comment">// getNextBuffer() = 0;</span></div><div class="line"><span class="comment">// This implementation of releaseBuffer() is used by Track and RecordTrack</span></div><div class="line"><span class="keyword">void</span> AudioFlinger::ThreadBase::TrackBase::releaseBuffer(AudioBufferProvider::Buffer* buffer)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// AudioBufferProvider::Buffer转化为Proxy::Buffer</span></div><div class="line">    ServerProxy::Buffer buf;</div><div class="line">    buf.mFrameCount = buffer-&gt;frameCount;</div><div class="line">    buf.mRaw = buffer-&gt;raw;</div><div class="line">    buffer-&gt;frameCount = <span class="number">0</span>;</div><div class="line">    buffer-&gt;raw = <span class="literal">NULL</span>;</div><div class="line">    <span class="comment">// 调用AudioTrackServerProxy的releaseBuffer函数，由于继承关系，</span></div><div class="line"><span class="comment">// 会调用ServerProxy的releaseBuffer函数 </span></div><div class="line">    mServerProxy-&gt;releaseBuffer(&amp;buf);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>获取可读数据及更新读数据指针位置最终会通过ServerProxy实现，同样先获取队头指针和队尾指针，然后计算可读数据，将可读数据转给传入的buffer。拷贝完数据，然后更新读数据指针，然后同步通知Client端，唤醒挂起的进程。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/av/media/libaudioclient/AudioTrackShared.cpp</span></div><div class="line">__attribute__((no_sanitize(<span class="string">"integer"</span>)))</div><div class="line"><span class="keyword">status_t</span> ServerProxy::obtainBuffer(Buffer* buffer, <span class="keyword">bool</span> ackFlush)</div><div class="line">&#123;</div><div class="line">    LOG_ALWAYS_FATAL_IF(buffer == <span class="literal">NULL</span> || buffer-&gt;mFrameCount == <span class="number">0</span>,</div><div class="line">            <span class="string">"%s: null or zero frame buffer, buffer:%p"</span>, __func__, buffer);</div><div class="line">    <span class="keyword">if</span> (mIsShutdown) &#123;</div><div class="line">        <span class="keyword">goto</span> no_init;</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">    <span class="keyword">audio_track_cblk_t</span>* cblk = mCblk;</div><div class="line">    <span class="comment">// compute number of frames available to write (AudioTrack) or read (AudioRecord),</span></div><div class="line">    <span class="comment">// or use previous cached value from framesReady(), with added barrier if it omits.</span></div><div class="line">    <span class="keyword">int32_t</span> front;</div><div class="line">    <span class="keyword">int32_t</span> rear;</div><div class="line">    <span class="comment">// See notes on barriers at ClientProxy::obtainBuffer()</span></div><div class="line">    <span class="comment">// 注意使用带内存屏障的函数android_atomic_acquire_load</span></div><div class="line">    <span class="comment">// 获取队头和队尾</span></div><div class="line">    <span class="keyword">if</span> (mIsOut) &#123;</div><div class="line">        flushBufferIfNeeded(); <span class="comment">// might modify mFront</span></div><div class="line">        rear = android_atomic_acquire_load(&amp;cblk-&gt;u.mStreaming.mRear);</div><div class="line">        front = cblk-&gt;u.mStreaming.mFront;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        front = android_atomic_acquire_load(&amp;cblk-&gt;u.mStreaming.mFront);</div><div class="line">        rear = cblk-&gt;u.mStreaming.mRear;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">ssize_t</span> filled = rear - front;</div><div class="line">    <span class="comment">// pipe should not already be overfull</span></div><div class="line">    <span class="keyword">if</span> (!(<span class="number">0</span> &lt;= filled &amp;&amp; (<span class="keyword">size_t</span>) filled &lt;= mFrameCount)) &#123;</div><div class="line">        ALOGE(<span class="string">"Shared memory control block is corrupt (filled=%zd, mFrameCount=%zu); </span></div><div class="line"><span class="string">               shutting down"</span>, filled, mFrameCount);</div><div class="line">        mIsShutdown = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (mIsShutdown) &#123;</div><div class="line">        <span class="keyword">goto</span> no_init;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// don't allow filling pipe beyond the nominal size</span></div><div class="line">    <span class="keyword">size_t</span> availToServer;</div><div class="line">    <span class="keyword">if</span> (mIsOut) &#123;</div><div class="line">        availToServer = filled;</div><div class="line">        mAvailToClient = mFrameCount - filled;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        availToServer = mFrameCount - filled;</div><div class="line">        mAvailToClient = filled;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 'availToServer' may be non-contiguous, so return only the first contiguous chunk</span></div><div class="line">    <span class="keyword">size_t</span> part1;</div><div class="line">    <span class="keyword">if</span> (mIsOut) &#123;</div><div class="line">        front &amp;= mFrameCountP2 - <span class="number">1</span>;</div><div class="line">        part1 = mFrameCountP2 - front;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        rear &amp;= mFrameCountP2 - <span class="number">1</span>;</div><div class="line">        part1 = mFrameCountP2 - rear;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (part1 &gt; availToServer) &#123;</div><div class="line">        part1 = availToServer;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">size_t</span> ask = buffer-&gt;mFrameCount;</div><div class="line">    <span class="keyword">if</span> (part1 &gt; ask) &#123;</div><div class="line">        part1 = ask;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// is assignment redundant in some cases?</span></div><div class="line">    buffer-&gt;mFrameCount = part1;</div><div class="line">    buffer-&gt;mRaw = part1 &gt; <span class="number">0</span> ?</div><div class="line">            &amp;((<span class="keyword">char</span> *) mBuffers)[(mIsOut ? front : rear) * mFrameSize] : <span class="literal">NULL</span>;</div><div class="line">    buffer-&gt;mNonContig = availToServer - part1;</div><div class="line">    <span class="comment">// After flush(), allow releaseBuffer() on a previously obtained buffer;</span></div><div class="line">    <span class="comment">// see "Acknowledge any pending flush()" in audioflinger/Tracks.cpp.</span></div><div class="line">    <span class="keyword">if</span> (!ackFlush) &#123;</div><div class="line">        mUnreleased = part1;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> part1 &gt; <span class="number">0</span> ? NO_ERROR : WOULD_BLOCK;</div><div class="line">    &#125;</div><div class="line">no_init:</div><div class="line">    buffer-&gt;mFrameCount = <span class="number">0</span>;</div><div class="line">    buffer-&gt;mRaw = <span class="literal">NULL</span>;</div><div class="line">    buffer-&gt;mNonContig = <span class="number">0</span>;</div><div class="line">    mUnreleased = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> NO_INIT;</div><div class="line">&#125;</div><div class="line"></div><div class="line">__attribute__((no_sanitize(<span class="string">"integer"</span>)))</div><div class="line"><span class="keyword">void</span> ServerProxy::releaseBuffer(Buffer* buffer)</div><div class="line">&#123;</div><div class="line">    ..... <span class="comment">// 条件检查</span></div><div class="line">    mUnreleased -= stepCount;</div><div class="line">    <span class="keyword">audio_track_cblk_t</span>* cblk = mCblk;</div><div class="line">    <span class="comment">// 释放buffer控制权，其实是移动队头（队尾），更新读数据位置，注意内存屏障的使用</span></div><div class="line">    <span class="keyword">if</span> (mIsOut) &#123;</div><div class="line">        <span class="keyword">int32_t</span> front = cblk-&gt;u.mStreaming.mFront;</div><div class="line">        android_atomic_release_store(stepCount + front, &amp;cblk-&gt;u.mStreaming.mFront);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">int32_t</span> rear = cblk-&gt;u.mStreaming.mRear;</div><div class="line">        android_atomic_release_store(stepCount + rear, &amp;cblk-&gt;u.mStreaming.mRear);</div><div class="line">    &#125;</div><div class="line">    cblk-&gt;mServer += stepCount;</div><div class="line">    mReleased += stepCount;</div><div class="line">    <span class="keyword">size_t</span> half = mFrameCount / <span class="number">2</span>;</div><div class="line">    <span class="keyword">if</span> (half == <span class="number">0</span>) &#123;</div><div class="line">        half = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">size_t</span> minimum = (<span class="keyword">size_t</span>) cblk-&gt;mMinimum;</div><div class="line">    <span class="keyword">if</span> (minimum == <span class="number">0</span>) &#123;</div><div class="line">        minimum = mIsOut ? half : <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (minimum &gt; half) &#123;</div><div class="line">        minimum = half;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// FIXME AudioRecord wakeup needs to be optimized; it currently wakes up client every time</span></div><div class="line">    <span class="keyword">if</span> (!mIsOut || (mAvailToClient + stepCount &gt;= minimum)) &#123;</div><div class="line">        <span class="keyword">int32_t</span> old = android_atomic_or(CBLK_FUTEX_WAKE, &amp;cblk-&gt;mFutex);</div><div class="line">        <span class="keyword">if</span> (!(old &amp; CBLK_FUTEX_WAKE)) &#123;</div><div class="line">            <span class="comment">// 同步控制，up (V)操作,原子性的给cblk-&gt;mFutex同步变量加1，</span></div><div class="line">            <span class="comment">// FUTEX_WAKE，原子性的检查cblk-&gt;mFutex中计数器的值是否为正值,</span></div><div class="line">            <span class="comment">// 如果不是则唤醒一个或者多个等待进程。</span></div><div class="line">            (<span class="keyword">void</span>) syscall(__NR_futex, &amp;cblk-&gt;mFutex,</div><div class="line">                    mClientInServer ? FUTEX_WAKE_PRIVATE : FUTEX_WAKE, <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    buffer-&gt;mFrameCount = <span class="number">0</span>;</div><div class="line">    buffer-&gt;mRaw = <span class="literal">NULL</span>;</div><div class="line">    buffer-&gt;mNonContig = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从前面AudioFlinger启动知道，其运行在audioserver进程，而创建AudioTrack一般在APP端创建，APP一般运行在单独的进程，所以这里说AudioTrack到AudioFlinger数据传输，其实也是两个进程之间数据传输，这篇笔记就记录了AudioT
      
    
    </summary>
    
      <category term="Android Audio" scheme="http://yoursite.com/categories/Android-Audio/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android AudioManager API: getDevicces原理</title>
    <link href="http://yoursite.com/2017/12/16/Android-AudioManager-API-getDevicces%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2017/12/16/Android-AudioManager-API-getDevicces原理/</id>
    <published>2017-12-16T07:24:58.000Z</published>
    <updated>2017-12-19T11:46:10.939Z</updated>
    
    <content type="html"><![CDATA[<p>阅读Android开发者文档，我们看到在AudioManager中判断有线耳机和A2DP的是否存在有两组API，分别是isWiredHeadsetOn()，isBluetoothA2dpOn()和getDevices(int)，而isWiredHeadsetOn()在API 14中废弃，isBluetoothA2dpOn()在API 26中废弃，google建议都使用getDevices(int)，而在使用getDevices(int)过程中遇到bug，所以本文就研究一下getDevices(int)的原理。</p><h2 id="宏观剖析getDevices"><a href="#宏观剖析getDevices" class="headerlink" title="宏观剖析getDevices"></a>宏观剖析getDevices</h2><p>首先我们通过一张图，从进程的角度看看getDevices API的原理。<br><img src="https://i.imgur.com/DfSkS3c.png" alt=""><br>我们可以将getDevices大概分为两种情况讨论，第一次调用：</p><ol><li>Client调用AudioManager的getDevices函数，获取MainLooper，创建Handler。</li><li>获取AudioPolicyService的代理，创建AudioPolicyServiceClient，添加回调AudioPortCallback。</li><li>将AudioPolicyServiceClien注册到AudioPolicyService，更新cache，获取可用设备list返回。</li></ol><p>我们再看第二种情况，在有新设备和手机连接的时候：</p><ol><li>此时会进入AudioPolicyService进程中，调用AudioPolicyManager的setDeviceConnectionStateInt函数。</li><li>然后调用AudioPolicyClient的onAudioPortListUpdate，通过AudioPolicyService启动一文，我们知道，最终会调用AudioPolicyService的onAudioPortListUpdate</li><li>调用所有AudioPolicyServiceClien的AudioPortCallback，获取之前创建的Handler。</li><li>发送设备更新消息。</li><li>添加消息到消息队列。</li><li>Looper取出消息队列中的消息。</li><li>处理设备更新消息。</li><li>后续该Client调用getDevices重新获取设备list，更新cache。</li></ol><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p>首先我们看看第一次调用getDevices的过程，在这个过程中，主要由两个工作，一是注册回调通知，二是获取设备列表；后面再次调用就不需要再次注册了，直接获取设备列表即可。<br><img src="https://i.imgur.com/wCmfSpu.png" alt=""><br>下面是当设备变化时的回调通知过程。<br><img src="https://i.imgur.com/K9B1xp2.png" alt=""></p><h2 id="微观剖析getDevices"><a href="#微观剖析getDevices" class="headerlink" title="微观剖析getDevices"></a>微观剖析getDevices</h2><h3 id="Java层调用"><a href="#Java层调用" class="headerlink" title="Java层调用"></a>Java层调用</h3><p>在AudioManager中会调用从getDevicesStatic，listAudioDevicePorts到updateAudioPortCache，由于主要的处理都在updateAudioPortCache中，所以我们主要看一下该函数，在其中先初始化AudioPortEventHandler，若sAudioPortGeneration是初始值，则更新sAudioPortsCached，并返回其中的值，否则直接返回sAudioPortsCached中的值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> AudioDeviceInfo[] getDevices(<span class="keyword">int</span> flags) &#123;</div><div class="line">    <span class="keyword">return</span> getDevicesStatic(flags);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> AudioDeviceInfo[] getDevicesStatic(<span class="keyword">int</span> flags) &#123;</div><div class="line">    ......</div><div class="line">    <span class="keyword">int</span> status = AudioManager.listAudioDevicePorts(ports);</div><div class="line">    ......</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">listAudioDevicePorts</span><span class="params">(ArrayList&lt;AudioDevicePort&gt; devices)</span> </span>&#123;</div><div class="line">    ......</div><div class="line">    <span class="keyword">int</span> status = updateAudioPortCache(ports, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">    ......</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">resetAudioPortGeneration</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> generation;</div><div class="line">    <span class="keyword">synchronized</span> (sAudioPortGeneration) &#123;</div><div class="line">        generation = sAudioPortGeneration;</div><div class="line">        sAudioPortGeneration = AUDIOPORT_GENERATION_INIT;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> generation;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">updateAudioPortCache</span><span class="params">(ArrayList&lt;AudioPort&gt; ports, ArrayList&lt;AudioPatch&gt; patches,</span></span></div><div class="line"><span class="function"><span class="params">                                ArrayList&lt;AudioPort&gt; previousPorts)</span> </span>&#123;</div><div class="line">    sAudioPortEventHandler.init();</div><div class="line">    <span class="keyword">synchronized</span> (sAudioPortGeneration) &#123;</div><div class="line">        <span class="keyword">if</span> (sAudioPortGeneration == AUDIOPORT_GENERATION_INIT) &#123;</div><div class="line">            ......</div><div class="line"></div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                newPorts.clear();</div><div class="line">                status = AudioSystem.listAudioPorts(newPorts, portGeneration);</div><div class="line">                ......</div><div class="line">            &#125; <span class="keyword">while</span> (patchGeneration[<span class="number">0</span>] != portGeneration[<span class="number">0</span>]);</div><div class="line">            ......</div><div class="line">            sAudioPortGeneration = portGeneration[<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (ports != <span class="keyword">null</span>) &#123;</div><div class="line">            ports.clear();</div><div class="line">            ports.addAll(sAudioPortsCached);</div><div class="line">        &#125;</div><div class="line">        ......</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> SUCCESS;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在updateAudioPortCache会初始化AudioPortEventHandler，下面我们看看具体会做哪些事情。首先会获取当前进程的MainLooper，并以此Looper创建Handler，重写Handler消息处理函数。然后调用native_setup进入JNI层。而handleMessage对设备更新消息的处理是resetAudioPortGeneration，这样就会是的下次调用getDevices会更新sAudioPortsCached，从而得到更新后的设备列表。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AudioPortEventHandler</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (mHandler != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// find the looper for our new event handler</span></div><div class="line">            Looper looper = Looper.getMainLooper();</div><div class="line">            <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</div><div class="line">                mHandler = <span class="keyword">new</span> Handler(looper) &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">                        ......</div><div class="line">                        <span class="keyword">if</span> (msg.what == AUDIOPORT_EVENT_PORT_LIST_UPDATED ||</div><div class="line">                                msg.what == AUDIOPORT_EVENT_PATCH_LIST_UPDATED ||</div><div class="line">                                msg.what == AUDIOPORT_EVENT_SERVICE_DIED) &#123;</div><div class="line">                            AudioManager.resetAudioPortGeneration();</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">if</span> (listeners.isEmpty()) &#123;</div><div class="line">                            <span class="keyword">return</span>;</div><div class="line">                        &#125;</div><div class="line">                        ArrayList&lt;AudioPort&gt; ports = <span class="keyword">new</span> ArrayList&lt;AudioPort&gt;();</div><div class="line">                        ArrayList&lt;AudioPatch&gt; patches = <span class="keyword">new</span> ArrayList&lt;AudioPatch&gt;();</div><div class="line">                        <span class="keyword">if</span> (msg.what != AUDIOPORT_EVENT_SERVICE_DIED) &#123;</div><div class="line">                            <span class="keyword">int</span> status = AudioManager.updateAudioPortCache(ports, patches, <span class="keyword">null</span>);</div><div class="line">                            <span class="keyword">if</span> (status != AudioManager.SUCCESS) &#123;</div><div class="line">                                <span class="keyword">return</span>;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        ......</div><div class="line">                    &#125;</div><div class="line">                &#125;;</div><div class="line">                native_setup(<span class="keyword">new</span> WeakReference&lt;AudioPortEventHandler&gt;(<span class="keyword">this</span>));</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                mHandler = <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">native_setup</span><span class="params">(Object module_this)</span></span>;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postEventFromNative</span><span class="params">(Object module_ref,</span></span></div><div class="line"><span class="function"><span class="params">                                            <span class="keyword">int</span> what, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, Object obj)</span> </span>&#123;</div><div class="line">        AudioPortEventHandler eventHandler =</div><div class="line">                (AudioPortEventHandler)((WeakReference)module_ref).get();</div><div class="line">        <span class="keyword">if</span> (eventHandler == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (eventHandler != <span class="keyword">null</span>) &#123;</div><div class="line">            Handler handler = eventHandler.handler();</div><div class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</div><div class="line">                Message m = handler.obtainMessage(what, arg1, arg2, obj);</div><div class="line">                handler.sendMessage(m);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="JNI层调用"><a href="#JNI层调用" class="headerlink" title="JNI层调用"></a>JNI层调用</h3><p>仔细追代码，发现AudioPortEventHandler的JNI函数定义在android_media_AudioSystem.cpp。且Java实例方法native_setup对应着JNI层android_media_AudioSystem_eventHandlerSetup。同时还会有Java静态方法postEventFromNative和JNI层的gAudioPortEventHandlerMethods.postEventFromNative的对应。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> kEventHandlerClassPathName =</div><div class="line">        <span class="string">"android/media/AudioPortEventHandler"</span>;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod gEventHandlerMethods[] = &#123;</div><div class="line">    &#123;<span class="string">"native_setup"</span>,</div><div class="line">        <span class="string">"(Ljava/lang/Object;)V"</span>,</div><div class="line">        (<span class="keyword">void</span> *)android_media_AudioSystem_eventHandlerSetup&#125;,</div><div class="line">    &#123;<span class="string">"native_finalize"</span>,</div><div class="line">        <span class="string">"()V"</span>,</div><div class="line">        (<span class="keyword">void</span> *)android_media_AudioSystem_eventHandlerFinalize&#125;,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_android_media_AudioSystem</span><span class="params">(JNIEnv *env)</span> </span>&#123;</div><div class="line">   ......</div><div class="line">   jclass eventHandlerClass = FindClassOrDie(env, kEventHandlerClassPathName);</div><div class="line">   gAudioPortEventHandlerMethods.postEventFromNative = GetStaticMethodIDOrDie(</div><div class="line">                                       env, eventHandlerClass, </div><div class="line">                                       <span class="string">"postEventFromNative"</span>,</div><div class="line">                                       <span class="string">"(Ljava/lang/Object;IIILjava/lang/Object;)V"</span>);</div><div class="line">   ......</div><div class="line">   <span class="keyword">return</span> RegisterMethodsOrDie(env, kEventHandlerClassPathName, gEventHandlerMethods,</div><div class="line">                     NELEM(gEventHandlerMethods));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在android_media_AudioSystem_eventHandlerSetup中会创建JNIAudioPortCallback，然后调用AudioSystem的addAudioPortCallback函数进行注册添加。后续有设备的变化，会通过这个回调sendEvent，进而通过gAudioPortEventHandlerMethods.postEventFromNative返回Java层，通过Handler处理消息。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span></div><div class="line">android_media_AudioSystem_eventHandlerSetup(JNIEnv *env, jobject thiz, jobject weak_this)</div><div class="line">&#123;</div><div class="line">    ALOGV(<span class="string">"eventHandlerSetup"</span>);</div><div class="line">    <span class="comment">//JNIAudioPortCallback从AudioPortCallback继承</span></div><div class="line">    sp&lt;JNIAudioPortCallback&gt; callback = <span class="keyword">new</span> JNIAudioPortCallback(env, thiz, weak_this);</div><div class="line">    <span class="keyword">if</span> (AudioSystem::addAudioPortCallback(callback) == NO_ERROR) &#123;</div><div class="line">        setJniCallback(env, thiz, callback);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> JNIAudioPortCallback::sendEvent(<span class="keyword">int</span> event)</div><div class="line">&#123;</div><div class="line">    JNIEnv *env = AndroidRuntime::getJNIEnv();</div><div class="line">    <span class="keyword">if</span> (env == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    env-&gt;CallStaticVoidMethod(mClass, gAudioPortEventHandlerMethods.postEventFromNative, mObject,</div><div class="line">                              event, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line">    <span class="keyword">if</span> (env-&gt;ExceptionCheck()) &#123;</div><div class="line">        ALOGW(<span class="string">"An exception occurred while notifying an event."</span>);</div><div class="line">        env-&gt;ExceptionClear();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">void</span> JNIAudioPortCallback::onAudioPortListUpdate()</div><div class="line">&#123;</div><div class="line">    sendEvent(AUDIOPORT_EVENT_PORT_LIST_UPDATED);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="Native层调用"><a href="#Native层调用" class="headerlink" title="Native层调用"></a>Native层调用</h3><p>AudioSystem的addAudioPortCallback会先获取AudioPolicyService的代理，同时创建AudioPolicyServiceClient，然后将AudioPolicyServiceClient注册到AudioPolicyService，在AudioPolicyService中，以NotificationClien封装AudioPolicyServiceClient，再将其以UID为key保存在mNotificationClients中。然后向AudioPolicyServiceClient中添加回调AudioPortCallback。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> sp&lt;IAudioPolicyService&gt; AudioSystem::get_audio_policy_service()</div><div class="line">&#123;</div><div class="line">    sp&lt;IAudioPolicyService&gt; ap;</div><div class="line">    sp&lt;AudioPolicyServiceClient&gt; apc;</div><div class="line">    &#123;</div><div class="line">        Mutex::Autolock _l(gLockAPS);</div><div class="line">        <span class="keyword">if</span> (gAudioPolicyService == <span class="number">0</span>) &#123;</div><div class="line">            sp&lt;IServiceManager&gt; sm = defaultServiceManager();</div><div class="line">            sp&lt;IBinder&gt; binder;</div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                binder = sm-&gt;getService(String16(<span class="string">"media.audio_policy"</span>));</div><div class="line">                <span class="keyword">if</span> (binder != <span class="number">0</span>)</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                ALOGW(<span class="string">"AudioPolicyService not published, waiting..."</span>);</div><div class="line">                usleep(<span class="number">500000</span>); <span class="comment">// 0.5 s</span></div><div class="line">            &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</div><div class="line">            <span class="keyword">if</span> (gAudioPolicyServiceClient == <span class="literal">NULL</span>) &#123;</div><div class="line">                gAudioPolicyServiceClient = <span class="keyword">new</span> AudioPolicyServiceClient();</div><div class="line">            &#125;</div><div class="line">            binder-&gt;linkToDeath(gAudioPolicyServiceClient);</div><div class="line">            gAudioPolicyService = interface_cast&lt;IAudioPolicyService&gt;(binder);</div><div class="line">            LOG_ALWAYS_FATAL_IF(gAudioPolicyService == <span class="number">0</span>);</div><div class="line">            apc = gAudioPolicyServiceClient;</div><div class="line">            <span class="comment">// Make sure callbacks can be received by gAudioPolicyServiceClient</span></div><div class="line">            ProcessState::self()-&gt;startThreadPool();</div><div class="line">        &#125;</div><div class="line">        ap = gAudioPolicyService;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (apc != <span class="number">0</span>) &#123;</div><div class="line">        ap-&gt;registerClient(apc);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ap;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">status_t</span> AudioSystem::addAudioPortCallback(<span class="keyword">const</span> sp&lt;AudioPortCallback&gt;&amp; callback)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">const</span> sp&lt;IAudioPolicyService&gt;&amp; aps = AudioSystem::get_audio_policy_service();</div><div class="line">    <span class="keyword">if</span> (aps == <span class="number">0</span>) <span class="keyword">return</span> PERMISSION_DENIED;</div><div class="line">    Mutex::Autolock _l(gLockAPS);</div><div class="line">    <span class="keyword">if</span> (gAudioPolicyServiceClient == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> NO_INIT;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> ret = gAudioPolicyServiceClient-&gt;addAudioPortCallback(callback);</div><div class="line">    <span class="keyword">if</span> (ret == <span class="number">1</span>) &#123;</div><div class="line">        aps-&gt;setAudioPortCallbacksEnabled(<span class="literal">true</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (ret &lt; <span class="number">0</span>) ? INVALID_OPERATION : NO_ERROR;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> AudioSystem::AudioPolicyServiceClient::addAudioPortCallback(</div><div class="line">        <span class="keyword">const</span> sp&lt;AudioPortCallback&gt;&amp; callback)</div><div class="line">&#123;</div><div class="line">    Mutex::Autolock _l(mLock);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mAudioPortCallbacks.size(); i++) &#123;</div><div class="line">        <span class="keyword">if</span> (mAudioPortCallbacks[i] == callback) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    mAudioPortCallbacks.add(callback);</div><div class="line">    <span class="keyword">return</span> mAudioPortCallbacks.size();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如下就是AudioPolicyService保存AudioPolicyServiceClient的代码，我们看到会判断key值uid是否存在，若已经存在，则不会重复保存。<strong>我们知道在Android中PID是唯一的，而UID是不唯一的，因为进程之前可以通过sharedUid共享数据。所以从这点看，这里是存在隐患的，假如有两个进程共享UID，且两个进程都会使用getDevices注册回调，这就有可能是的后注册的回调无法得到调用而得不到设备列表更新。</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> AudioPolicyService::registerClient(<span class="keyword">const</span> sp&lt;IAudioPolicyServiceClient&gt;&amp; client)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (client == <span class="number">0</span>) &#123;</div><div class="line">        ALOGW(<span class="string">"%s got NULL client"</span>, __FUNCTION__);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    Mutex::Autolock _l(mNotificationClientsLock);</div><div class="line">    <span class="keyword">uid_t</span> uid = IPCThreadState::self()-&gt;getCallingUid();</div><div class="line">    <span class="keyword">if</span> (mNotificationClients.indexOfKey(uid) &lt; <span class="number">0</span>) &#123;</div><div class="line">        sp&lt;NotificationClient&gt; notificationClient = <span class="keyword">new</span> NotificationClient(<span class="keyword">this</span>,</div><div class="line">                                                                           client,</div><div class="line">                                                                           uid);</div><div class="line">        ALOGV(<span class="string">"registerClient() client %p, uid %d"</span>, client.get(), uid);</div><div class="line">        mNotificationClients.add(uid, notificationClient);</div><div class="line">        sp&lt;IBinder&gt; binder = IInterface::asBinder(client);</div><div class="line">        binder-&gt;linkToDeath(notificationClient);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> AudioPolicyService::setAudioPortCallbacksEnabled(<span class="keyword">bool</span> enabled)</div><div class="line">&#123;</div><div class="line">    Mutex::Autolock _l(mNotificationClientsLock);</div><div class="line">    <span class="keyword">uid_t</span> uid = IPCThreadState::self()-&gt;getCallingUid();</div><div class="line">    <span class="keyword">if</span> (mNotificationClients.indexOfKey(uid) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    mNotificationClients.valueFor(uid)-&gt;setAudioPortCallbacksEnabled(enabled);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如下是当有设备更新的时候，反向调用回调的过程，设备接入或移除，都会经过AudioPolicyManager的setDeviceConnectionStateInt，然后调用AudioPolicyClient的onAudioPortListUpdate，在AudioPolicyService启动过程我们知道，AudioPolicyClient中的调用几乎最终都会进入AudioPolicyService，使用AudioCommandThread异步处理，调用NotificationClients中的onAudioPortListUpdate，再到AudioPolicyServiceClient的onAudioPortListUpdate，再到JNIAudioPortCallback的onAudioPortListUpdate，调用Java静态函数postEventFromNative，通过Handler发消息执行reset，从而通知所有的client连接的设备已经更新。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">status_t</span> AudioPolicyManager::setDeviceConnectionStateInt(<span class="keyword">audio_devices_t</span> device,</div><div class="line">                                                         <span class="keyword">audio_policy_dev_state_t</span> state,</div><div class="line">                                                         <span class="keyword">const</span> <span class="keyword">char</span> *device_address,</div><div class="line">                                                         <span class="keyword">const</span> <span class="keyword">char</span> *device_name)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    <span class="keyword">if</span> (audio_is_output_device(device)) &#123;</div><div class="line">        SortedVector &lt;<span class="keyword">audio_io_handle_t</span>&gt; outputs;</div><div class="line">        <span class="keyword">ssize_t</span> index = mAvailableOutputDevices.indexOf(devDesc);</div><div class="line">        <span class="comment">// save a copy of the opened output descriptors before any output is opened or closed</span></div><div class="line">        <span class="comment">// by checkOutputsForDevice(). This will be needed by checkOutputForAllStrategies()</span></div><div class="line">        mPreviousOutputs = mOutputs;</div><div class="line">        <span class="keyword">switch</span> (state)</div><div class="line">        &#123;</div><div class="line">        <span class="comment">// handle output device connection</span></div><div class="line">        <span class="keyword">case</span> AUDIO_POLICY_DEVICE_STATE_AVAILABLE: &#123;</div><div class="line">            ......</div><div class="line">            index = mAvailableOutputDevices.add(devDesc);</div><div class="line">            ......</div><div class="line">        <span class="keyword">case</span> AUDIO_POLICY_DEVICE_STATE_UNAVAILABLE: &#123;</div><div class="line">            ......</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            ALOGE(<span class="string">"setDeviceConnectionState() invalid state: %x"</span>, state);</div><div class="line">            <span class="keyword">return</span> BAD_VALUE;</div><div class="line">        &#125;</div><div class="line">        ......</div><div class="line">        mpClientInterface-&gt;onAudioPortListUpdate();</div><div class="line">        <span class="keyword">return</span> NO_ERROR;</div><div class="line">    &#125;  <span class="comment">// end if is output device</span></div><div class="line">    <span class="comment">// handle input devices</span></div><div class="line">    <span class="keyword">if</span> (audio_is_input_device(device)) &#123;</div><div class="line">      ......</div><div class="line">    &#125; <span class="comment">// end if is input device</span></div><div class="line">    ALOGW(<span class="string">"setDeviceConnectionState() invalid device: %x"</span>, device);</div><div class="line">    <span class="keyword">return</span> BAD_VALUE;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">void</span> AudioPolicyService::AudioPolicyClient::onAudioPortListUpdate()</div><div class="line">&#123;</div><div class="line">    mAudioPolicyService-&gt;onAudioPortListUpdate();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> AudioPolicyService::onAudioPortListUpdate()</div><div class="line">&#123;</div><div class="line">    mOutputCommandThread-&gt;updateAudioPortListCommand();</div><div class="line">&#125;</div><div class="line"><span class="keyword">void</span> AudioPolicyService::doOnAudioPortListUpdate()</div><div class="line">&#123;</div><div class="line">    Mutex::Autolock _l(mNotificationClientsLock);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mNotificationClients.size(); i++) &#123;</div><div class="line">        mNotificationClients.valueAt(i)-&gt;onAudioPortListUpdate();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">void</span> AudioPolicyService::NotificationClient::onAudioPortListUpdate()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (mAudioPolicyServiceClient != <span class="number">0</span> &amp;&amp; mAudioPortCallbacksEnabled) &#123;</div><div class="line">        mAudioPolicyServiceClient-&gt;onAudioPortListUpdate();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> AudioPolicyService::AudioCommandThread::updateAudioPortListCommand()</div><div class="line">&#123;</div><div class="line">    sp&lt;AudioCommand&gt; command = <span class="keyword">new</span> AudioCommand();</div><div class="line">    command-&gt;mCommand = UPDATE_AUDIOPORT_LIST;</div><div class="line">    ALOGV(<span class="string">"AudioCommandThread() adding update audio port list"</span>);</div><div class="line">    sendCommand(command);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> AudioSystem::AudioPolicyServiceClient::onAudioPortListUpdate()</div><div class="line">&#123;</div><div class="line">    Mutex::Autolock _l(mLock);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mAudioPortCallbacks.size(); i++) &#123;</div><div class="line">        mAudioPortCallbacks[i]-&gt;onAudioPortListUpdate();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;阅读Android开发者文档，我们看到在AudioManager中判断有线耳机和A2DP的是否存在有两组API，分别是isWiredHeadsetOn()，isBluetoothA2dpOn()和getDevices(int)，而isWiredHeadsetOn()在API
      
    
    </summary>
    
      <category term="Android Audio" scheme="http://yoursite.com/categories/Android-Audio/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Audio HAL server启动</title>
    <link href="http://yoursite.com/2017/11/28/Android-Audio-HAL-server%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/11/28/Android-Audio-HAL-server启动过程/</id>
    <published>2017-11-28T02:41:54.000Z</published>
    <updated>2017-12-05T09:55:31.366Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道硬件抽象层（HAL）是连接driver和native的桥梁，数据会从native层到HAL层，最终写入kernel。然而8.0之前的HAL和native处于同一进程，耦合度比较高。所以在Android 8.0，google对HAL做了重构，将HAL放在独立的进程，和native通过binder通信。下面我们就看看Android Audio HAL server的启动。</p><h2 id="Audio-HAL-server启动"><a href="#Audio-HAL-server启动" class="headerlink" title="Audio HAL server启动"></a>Audio HAL server启动</h2><p>同样Android Audio HAL server（audio-hal-2-0）从init进程启动，不过audio-hal-2-0的可执行文件在vendor分区，这也是为了降低耦合度，因为HAL一般由OEM/ODM实现，google不想HAL影响到Framework的更新，所以希望尽量将OEM/ODM的实现放到vendor分区，由这些厂商自己维护。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">service audio-hal-2-0 /vendor/bin/hw/android.hardware.audio@2.0-service</div><div class="line">    class hal                                   <span class="comment"># audio-hal-2-0和class hal行为一致</span></div><div class="line">    user audioserver                            <span class="comment"># 用户归属，uid：AID_AUDIOSERVER</span></div><div class="line">    <span class="comment"># media gid needed for /dev/fm (radio) and for /data/misc/media (tee)</span></div><div class="line">    group audio camera drmrpc inet media mediadrm net_bt \</div><div class="line">                       net_bt_admin net_bw_acct <span class="comment"># 用户组归属</span></div><div class="line">    ioprio rt 4                                 <span class="comment"># io调度优先级</span></div><div class="line">    <span class="comment"># 当子进程被创建的时候，将子进程的pid写入到给定的文件中,cgroup/cpuset用法</span></div><div class="line">    writepid /dev/cpuset/foreground/tasks /dev/stune/foreground/tasks</div><div class="line">    <span class="comment"># audioflinger restarts itself when it loses connection with the hal</span></div><div class="line">    <span class="comment"># and its .rc file has an "onrestart restart audio-hal" rule, thus</span></div><div class="line">    <span class="comment"># an additional auto-restart from the init process isn't needed.</span></div><div class="line">    oneshot                                     <span class="comment"># 当此服务退出时不会自动重启</span></div></pre></td></tr></table></figure></p><p>我们看到audio-hal-2-0的启动代码有IDevicesFactory，IEffectsFactory，ISoundTriggerHw及IBroadcastRadioFactory，这和native的audioserver相对应。且代码有一种熟悉的感觉，和audioserver的启动很相似，只是具体实现有些不一样，这里通过registerPassthroughServiceImplementation将如上四个服务注册到hwservicemanager，以供native调用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> <span class="comment">/* argc */</span>, <span class="keyword">char</span>* <span class="comment">/* argv */</span> [])</span> </span>&#123;</div><div class="line">    configureRpcThreadpool(<span class="number">16</span>, <span class="literal">true</span> <span class="comment">/*callerWillJoin*/</span>);</div><div class="line">    android::<span class="keyword">status_t</span> status;</div><div class="line">    status = registerPassthroughServiceImplementation&lt;IDevicesFactory&gt;();</div><div class="line">    LOG_ALWAYS_FATAL_IF(status != OK, <span class="string">"Error while registering audio service: %d"</span>, status);</div><div class="line">    status = registerPassthroughServiceImplementation&lt;IEffectsFactory&gt;();</div><div class="line">    LOG_ALWAYS_FATAL_IF(status != OK, <span class="string">"Error while registering audio effects </span></div><div class="line"><span class="string">                                                         service: %d"</span>, status);</div><div class="line">    <span class="comment">// Soundtrigger and FM radio might be not present.</span></div><div class="line">    status = registerPassthroughServiceImplementation&lt;ISoundTriggerHw&gt;();</div><div class="line">    ALOGE_IF(status != OK, <span class="string">"Error while registering soundtrigger service: %d"</span>, status);</div><div class="line">    <span class="keyword">if</span> (useBroadcastRadioFutureFeatures) &#123;</div><div class="line">        status = registerPassthroughServiceImplementation&lt;</div><div class="line">            broadcastradio::V1_1::IBroadcastRadioFactory&gt;();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        status = registerPassthroughServiceImplementation&lt;</div><div class="line">            broadcastradio::V1_0::IBroadcastRadioFactory&gt;();</div><div class="line">    &#125;</div><div class="line">    ALOGE_IF(status != OK, <span class="string">"Error while registering fm radio service: %d"</span>, status);</div><div class="line">    joinRpcThreadpool();</div><div class="line">    <span class="keyword">return</span> status;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="IDevicesFactory注册到hwservicemanager"><a href="#IDevicesFactory注册到hwservicemanager" class="headerlink" title="IDevicesFactory注册到hwservicemanager"></a>IDevicesFactory注册到hwservicemanager</h2><p>在如上的启动代码中我们看到，HAL服务端调用registerPassthroughServiceImplementation实现注册，这函数的实现在system/libhidl/transport/include/hidl/LegacySupport.h,这是一个模板方法，这里传入IDevicesFactory接口。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Registers passthrough service implementation.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Interface</span>&gt;</span></div><div class="line"><span class="class">__<span class="title">attribute__</span>((<span class="title">warn_unused_result</span>))</span></div><div class="line"><span class="class"><span class="title">status_t</span> <span class="title">registerPassthroughServiceImplementation</span>(</span></div><div class="line"><span class="class">        <span class="title">std</span>:</span>:<span class="built_in">string</span> name = <span class="string">"default"</span>) &#123;</div><div class="line">    sp&lt;Interface&gt; service = Interface::getService(name, <span class="literal">true</span> <span class="comment">/* getStub */</span>);</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">    <span class="keyword">status_t</span> status = service-&gt;registerAsService(name);</div><div class="line">    </div><div class="line">    ......</div><div class="line"></div><div class="line">    <span class="keyword">return</span> status;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>所以首先会调用IDevicesFactory的getService方法。在IDevicesFactory.h中看到有getService方法的声明，在DevicesFactoryAll.cpp中有此方法的实现，最后会返回BsDevicesFactory实例。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span>* IDevicesFactory::descriptor(<span class="string">"android.hardware.audio@2.0::IDevicesFactory"</span>);</div><div class="line"></div><div class="line">::android::sp&lt;IDevicesFactory&gt; IDevicesFactory::getService(</div><div class="line">                       <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;serviceName, <span class="keyword">const</span> <span class="keyword">bool</span> getStub) &#123;</div><div class="line">    <span class="keyword">using</span> ::android::hardware::defaultServiceManager;</div><div class="line">    <span class="keyword">using</span> ::android::hardware::details::waitForHwService;</div><div class="line">    <span class="keyword">using</span> ::android::hardware::getPassthroughServiceManager;</div><div class="line">    <span class="keyword">using</span> ::android::hardware::Return;</div><div class="line">    <span class="keyword">using</span> ::android::sp;</div><div class="line">    <span class="keyword">using</span> Transport = ::android::hidl::manager::V1_0::IServiceManager::Transport;</div><div class="line"></div><div class="line">    sp&lt;IDevicesFactory&gt; iface = <span class="literal">nullptr</span>;</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (getStub || vintfPassthru || vintfLegacy) &#123;</div><div class="line">        <span class="keyword">const</span> sp&lt;::android::hidl::manager::V1_0::IServiceManager&gt; pm = </div><div class="line">                                             getPassthroughServiceManager();</div><div class="line">        <span class="keyword">if</span> (pm != <span class="literal">nullptr</span>) &#123;</div><div class="line">            Return&lt;sp&lt;::android::hidl::base::V1_0::IBase&gt;&gt; ret = </div><div class="line">                    pm-&gt;get(IDevicesFactory::descriptor, serviceName);</div><div class="line">            <span class="keyword">if</span> (ret.isOk()) &#123;</div><div class="line">                sp&lt;::android::hidl::base::V1_0::IBase&gt; baseInterface = ret;</div><div class="line">                <span class="keyword">if</span> (baseInterface != <span class="literal">nullptr</span>) &#123;</div><div class="line">                    iface = <span class="keyword">new</span> BsDevicesFactory(IDevicesFactory::castFrom(baseInterface));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> iface;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里getStub为true，所以前面一段代码不会执行，直接创建PassthroughServiceManager，PassthroughServiceManager的实现在system/libhidl/transport/ServiceManagement.cpp，然后执行其get方法。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line">Return&lt;sp&lt;IBase&gt;&gt; get(<span class="keyword">const</span> hidl_string&amp; fqName,</div><div class="line">                      <span class="keyword">const</span> hidl_string&amp; name) override &#123;</div><div class="line">    std::string stdFqName(fqName.c_str());</div><div class="line">    <span class="comment">//fqName looks like android.hardware.foo@1.0::IFoo</span></div><div class="line">    <span class="keyword">size_t</span> idx = stdFqName.find(<span class="string">"::"</span>);</div><div class="line">    <span class="keyword">if</span> (idx == <span class="built_in">std</span>::<span class="built_in">string</span>::npos ||</div><div class="line">            idx + <span class="built_in">strlen</span>(<span class="string">"::"</span>) + <span class="number">1</span> &gt;= stdFqName.size()) &#123;</div><div class="line">        LOG(ERROR) &lt;&lt; <span class="string">"Invalid interface name passthrough lookup: "</span> &lt;&lt; fqName;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// packageAndVersion为android.hardware.audio@2.0</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> packageAndVersion = stdFqName.substr(<span class="number">0</span>, idx);</div><div class="line"></div><div class="line">    <span class="comment">// ifaceName为IDevicesFactory</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> ifaceName = stdFqName.substr(idx + <span class="built_in">strlen</span>(<span class="string">"::"</span>));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> prefix = packageAndVersion + <span class="string">"-impl"</span>;</div><div class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> sym = <span class="string">"HIDL_FETCH_"</span> + ifaceName;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">android_namespace_t</span>* sphal_namespace = android_get_exported_namespace(<span class="string">"sphal"</span>);</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dlMode = RTLD_LAZY;</div><div class="line">    <span class="keyword">void</span> *handle = <span class="literal">nullptr</span>;</div><div class="line">    <span class="comment">// <span class="doctag">TODO:</span> lookup in VINTF instead</span></div><div class="line">    <span class="comment">// TODO(b/34135607): Remove HAL_LIBRARY_PATH_SYSTEM</span></div><div class="line">    dlerror(); <span class="comment">// clear</span></div><div class="line">    </div><div class="line">    <span class="comment">// 在/odm/lib(64)/hw/，/vendor/lib(64)/hw/，/system/lib(64)/hw/</span></div><div class="line">    <span class="comment">// 寻找android.hardware.audio@2.0-impl.so并用dlopen打开，执行</span></div><div class="line">    <span class="comment">// HIDL_FETCH_IDevicesFactory函数,创建DevicesFactory实例</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;path : &#123;</div><div class="line">        HAL_LIBRARY_PATH_ODM, HAL_LIBRARY_PATH_VENDOR, HAL_LIBRARY_PATH_SYSTEM</div><div class="line">    &#125;) &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; libs = search(path, prefix, <span class="string">".so"</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;lib : libs) &#123;</div><div class="line">            <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> fullPath = path + lib;</div><div class="line">            <span class="comment">// If sphal namespace is available, try to load from the</span></div><div class="line">            <span class="comment">// namespace first. If it fails, fall back to the original</span></div><div class="line">            <span class="comment">// dlopen, which loads from the current namespace.</span></div><div class="line">            <span class="keyword">if</span> (sphal_namespace != <span class="literal">nullptr</span> &amp;&amp; path != HAL_LIBRARY_PATH_SYSTEM) &#123;</div><div class="line">                <span class="keyword">const</span> android_dlextinfo dlextinfo = &#123;</div><div class="line">                    .flags = ANDROID_DLEXT_USE_NAMESPACE,</div><div class="line">                    <span class="comment">// const_cast is dirty but required because</span></div><div class="line">                    <span class="comment">// library_namespace field is non-const.</span></div><div class="line">                    .library_namespace = <span class="keyword">const_cast</span>&lt;<span class="keyword">android_namespace_t</span>*&gt;(sphal_namespace),</div><div class="line">                &#125;;</div><div class="line">                handle = android_dlopen_ext(fullPath.c_str(), dlMode, &amp;dlextinfo);</div><div class="line">                <span class="keyword">if</span> (handle == <span class="literal">nullptr</span>) &#123;</div><div class="line">                    <span class="keyword">const</span> <span class="keyword">char</span>* error = dlerror();</div><div class="line">                    LOG(WARNING) &lt;&lt; <span class="string">"Failed to dlopen "</span> &lt;&lt; lib &lt;&lt; <span class="string">" from sphal namespace:"</span></div><div class="line">                                 &lt;&lt; (error == <span class="literal">nullptr</span> ? <span class="string">"unknown error"</span> : error);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    LOG(DEBUG) &lt;&lt; lib &lt;&lt; <span class="string">" loaded from sphal namespace."</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (handle == <span class="literal">nullptr</span>) &#123;</div><div class="line">                handle = dlopen(fullPath.c_str(), dlMode);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (handle == <span class="literal">nullptr</span>) &#123;</div><div class="line">                <span class="keyword">const</span> <span class="keyword">char</span>* error = dlerror();</div><div class="line">                LOG(ERROR) &lt;&lt; <span class="string">"Failed to dlopen "</span> &lt;&lt; lib &lt;&lt; <span class="string">": "</span></div><div class="line">                           &lt;&lt; (error == <span class="literal">nullptr</span> ? <span class="string">"unknown error"</span> : error);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            IBase* (*generator)(<span class="keyword">const</span> <span class="keyword">char</span>* name);</div><div class="line">            *(<span class="keyword">void</span> **)(&amp;generator) = dlsym(handle, sym.c_str());</div><div class="line">            <span class="keyword">if</span>(!generator) &#123;</div><div class="line">                <span class="keyword">const</span> <span class="keyword">char</span>* error = dlerror();</div><div class="line">                LOG(ERROR) &lt;&lt; <span class="string">"Passthrough lookup opened "</span> &lt;&lt; lib</div><div class="line">                           &lt;&lt; <span class="string">" but could not find symbol "</span> &lt;&lt; sym &lt;&lt; <span class="string">": "</span></div><div class="line">                           &lt;&lt; (error == <span class="literal">nullptr</span> ? <span class="string">"unknown error"</span> : error);</div><div class="line">                dlclose(handle);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            IBase *interface = (*generator)(name.c_str());</div><div class="line">            <span class="keyword">if</span> (interface == <span class="literal">nullptr</span>) &#123;</div><div class="line">                dlclose(handle);</div><div class="line">                <span class="keyword">continue</span>; <span class="comment">// this module doesn't provide this instance name</span></div><div class="line">            &#125;</div><div class="line">            registerReference(fqName, name);</div><div class="line">            <span class="keyword">return</span> interface;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>根据android.hardware.audio@2.0::IDevicesFactory字串拼接出android.hardware.audio@2.0-impl.so并找到打开，执行HIDL_FETCH_IDevicesFactory函数创建DevicesFactory返回。得到BsDevicesFactory实例后，会执行其registerAsService。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">::android::<span class="keyword">status_t</span> IDevicesFactory::registerAsService(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;serviceName) &#123;</div><div class="line">    ::android::hardware::details::onRegistration(</div><div class="line">                       <span class="string">"android.hardware.audio@2.0"</span>, <span class="string">"IDevicesFactory"</span>, serviceName);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> ::android::sp&lt;::android::hidl::manager::V1_0::IServiceManager&gt; sm</div><div class="line">            = ::android::hardware::defaultServiceManager();</div><div class="line">    <span class="keyword">if</span> (sm == <span class="literal">nullptr</span>) &#123;</div><div class="line">        <span class="keyword">return</span> ::android::INVALID_OPERATION;</div><div class="line">    &#125;</div><div class="line">    ::android::hardware::Return&lt;<span class="keyword">bool</span>&gt; ret = sm-&gt;add(serviceName.c_str(), <span class="keyword">this</span>);</div><div class="line">    <span class="keyword">return</span> ret.isOk() &amp;&amp; ret ? ::android::OK : ::android::UNKNOWN_ERROR;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>获取HwServiceManager将自己注册到hwservicemanager。这里涉及binder通信机制，关于binder通信，是另外一个比较大的topic，在这里一两句说不清楚，所以后续有时间再专门记录。</p><h2 id="加载HAL-so"><a href="#加载HAL-so" class="headerlink" title="加载HAL so"></a>加载HAL so</h2><p>回想在AudioPolicyService启动的时候，会mDevicesFactoryHal-&gt;openDevice(name, &amp;dev),其实最终会调用DevicesFactory的loadAudioInterface，即打开audio.primary.default.so等lib。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> DevicesFactory::loadAudioInterface(<span class="keyword">const</span> <span class="keyword">char</span> *if_name, <span class="keyword">audio_hw_device_t</span> **dev)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">hw_module_t</span> *mod;</div><div class="line">    <span class="keyword">int</span> rc;</div><div class="line">    rc = hw_get_module_by_class(AUDIO_HARDWARE_MODULE_ID, if_name, &amp;mod);</div><div class="line">    <span class="keyword">if</span> (rc) &#123;</div><div class="line">        ALOGE(<span class="string">"%s couldn't load audio hw module %s.%s (%s)"</span>, __func__,</div><div class="line">                AUDIO_HARDWARE_MODULE_ID, if_name, strerror(-rc));</div><div class="line">        <span class="keyword">goto</span> out;</div><div class="line">    &#125;</div><div class="line">    rc = audio_hw_device_open(mod, dev);</div><div class="line">    <span class="keyword">if</span> (rc) &#123;</div><div class="line">        ALOGE(<span class="string">"%s couldn't open audio hw device in %s.%s (%s)"</span>, __func__,</div><div class="line">                AUDIO_HARDWARE_MODULE_ID, if_name, strerror(-rc));</div><div class="line">        <span class="keyword">goto</span> out;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> ((*dev)-&gt;common.version &lt; AUDIO_DEVICE_API_VERSION_MIN) &#123;</div><div class="line">        ALOGE(<span class="string">"%s wrong audio hw device version %04x"</span>, __func__, (*dev)-&gt;common.version);</div><div class="line">        rc = -EINVAL;</div><div class="line">        audio_hw_device_close(*dev);</div><div class="line">        <span class="keyword">goto</span> out;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">out:</div><div class="line">    *dev = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">return</span> rc;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Methods from ::android::hardware::audio::V2_0::IDevicesFactory follow.</span></div><div class="line">Return&lt;<span class="keyword">void</span>&gt; DevicesFactory::openDevice(IDevicesFactory::Device device, </div><div class="line">                                        openDevice_cb _hidl_cb)  &#123;</div><div class="line">    <span class="keyword">audio_hw_device_t</span> *halDevice;</div><div class="line">    <span class="function">Result <span class="title">retval</span><span class="params">(Result::INVALID_ARGUMENTS)</span></span>;</div><div class="line">    sp&lt;IDevice&gt; result;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* moduleName = deviceToString(device);</div><div class="line">    <span class="keyword">if</span> (moduleName != <span class="literal">nullptr</span>) &#123;</div><div class="line">        <span class="keyword">int</span> halStatus = loadAudioInterface(moduleName, &amp;halDevice);</div><div class="line">        <span class="keyword">if</span> (halStatus == OK) &#123;</div><div class="line">            <span class="keyword">if</span> (device == IDevicesFactory::Device::PRIMARY) &#123;</div><div class="line">                result = <span class="keyword">new</span> PrimaryDevice(halDevice);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                result = <span class="keyword">new</span> ::android::hardware::audio::V2_0::implementation::</div><div class="line">                    Device(halDevice);</div><div class="line">            &#125;</div><div class="line">            retval = Result::OK;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (halStatus == -EINVAL) &#123;</div><div class="line">            retval = Result::NOT_INITIALIZED;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    _hidl_cb(retval, result);</div><div class="line">    <span class="keyword">return</span> Void();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们知道硬件抽象层（HAL）是连接driver和native的桥梁，数据会从native层到HAL层，最终写入kernel。然而8.0之前的HAL和native处于同一进程，耦合度比较高。所以在Android 8.0，google对HAL做了重构，将HAL放在独立的进程，和
      
    
    </summary>
    
      <category term="Android Audio HAL" scheme="http://yoursite.com/categories/Android-Audio-HAL/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Audio HIDL C++</title>
    <link href="http://yoursite.com/2017/11/24/Android-Audio-HIDL-C++/"/>
    <id>http://yoursite.com/2017/11/24/Android-Audio-HIDL-C++/</id>
    <published>2017-11-24T01:01:24.000Z</published>
    <updated>2017-12-05T09:20:41.880Z</updated>
    
    <content type="html"><![CDATA[<p>HAL接口定义语言（简称HIDL，发音为“hide-l”）是用于指定HAL和其用户之间的接口的一种接口描述语言 (IDL)。HIDL允许指定类型和方法调用（会汇集到接口和软件包中）。从更广泛的意义上来说，HIDL是用于在可以独立编译的代码库之间进行通信的系统。</p><p>HIDL旨在用于进程间通信 (IPC)。进程之间的通信经过Binder化。对于必须与进程相关联的代码库，还可以使用直通模式（在Java中不受支持）。</p><p>HIDL可指定数据结构和方法签名，这些内容会整理归类到接口（与类相似）中，而接口会汇集到软件包中。尽管HIDL具有一系列不同的关键字，但C++和Java程序员对HIDL的语法并不陌生。此外，HIDL还使用Java样式的注释。</p><h2 id="HAL分类"><a href="#HAL分类" class="headerlink" title="HAL分类"></a>HAL分类</h2><p>为了更好地实现模块化，Android 8.0对Android操作系统底层进行了重新架构。作为此变化的一部分，运行 Android 8.0的设备必须支持绑定式或直通式HAL：</p><ul><li><strong>绑定式HAL</strong>：以HAL接口定义语言 (HIDL) 表示的HAL。这些HAL取代了早期 Android 版本中使用的传统 HAL和旧版HAL。在绑定式HAL中，Android框架和HAL之间通过Binder进程间通信 (IPC) 调用进行通信。所有在推出时即搭载了Android 8.0或后续版本的设备都必须只支持绑定式HAL。</li><li><strong>直通式HAL</strong>：以HIDL封装的传统HAL或旧版HAL。这些HAL封装了现有的HAL，可在绑定模式和 Same-Process（直通）模式下使用。升级到 Android 8.0 的设备可以使用直通式HAL。</li></ul><h2 id="HAL的发展历程"><a href="#HAL的发展历程" class="headerlink" title="HAL的发展历程"></a>HAL的发展历程</h2><p>HIDL接口具有客户端和服务器实现：</p><ul><li>HIDL接口的客户端实现是指通过在该接口上调用方法来使用该接口的代码。</li><li>服务器实现是指HIDL接口的实现，它可接收来自客户端的调用并返回结果（如有必要）。</li></ul><p>在从libhardware HAL转换为HIDL HAL的过程中，HAL实现成为服务器，而调用HAL的进程则成为客户端。默认实现可提供直通和绑定式HAL，并可能会随着时间而发生变化：<br><img src="https://i.imgur.com/j26sMR2.png" alt=""></p><h2 id="Audio-HIDL客户端和服务端"><a href="#Audio-HIDL客户端和服务端" class="headerlink" title="Audio HIDL客户端和服务端"></a>Audio HIDL客户端和服务端</h2><h3 id="客户端创建"><a href="#客户端创建" class="headerlink" title="客户端创建"></a>客户端创建</h3><p>libaudioflinger.so会依赖libaudiohal.so<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LOCAL_SHARED_LIBRARIES += \</div><div class="line">    libaudiohal</div></pre></td></tr></table></figure></p><p>libaudiohal.so依赖android.hardware.audio@2.0.so<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LOCAL_SHARED_LIBRARIES += \</div><div class="line">    android.hardware.audio@2.0</div></pre></td></tr></table></figure></p><p>记得在AudioFlinger的启动过程中，在创建libaudiohal的DevicesFactoryHalHidl时有如下以一段代码，这里就是创建Audio HIDL的客户端。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/hardware/audio/2.0/IDevicesFactory.h&gt;</span></span></div><div class="line"></div><div class="line">DevicesFactoryHalHidl::DevicesFactoryHalHidl() &#123;</div><div class="line">    mDevicesFactory = IDevicesFactory::getService();</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="服务端创建"><a href="#服务端创建" class="headerlink" title="服务端创建"></a>服务端创建</h3><p>生成可执行文件android.hardware.audio@2.0-service代表服务端，同样依赖于android.hardware.audio@2.0<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LOCAL_MODULE := android.hardware.audio@2.0-service</div><div class="line">LOCAL_SHARED_LIBRARIES += \</div><div class="line">    android.hardware.audio@2.0</div></pre></td></tr></table></figure></p><p>为了让HAL在直通模式下发挥作用（对于旧版设备），您必须具有HIDL_FETCH_IModuleName 函数（位于/system/lib(64)?/hw/android.hardware.package@3.0-impl(-$OPTIONAL_IDENTIFIER).so下），其中$OPTIONAL_IDENTIFIER是一个标识直通实现的字符串。比如对于Audio,在android.hardware.audio@2.0-impl.so中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">IDevicesFactory* <span class="title">HIDL_FETCH_IDevicesFactory</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="comment">/* name */</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DevicesFactory();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>接下来，使用功能填写存根并设置守护进程。守护进程代码（支持直通）示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hidl/LegacySupport.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> <span class="comment">/* argc */</span>, <span class="keyword">char</span>* <span class="comment">/* argv */</span> [])</span> </span>&#123;</div><div class="line">    status = registerPassthroughServiceImplementation&lt;IDevicesFactory&gt;();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>registerPassthroughServiceImplementation将对提供的-impl库执行dlopen()操作，并将其作为绑定式服务提供。守护进程代码（对于纯绑定式服务）示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> <span class="comment">/* argc */</span>, <span class="keyword">char</span>* <span class="comment">/* argv */</span> [])</span> </span>&#123;</div><div class="line">    Nfc nfc = <span class="keyword">new</span> Nfc();</div><div class="line">    nfc-&gt;registerAsService();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>此守护进程应该存在于$PACKAGE + “-service”（例如android.hardware.audio@2.0-service）中。HAL的特定类的sepolicy是属性hal_<module>（例如 hal_audio))。您必须将此属性应用到运行特定HAL 的守护进程（如果同一进程提供多个HAL，则可以将多个属性应用到该进程）。</module></p><h2 id="Audio-HIDL接口软件包"><a href="#Audio-HIDL接口软件包" class="headerlink" title="Audio HIDL接口软件包"></a>Audio HIDL接口软件包</h2><p>HIDL接口软件包位于hardware/interfaces或vendor/目录下（少数例外情况除外）。hardware/interfaces顶层会直接映射到android.hardware软件包命名空间；版本是软件包（而不是接口）命名空间下的子目录。</p><p>hidl-gen编译器会将.hal文件编译成一组.h和.cpp文件。这些自动生成的文件可用来编译客户端/服务器实现链接到的共享库。用于编译此共享库的Android.bp文件由hardware/interfaces/update-makefiles.sh 脚本自动生成。每次将新软件包添加到hardware/interfaces或在现有软件包中添加/移除.hal文件时，您都必须重新运行该脚本，以确保生成的共享库是最新的。</p><h3 id="Auido-HIDL接口定义"><a href="#Auido-HIDL接口定义" class="headerlink" title="Auido HIDL接口定义"></a>Auido HIDL接口定义</h3><p>对于Audio，.hal文件位于hardware/interfaces/audio/2.0下，我们看看客户端和服务端同时使用的IDevicesFactory接口，该定义在IDevicesFactory.hal中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">package android.hardware.audio@<span class="number">2.0</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> android.hardware.audio.common@<span class="number">2.0</span>;</div><div class="line"><span class="keyword">import</span> IDevice;</div><div class="line"></div><div class="line">interface IDevicesFactory &#123;</div><div class="line">    <span class="keyword">typedef</span> android.hardware.audio@<span class="number">2.0</span>::Result Result;</div><div class="line"></div><div class="line">    <span class="keyword">enum</span> Device : <span class="keyword">int32_t</span> &#123;</div><div class="line">        PRIMARY,</div><div class="line">        A2DP,</div><div class="line">        USB,</div><div class="line">        R_SUBMIX,</div><div class="line">        STUB</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Opens an audio device. To close the device, it is necessary to release</span></div><div class="line"><span class="comment">     * references to the returned device object.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * @param device device type.</span></div><div class="line"><span class="comment">     * @return retval operation completion status. Returns INVALID_ARGUMENTS</span></div><div class="line"><span class="comment">     *         if there is no corresponding hardware module found,</span></div><div class="line"><span class="comment">     *         NOT_INITIALIZED if an error occured while opening the hardware</span></div><div class="line"><span class="comment">     *         module.</span></div><div class="line"><span class="comment">     * @return result the interface for the created device.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    openDevice(Device device) generates (Result retval, IDevice result);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h3 id="HIDL接口转化为cpp"><a href="#HIDL接口转化为cpp" class="headerlink" title="HIDL接口转化为cpp"></a>HIDL接口转化为cpp</h3><p>如下是编译android.hardware.audio@2.0的Android.bp,由hidl-gen自动产生，不能手动编辑。IDevicesFactory.hal会生成DevicesFactoryAll.cpp，及IDevicesFactory.h，IHwDevicesFactory.h，BnHwDevicesFactory.h，BpHwDevicesFactory.h，BsDevicesFactory.h。<br>生成的.h位于out/soong/.intermediates/hardware/interfaces/audio/2.0/android.hardware.audio@2.0_genc++_headers，<br>生成的.cpp文件位于out/soong/.intermediates/hardware/interfaces/audio/2.0/android.hardware.audio@2.0_genc++。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// This file is autogenerated by hidl-gen. Do not edit manually.</span></div><div class="line">filegroup &#123;</div><div class="line">    name: <span class="string">"android.hardware.audio@2.0_hal"</span>,</div><div class="line">    srcs: [</div><div class="line">        <span class="string">"types.hal"</span>,</div><div class="line">        <span class="string">"IDevice.hal"</span>,</div><div class="line">        <span class="string">"IDevicesFactory.hal"</span>,</div><div class="line">        <span class="string">"IPrimaryDevice.hal"</span>,</div><div class="line">        <span class="string">"IStream.hal"</span>,</div><div class="line">        <span class="string">"IStreamIn.hal"</span>,</div><div class="line">        <span class="string">"IStreamOut.hal"</span>,</div><div class="line">        <span class="string">"IStreamOutCallback.hal"</span>,</div><div class="line">    ],</div><div class="line">&#125;</div><div class="line">genrule &#123;</div><div class="line">    name: <span class="string">"android.hardware.audio@2.0_genc++"</span>,</div><div class="line">    tools: [<span class="string">"hidl-gen"</span>],</div><div class="line">    cmd: <span class="string">"$(location hidl-gen) -o $(genDir) -Lc++-sources </span></div><div class="line"><span class="string">         -randroid.hardware:hardware/interfaces </span></div><div class="line"><span class="string">         -randroid.hidl:system/libhidl/transport </span></div><div class="line"><span class="string">         android.hardware.audio@2.0"</span>,</div><div class="line">    srcs: [</div><div class="line">        <span class="string">":android.hardware.audio@2.0_hal"</span>,</div><div class="line">    ],</div><div class="line">    out: [</div><div class="line">        <span class="string">"android/hardware/audio/2.0/types.cpp"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/DeviceAll.cpp"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/DevicesFactoryAll.cpp"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/PrimaryDeviceAll.cpp"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/StreamAll.cpp"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/StreamInAll.cpp"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/StreamOutAll.cpp"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/StreamOutCallbackAll.cpp"</span>,</div><div class="line">    ],</div><div class="line">&#125;</div><div class="line">genrule &#123;</div><div class="line">    name: <span class="string">"android.hardware.audio@2.0_genc++_headers"</span>,</div><div class="line">    tools: [<span class="string">"hidl-gen"</span>],</div><div class="line">    cmd: <span class="string">"$(location hidl-gen) -o $(genDir) -Lc++-headers </span></div><div class="line"><span class="string">         -randroid.hardware:hardware/interfaces </span></div><div class="line"><span class="string">         -randroid.hidl:system/libhidl/transport </span></div><div class="line"><span class="string">         android.hardware.audio@2.0"</span>,</div><div class="line">    srcs: [</div><div class="line">        <span class="string">":android.hardware.audio@2.0_hal"</span>,</div><div class="line">    ],</div><div class="line">    out: [</div><div class="line">        <span class="string">"android/hardware/audio/2.0/types.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/hwtypes.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/IDevice.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/IHwDevice.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BnHwDevice.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BpHwDevice.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BsDevice.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/IDevicesFactory.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/IHwDevicesFactory.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BnHwDevicesFactory.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BpHwDevicesFactory.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BsDevicesFactory.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/IPrimaryDevice.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/IHwPrimaryDevice.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BnHwPrimaryDevice.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BpHwPrimaryDevice.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BsPrimaryDevice.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/IStream.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/IHwStream.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BnHwStream.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BpHwStream.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BsStream.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/IStreamIn.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/IHwStreamIn.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BnHwStreamIn.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BpHwStreamIn.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BsStreamIn.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/IStreamOut.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/IHwStreamOut.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BnHwStreamOut.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BpHwStreamOut.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BsStreamOut.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/IStreamOutCallback.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/IHwStreamOutCallback.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BnHwStreamOutCallback.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BpHwStreamOutCallback.h"</span>,</div><div class="line">        <span class="string">"android/hardware/audio/2.0/BsStreamOutCallback.h"</span>,</div><div class="line">    ],</div><div class="line">&#125;</div><div class="line">cc_library_shared &#123;</div><div class="line">    name: <span class="string">"android.hardware.audio@2.0"</span>,</div><div class="line">    defaults: [<span class="string">"hidl-module-defaults"</span>],</div><div class="line">    generated_sources: [<span class="string">"android.hardware.audio@2.0_genc++"</span>],</div><div class="line">    generated_headers: [<span class="string">"android.hardware.audio@2.0_genc++_headers"</span>],</div><div class="line">    export_generated_headers: [<span class="string">"android.hardware.audio@2.0_genc++_headers"</span>],</div><div class="line">    vendor_available: <span class="literal">true</span>,</div><div class="line">    shared_libs: [</div><div class="line">        <span class="string">"libhidlbase"</span>,</div><div class="line">        <span class="string">"libhidltransport"</span>,</div><div class="line">        <span class="string">"libhwbinder"</span>,</div><div class="line">        <span class="string">"liblog"</span>,</div><div class="line">        <span class="string">"libutils"</span>,</div><div class="line">        <span class="string">"libcutils"</span>,</div><div class="line">        <span class="string">"android.hardware.audio.common@2.0"</span>,</div><div class="line">    ],</div><div class="line">    export_shared_lib_headers: [</div><div class="line">        <span class="string">"libhidlbase"</span>,</div><div class="line">        <span class="string">"libhidltransport"</span>,</div><div class="line">        <span class="string">"libhwbinder"</span>,</div><div class="line">        <span class="string">"libutils"</span>,</div><div class="line">        <span class="string">"android.hardware.audio.common@2.0"</span>,</div><div class="line">    ],</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://i.imgur.com/C23pi5i.png" alt=""></p><ul><li>IDevicesFactory.h - 描述C++类中的纯IDevicesFactory接口；它包含IDevicesFactory.hal文件中的IDevicesFactory接口中所定义的方法和类型，必要时会转换为C++类型。不包含与用于实现此接口的RPC机制（例如HwBinder）相关的详细信息。类的命名空间包含软件包名称和版本号，例如::android::hardware::audio::V2_0::IDevicesFactory。客户端和服务器都包含此标头：客户端用它来调用方法，服务器用它来实现这些方法。</li><li>IHwDevicesFactory.h - 头文件，其中包含用于对接口中使用的数据类型进行序列化的函数的声明。开发者不得直接包含其标头（它不包含任何类）</li><li>BpHwDevicesFactory.h - 从IDevicesFactory继承的类，可描述接口的HwBinder代理（客户端）实现。开发者不得直接引用此类。</li><li>BnHwDevicesFactory.h - 保存对IDevicesFactory实现的引用的类，可描述接口的HwBinder存根（服务器端）实现。开发者不得直接引用此类。</li><li>DevicesFactoryAll.cpp - 包含HwBinder代理和HwBinder存根的实现的类。当客户端调用接口方法时，代理会自动从客户端封送参数，并将事务发送到绑定内核驱动程序，该内核驱动程序会将事务传送到另一端的存根（该存根随后会调用实际的服务器实现）</li><li>BsDevicesFactory.h - 从IDevicesFactory继承的类，直通模式对IDevicesFactory的服务端实现。开发者不得直接引用此类。</li></ul><p>这些文件的结构类似于由aidl-cpp生成的文件。独立于HIDL使用的RPC机制的唯一一个自动生成的文件是 IDevicesFactory.h，其他所有文件都与HIDL使用的HwBinder RPC机制相关联。因此，客户端和服务器实现不得直接引用除IDevicesFactory之外的任何内容。为了满足这项要求，请只包含IDevicesFactory.h并链接到生成的共享库。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HAL接口定义语言（简称HIDL，发音为“hide-l”）是用于指定HAL和其用户之间的接口的一种接口描述语言 (IDL)。HIDL允许指定类型和方法调用（会汇集到接口和软件包中）。从更广泛的意义上来说，HIDL是用于在可以独立编译的代码库之间进行通信的系统。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="Android Audio HAL" scheme="http://yoursite.com/categories/Android-Audio-HAL/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>AudioPolicyService启动过程</title>
    <link href="http://yoursite.com/2017/11/10/AudioPolicyService%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/11/10/AudioPolicyService启动过程/</id>
    <published>2017-11-10T12:39:29.000Z</published>
    <updated>2017-11-21T12:15:30.239Z</updated>
    
    <content type="html"><![CDATA[<p>AudioPolicyService在Audio系统另一个重要的服务，是音频策略的制定者，负责音频设备切换的策略抉择、音量调节策略等。本文基于Android 8.0的代码，记录了AudioPolicyService启动的过程，介绍了其中几个比较关键的点，希望以后自己看到此文能快速回想起AudioPolicyService的启动过程。其代码位于frameworks/av/services/audiopolicy。</p><h2 id="audiopolicy的代码结构"><a href="#audiopolicy的代码结构" class="headerlink" title="audiopolicy的代码结构"></a>audiopolicy的代码结构</h2><ol><li>service目录是AudioPolicyService、AudioPolicyClient、AudioCommandThread及AudioPolicyEffects的定义及实现。</li><li>managerdefault目录提供AudioPolicyManager的基本实现。</li><li>manager目录中是一个工厂类可以根据需要生产所需的AudioPolicyManager，一般各个厂商都会自己实现自己的AudioPolicyManager。</li><li>engine目录定义了AudioPolicyManagerInterface和AudioPolicyManagerObserver接口，<br>AudioPolicyManagerInterface由Policy Engine实现，AudioPolicyManagerObserver这个观察者由AudioPolicyManager实现，以供Engine访问。</li><li>engineconfigure和enginedefault目录是Policy Engine的两种实现，可以根据需要选择其中一种。</li><li>config目录存放audio policy及音量曲线的config文件。</li><li>common目录下定义公共代码。audio_policy.conf是旧版本的audio policy config文件。</li><li>AudioPolicyInterface.h定义了AudioPolicyInterface和AudioPolicyClientInterface接口，AudioPolicyInterface由AuidoPolicyManager实现，特定平台AuidoPolicyManager通过AudioPolicyClientInterface接口的实现者AudioPolicyClient控制音频的输入输出。<br><img src="https://i.imgur.com/kZpNl4i.png" alt=""><h2 id="AudioPolicyService初始化"><a href="#AudioPolicyService初始化" class="headerlink" title="AudioPolicyService初始化"></a>AudioPolicyService初始化</h2>从Android 8.0的code发现，基本流程还是和之前一样，分别创建了ApmTone、ApmAudio、ApmOutput三个AudioCommandThread线程，分别用于播放tone音、执行audio命令和执行输出命令，创建AudioPolicyClient，创建AudioPolicyManager以及创建AudioPolicyEffects。但已经完全移除了对旧版本的AUDIO_POLICY_HARDWARE_MODULE_ID的支持（不再加载audio_policy.default.so库得到audio_policy_module模块），完全使用新模式。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">AudioPolicyService::AudioPolicyService()</div><div class="line">    : BnAudioPolicyService(), mpAudioPolicyDev(<span class="literal">NULL</span>), mpAudioPolicy(<span class="literal">NULL</span>),</div><div class="line">      mAudioPolicyManager(<span class="literal">NULL</span>), mAudioPolicyClient(<span class="literal">NULL</span>), mPhoneState(AUDIO_MODE_INVALID)</div><div class="line">&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> AudioPolicyService::onFirstRef()</div><div class="line">&#123;</div><div class="line">    &#123;</div><div class="line">        Mutex::Autolock _l(mLock);</div><div class="line"></div><div class="line">        <span class="comment">// start tone playback thread</span></div><div class="line">        mTonePlaybackThread = <span class="keyword">new</span> AudioCommandThread(String8(<span class="string">"ApmTone"</span>), <span class="keyword">this</span>);</div><div class="line">        <span class="comment">// start audio commands thread</span></div><div class="line">        mAudioCommandThread = <span class="keyword">new</span> AudioCommandThread(String8(<span class="string">"ApmAudio"</span>), <span class="keyword">this</span>);</div><div class="line">        <span class="comment">// start output activity command thread</span></div><div class="line">        mOutputCommandThread = <span class="keyword">new</span> AudioCommandThread(String8(<span class="string">"ApmOutput"</span>), <span class="keyword">this</span>);</div><div class="line"></div><div class="line">        mAudioPolicyClient = <span class="keyword">new</span> AudioPolicyClient(<span class="keyword">this</span>);</div><div class="line">        mAudioPolicyManager = createAudioPolicyManager(mAudioPolicyClient);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// load audio processing modules</span></div><div class="line">    sp&lt;AudioPolicyEffects&gt;audioPolicyEffects = <span class="keyword">new</span> AudioPolicyEffects();</div><div class="line">    &#123;</div><div class="line">        Mutex::Autolock _l(mLock);</div><div class="line">        mAudioPolicyEffects = audioPolicyEffects;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>这些类之间的大致关系如下（AudioPolicyClient和AudioCommandThread都为AudioPolicyService的内部类）：<br><img src="https://i.imgur.com/wNiugU3.png" alt=""><br>AudioPolicyService的初始化大致分为3步：<br>1.创建三个AudioCommandThread（mTonePlaybackThread，mAudioCommandThread和mOutputCommandThread）<br>2.初始化AudioPolicyManager<br> 2.1 加载并解析audio_policy_configuration.xml<br> 2.2 加载对应的HW module<br> 2.3 初始化Policy Engine<br> 2.4 打开输入输出<br> 2.5 确保所有可用输入输出设备和默认输出设备真正可用<br>3.初始化AudioPolicyEffects</p><h2 id="AudioCommandThread线程"><a href="#AudioCommandThread线程" class="headerlink" title="AudioCommandThread线程"></a>AudioCommandThread线程</h2><p>AudioCommandThread采用异步方式来执行audio command，当需要执行上表中的命令时，首先将命令投递到AudioCommandThread的mAudioCommands命令向量表中，然后通过mWaitWorkCV.signal()唤醒AudioCommandThread线程，被唤醒的AudioCommandThread线程执行完command后，又通过mWaitWorkCV.waitRelative(mLock, waitTime)睡眠等待命令到来。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> AudioPolicyService::AudioCommandThread::onFirstRef()</div><div class="line">&#123;</div><div class="line">    run(mName.<span class="built_in">string</span>(), ANDROID_PRIORITY_AUDIO);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">status_t</span> AudioPolicyService::AudioCommandThread::volumeCommand(<span class="keyword">audio_stream_type_t</span> stream,</div><div class="line">                              <span class="keyword">float</span> volume, <span class="keyword">audio_io_handle_t</span> output, <span class="keyword">int</span> delayMs)</div><div class="line">&#123;</div><div class="line">    sp&lt;AudioCommand&gt; command = <span class="keyword">new</span> AudioCommand();</div><div class="line">    command-&gt;mCommand = SET_VOLUME;</div><div class="line">    sp&lt;VolumeData&gt; data = <span class="keyword">new</span> VolumeData();</div><div class="line">    data-&gt;mStream = stream;</div><div class="line">    data-&gt;mVolume = volume;</div><div class="line">    data-&gt;mIO = output;</div><div class="line">    command-&gt;mParam = data;</div><div class="line">    command-&gt;mWaitStatus = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">return</span> sendCommand(command, delayMs);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">bool</span> AudioPolicyService::AudioCommandThread::threadLoop()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">nsecs_t</span> waitTime = <span class="number">-1</span>;</div><div class="line"></div><div class="line">    mLock.lock();</div><div class="line">    <span class="keyword">while</span> (!exitPending())</div><div class="line">    &#123;</div><div class="line">        sp&lt;AudioPolicyService&gt; svc;</div><div class="line">        <span class="keyword">while</span> (!mAudioCommands.isEmpty() &amp;&amp; !exitPending()) &#123;</div><div class="line">            <span class="keyword">nsecs_t</span> curTime = systemTime();</div><div class="line">            <span class="comment">// commands are sorted by increasing time stamp: execute them from index 0 and up</span></div><div class="line">            <span class="keyword">if</span> (mAudioCommands[<span class="number">0</span>]-&gt;mTime &lt;= curTime) &#123;</div><div class="line">                sp&lt;AudioCommand&gt; command = mAudioCommands[<span class="number">0</span>];</div><div class="line">                mAudioCommands.removeAt(<span class="number">0</span>);</div><div class="line">                mLastCommand = command;</div><div class="line"></div><div class="line">                <span class="keyword">switch</span> (command-&gt;mCommand) &#123;</div><div class="line"></div><div class="line">                ......</div><div class="line"></div><div class="line">                <span class="keyword">case</span> SET_VOLUME: &#123;</div><div class="line">                    VolumeData *data = (VolumeData *)command-&gt;mParam.get();</div><div class="line">                    ALOGV(<span class="string">"AudioCommandThread() processing set volume stream %d, \</span></div><div class="line"><span class="string">                            volume %f, output %d"</span>, data-&gt;mStream, data-&gt;mVolume, data-&gt;mIO);</div><div class="line">                    command-&gt;mStatus = AudioSystem::setStreamVolume(data-&gt;mStream,</div><div class="line">                                                                    data-&gt;mVolume,</div><div class="line">                                                                    data-&gt;mIO);</div><div class="line">                    &#125;<span class="keyword">break</span>;</div><div class="line"></div><div class="line">                ......</div><div class="line"></div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                .....</div><div class="line"></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                waitTime = mAudioCommands[<span class="number">0</span>]-&gt;mTime - curTime;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ......</div><div class="line"></div><div class="line">        <span class="comment">// At this stage we have either an empty command queue or the first command in the queue</span></div><div class="line">        <span class="comment">// has a finite delay. So unless we are exiting it is safe to wait.</span></div><div class="line">        <span class="keyword">if</span> (!exitPending()) &#123;</div><div class="line">            ALOGV(<span class="string">"AudioCommandThread() going to sleep"</span>);</div><div class="line">            <span class="keyword">if</span> (waitTime == <span class="number">-1</span>) &#123;</div><div class="line">                mWaitWorkCV.wait(mLock);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                mWaitWorkCV.waitRelative(mLock, waitTime);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ......</div><div class="line"></div><div class="line">    mLock.unlock();</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>AudioCommandThread是AudioPolicyService的内部类，AudioCommandThread在内部又定义了AudioCommand及AudioCommandData关系如下。<br><img src="https://i.imgur.com/6IUY98f.png" alt=""></p><h2 id="AudioPolicyManager初始化"><a href="#AudioPolicyManager初始化" class="headerlink" title="AudioPolicyManager初始化"></a>AudioPolicyManager初始化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">AudioPolicyManager::AudioPolicyManager(AudioPolicyClientInterface *clientInterface)</div><div class="line">    :</div><div class="line">    mLimitRingtoneVolume(<span class="literal">false</span>), mLastVoiceVolume(<span class="number">-1.0f</span>),</div><div class="line">    mA2dpSuspended(<span class="literal">false</span>),</div><div class="line">    mAudioPortGeneration(<span class="number">1</span>),</div><div class="line">    mBeaconMuteRefCount(<span class="number">0</span>),</div><div class="line">    mBeaconPlayingRefCount(<span class="number">0</span>),</div><div class="line">    mBeaconMuted(<span class="literal">false</span>),</div><div class="line">    mTtsOutputAvailable(<span class="literal">false</span>),</div><div class="line">    mMasterMono(<span class="literal">false</span>),</div><div class="line">    mMusicEffectOutput(AUDIO_IO_HANDLE_NONE),</div><div class="line">    mHasComputedSoundTriggerSupportsConcurrentCapture(<span class="literal">false</span>)</div><div class="line">&#123;</div><div class="line">    mUidCached = getuid();</div><div class="line">    mpClientInterface = clientInterface;</div><div class="line"></div><div class="line">    ...... </div><div class="line">    <span class="comment">// audio policy config加载</span></div><div class="line"></div><div class="line">    <span class="comment">// 初始化Policy Engine</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mHwModules.size(); i++) &#123;</div><div class="line">        <span class="comment">// 加载所有的HW module</span></div><div class="line">        ......</div><div class="line">        <span class="comment">// 打开音频输入输出</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 确保所有可用输入输出设备真正可用</span></div><div class="line">    ......</div><div class="line"></div><div class="line">    <span class="comment">// 确保默认输出设备真正可用</span></div><div class="line">    ALOGE_IF((mPrimaryOutput == <span class="number">0</span>), <span class="string">"Failed to open primary output"</span>);</div><div class="line">    updateDevicesAndOutputs();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="audio-policy-config加载"><a href="#audio-policy-config加载" class="headerlink" title="audio policy config加载"></a>audio policy config加载</h3><p>进入AudioPolicyManager构造函数，会首先加载audio policy config文件，对于旧版本使用audio_policy.conf，在代码中定义音量曲线，对于新版本使用audio_policy_configuration.xml。对于Android 8.0使用新版本，这个文件一般会位于/odm/etc或/vendor/etc，同时解析音量曲线xml（audio_policy_volumes.xml和default_volume_tables.xml）,比起之前的硬编码音量曲线，灵活性更好。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_XML_AUDIO_POLICY_CONF</span></div><div class="line">    mVolumeCurves = <span class="keyword">new</span> VolumeCurvesCollection();</div><div class="line">    <span class="function">AudioPolicyConfig <span class="title">config</span><span class="params">(mHwModules, mAvailableOutputDevices, mAvailableInputDevices,</span></span></div><div class="line"><span class="function"><span class="params">                             mDefaultOutputDevice, speakerDrcEnabled,</span></span></div><div class="line">                             static_cast&lt;VolumeCurvesCollection *&gt;(mVolumeCurves));</div><div class="line">    <span class="keyword">if</span> (deserializeAudioPolicyXmlConfig(config) != NO_ERROR) &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    mVolumeCurves = <span class="keyword">new</span> StreamDescriptorCollection();</div><div class="line">    <span class="function">AudioPolicyConfig <span class="title">config</span><span class="params">(mHwModules, mAvailableOutputDevices, mAvailableInputDevices,</span></span></div><div class="line"><span class="function"><span class="params">                             mDefaultOutputDevice, speakerDrcEnabled)</span></span>;</div><div class="line">    <span class="keyword">if</span> ((ConfigParsingUtils::loadConfig(AUDIO_POLICY_VENDOR_CONFIG_FILE, config) != NO_ERROR) &amp;&amp;</div><div class="line">            (ConfigParsingUtils::loadConfig(AUDIO_POLICY_CONFIG_FILE, config) != NO_ERROR)) &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">        ALOGE(<span class="string">"could not load audio policy configuration file, setting defaults"</span>);</div><div class="line">        config.setDefault();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// must be done after reading the policy (since conditionned by Speaker Drc Enabling)</span></div><div class="line">    <span class="comment">// xml模式时这里是一个空函数无实现</span></div><div class="line">    mVolumeCurves-&gt;initializeVolumeCurves(speakerDrcEnabled);</div></pre></td></tr></table></figure></p><p>当执行完deserializeAudioPolicyXmlConfig，会得到mHwModules对应各个Audio HAL模块、mAvailableOutputDevices可用的输出设备、mAvailableInputDevices可用的输入设备、mDefaultOutputDevice默认输出设备、mVolumeCurves音量曲线及speakerDrcEnabled。</p><p>audio_policy_configuration.xml同时定义了多个audio接口(HwModules)，每一个audio接口包含若干routes（通路）、devicesPorts（设备）和mixPorts（音频流），而每个mixPorts又包含多个input和output流，每个input和output流又同时支持多种输入输出模式，每种输入输出模式又支持若干种设备。<br>mixPorts：listing all output and input streams exposed by the audio HAL.<br>routes：list of possible connections between input and output devices or between stream and devices.<br>devicePorts：a list of device descriptors for all input and output devices accessible via this module.This contains both permanently attached devices and removable devices.<br><img src="https://i.imgur.com/eEXkdfk.png" alt=""><br>每个stream type会分为四种device category：DEVICE_CATEGORY_HEADSET，DEVICE_CATEGORY_SPEAKER，DEVICE_CATEGORY_EARPIECE及DEVICE_CATEGORY_EXT_MEDIA来定义音量曲线，定义的形式如下，一样是分段定义，在每一段中定义不同的衰减值以控制音量的大小。<br>It contains a list of points of this curve expressing the attenuation in Millibels for a given volume index from 0 to 100.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">volume</span> <span class="attr">stream</span>=<span class="string">"AUDIO_STREAM_VOICE_CALL"</span> <span class="attr">deviceCategory</span>=<span class="string">"DEVICE_CATEGORY_HEADSET"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">point</span>&gt;</span>0,-4200<span class="tag">&lt;/<span class="name">point</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">point</span>&gt;</span>33,-2800<span class="tag">&lt;/<span class="name">point</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">point</span>&gt;</span>66,-1400<span class="tag">&lt;/<span class="name">point</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">point</span>&gt;</span>100,0<span class="tag">&lt;/<span class="name">point</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">volume</span>&gt;</span></div></pre></td></tr></table></figure></p><h3 id="初始化Policy-Engine"><a href="#初始化Policy-Engine" class="headerlink" title="初始化Policy Engine"></a>初始化Policy Engine</h3><p>这里也算一个观察者模式吧，EngineInstance是单例模式，通过EngineInstance创建AudioPolicyManagerInterface，从而创建Policy Engine，然后设置观察者。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Once policy config has been parsed, retrieve an instance of the engine and initialize it.</span></div><div class="line">    audio_policy::EngineInstance *engineInstance = audio_policy::EngineInstance::getInstance();</div><div class="line">    <span class="keyword">if</span> (!engineInstance) &#123;</div><div class="line">        ALOGE(<span class="string">"%s:  Could not get an instance of policy engine"</span>, __FUNCTION__);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Retrieve the Policy Manager Interface</span></div><div class="line">    mEngine = engineInstance-&gt;queryInterface&lt;AudioPolicyManagerInterface&gt;();</div><div class="line">    <span class="keyword">if</span> (mEngine == <span class="literal">NULL</span>) &#123;</div><div class="line">        ALOGE(<span class="string">"%s: Failed to get Policy Engine Interface"</span>, __FUNCTION__);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    mEngine-&gt;setObserver(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">status_t</span> status = mEngine-&gt;initCheck();</div><div class="line">    (<span class="keyword">void</span>) status;</div><div class="line">    ALOG_ASSERT(status == NO_ERROR, <span class="string">"Policy engine not initialized(err=%d)"</span>, status);</div></pre></td></tr></table></figure></p><p>其大致关系如下。<br><img src="https://i.imgur.com/PDHsnQK.png" alt=""></p><h3 id="加载HW-Module"><a href="#加载HW-Module" class="headerlink" title="加载HW Module"></a>加载HW Module</h3><p>根据audio policy config加载的HwModule真正加载HAL层的HW module。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// mAvailableOutputDevices and mAvailableInputDevices now contain all attached devices</span></div><div class="line"><span class="comment">// open all output streams needed to access attached devices</span></div><div class="line"><span class="keyword">audio_devices_t</span> outputDeviceTypes = mAvailableOutputDevices.types();</div><div class="line"><span class="keyword">audio_devices_t</span> inputDeviceTypes = mAvailableInputDevices.types() &amp; ~AUDIO_DEVICE_BIT_IN;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mHwModules.size(); i++) &#123;</div><div class="line">    mHwModules[i]-&gt;mHandle = mpClientInterface-&gt;loadHwModule(mHwModules[i]-&gt;getName());</div><div class="line">    <span class="keyword">if</span> (mHwModules[i]-&gt;mHandle == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>从如上代码看出，会执行mpClientInterface-&gt;loadHwModule，即调用AudioPolicyClient的loadHwModule函数，又会转到AudioFlinger的loadHwModule。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">audio_module_handle_t</span> AudioPolicyService::AudioPolicyClient::loadHwModule(<span class="keyword">const</span> <span class="keyword">char</span> *name)</div><div class="line">&#123;</div><div class="line">    sp&lt;IAudioFlinger&gt; af = AudioSystem::get_audio_flinger();</div><div class="line">    <span class="keyword">if</span> (af == <span class="number">0</span>) &#123;</div><div class="line">        ALOGW(<span class="string">"%s: could not get AudioFlinger"</span>, __func__);</div><div class="line">        <span class="keyword">return</span> AUDIO_MODULE_HANDLE_NONE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> af-&gt;loadHwModule(name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">audio_module_handle_t</span> AudioFlinger::loadHwModule(<span class="keyword">const</span> <span class="keyword">char</span> *name)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (name == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> AUDIO_MODULE_HANDLE_NONE;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!settingsAllowed()) &#123;</div><div class="line">        <span class="keyword">return</span> AUDIO_MODULE_HANDLE_NONE;</div><div class="line">    &#125;</div><div class="line">    Mutex::Autolock _l(mLock);</div><div class="line">    <span class="keyword">return</span> loadHwModule_l(name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// loadHwModule_l() must be called with AudioFlinger::mLock held</span></div><div class="line"><span class="keyword">audio_module_handle_t</span> AudioFlinger::loadHwModule_l(<span class="keyword">const</span> <span class="keyword">char</span> *name)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mAudioHwDevs.size(); i++) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(mAudioHwDevs.valueAt(i)-&gt;moduleName(), name, <span class="built_in">strlen</span>(name)) == <span class="number">0</span>) &#123;</div><div class="line">            ALOGW(<span class="string">"loadHwModule() module %s already loaded"</span>, name);</div><div class="line">            <span class="keyword">return</span> mAudioHwDevs.keyAt(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sp&lt;DeviceHalInterface&gt; dev;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> rc = mDevicesFactoryHal-&gt;openDevice(name, &amp;dev);</div><div class="line">    <span class="keyword">if</span> (rc) &#123;</div><div class="line">        ALOGE(<span class="string">"loadHwModule() error %d loading module %s"</span>, rc, name);</div><div class="line">        <span class="keyword">return</span> AUDIO_MODULE_HANDLE_NONE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">    <span class="comment">// Check and cache this HAL's level of support for master mute and master</span></div><div class="line">    <span class="comment">// volume.  If this is the first HAL opened, and it supports the get</span></div><div class="line">    <span class="comment">// methods, use the initial values provided by the HAL as the current</span></div><div class="line">    <span class="comment">// master mute and volume settings.</span></div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">    <span class="keyword">audio_module_handle_t</span> handle = </div><div class="line">          (<span class="keyword">audio_module_handle_t</span>) nextUniqueId(AUDIO_UNIQUE_ID_USE_MODULE);</div><div class="line">    mAudioHwDevs.add(handle, <span class="keyword">new</span> AudioHwDevice(handle, name, dev, flags));</div><div class="line"></div><div class="line">    ALOGI(<span class="string">"loadHwModule() Loaded %s audio interface, handle %d"</span>, name, handle);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> handle;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>mDevicesFactoryHal-&gt;openDevice(name, &amp;dev),从前面AudioFlinger的启动，我们知道mDevicesFactoryHal是HAL进程的客户端，对于Android 8.0加载HAL so文件已经移到HAL进程中，不再与audioserver处于同一个进程中。在AudioFlinger中使用AudioHwDevice代表HW Module，AudioHwDevice会封装audio_module_handle_t和DeviceHalInterface，并以audio_module_handle_t为key将其保存在AudioFlinger的mAudioHwDevs中，以供后续查询。<br>到这里就加载系统的音频接口就加载完了，我们大致可以得出如下结果。<br><img src="https://i.imgur.com/ou4M7xS.png" alt=""></p><h3 id="打开音频输出"><a href="#打开音频输出" class="headerlink" title="打开音频输出"></a>打开音频输出</h3><p>这里的输出，即mixPorts中outputs，也就是mHwModules中所有OutputProfile（IOProfile），代表了音频输出流。所以会遍历mHwModules中所有OutputProfile，然后SwAudioOutputDescriptor来描述每一个output，最终保存在以audio_io_handle_t为key的mOutputs中，以供后续查询。不过这里会除了AUDIO_OUTPUT_FLAG_DIRECT，AUDIO_OUTPUT_FLAG_DIRECT的output会在使用的时候打开，不会预先open。在打开输出设备后还会标记可用输出设备的可用情况，以备后续确认可用输出设备真正可用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// open all output streams needed to access attached devices</span></div><div class="line"><span class="comment">// except for direct output streams that are only opened when they are actually</span></div><div class="line"><span class="comment">// required by an app.</span></div><div class="line"><span class="comment">// This also validates mAvailableOutputDevices list</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; mHwModules[i]-&gt;mOutputProfiles.size(); j++)</div><div class="line">&#123;</div><div class="line">     <span class="keyword">const</span> sp&lt;IOProfile&gt; outProfile = mHwModules[i]-&gt;mOutputProfiles[j];</div><div class="line">     <span class="keyword">if</span> (!outProfile-&gt;hasSupportedDevices()) &#123;</div><div class="line">         <span class="keyword">continue</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">if</span> ((outProfile-&gt;getFlags() &amp; AUDIO_OUTPUT_FLAG_TTS) != <span class="number">0</span>) &#123;</div><div class="line">         mTtsOutputAvailable = <span class="literal">true</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">if</span> ((outProfile-&gt;getFlags() &amp; AUDIO_OUTPUT_FLAG_DIRECT) != <span class="number">0</span>) &#123;</div><div class="line">         <span class="keyword">continue</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">audio_devices_t</span> profileType = outProfile-&gt;getSupportedDevicesType();</div><div class="line">     <span class="keyword">if</span> ((profileType &amp; mDefaultOutputDevice-&gt;type()) != AUDIO_DEVICE_NONE) &#123;</div><div class="line">         profileType = mDefaultOutputDevice-&gt;type();</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">         <span class="comment">// chose first device present in profile's SupportedDevices also part of</span></div><div class="line">         <span class="comment">// outputDeviceTypes</span></div><div class="line">         profileType = outProfile-&gt;getSupportedDeviceForType(outputDeviceTypes);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">if</span> ((profileType &amp; outputDeviceTypes) == <span class="number">0</span>) &#123;</div><div class="line">         <span class="keyword">continue</span>;</div><div class="line">     &#125;</div><div class="line">     sp&lt;SwAudioOutputDescriptor&gt; outputDesc = </div><div class="line">                       <span class="keyword">new</span> SwAudioOutputDescriptor(outProfile, mpClientInterface);</div><div class="line">     <span class="keyword">const</span> DeviceVector &amp;supportedDevices = outProfile-&gt;getSupportedDevices();</div><div class="line">     <span class="keyword">const</span> DeviceVector &amp;devicesForType = </div><div class="line">                           supportedDevices.getDevicesFromType(profileType);</div><div class="line">     String8 address = devicesForType.size() &gt; <span class="number">0</span> </div><div class="line">                       ? devicesForType.itemAt(<span class="number">0</span>)-&gt;mAddress : String8(<span class="string">""</span>);</div><div class="line">     outputDesc-&gt;mDevice = profileType;</div><div class="line">     <span class="keyword">audio_config_t</span> config = AUDIO_CONFIG_INITIALIZER;</div><div class="line">     config.sample_rate = outputDesc-&gt;mSamplingRate;</div><div class="line">     config.channel_mask = outputDesc-&gt;mChannelMask;</div><div class="line">     config.format = outputDesc-&gt;mFormat;</div><div class="line">     <span class="keyword">audio_io_handle_t</span> output = AUDIO_IO_HANDLE_NONE;</div><div class="line">     <span class="keyword">status_t</span> status = mpClientInterface-&gt;openOutput(outProfile-&gt;getModuleHandle(),</div><div class="line">                                                     &amp;output,</div><div class="line">                                                     &amp;config,</div><div class="line">                                                     &amp;outputDesc-&gt;mDevice,</div><div class="line">                                                     address,</div><div class="line">                                                     &amp;outputDesc-&gt;mLatency,</div><div class="line">                                                     outputDesc-&gt;mFlags);</div><div class="line">     <span class="keyword">if</span> (status != NO_ERROR) &#123;</div><div class="line">         ......</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">         outputDesc-&gt;mSamplingRate = config.sample_rate;</div><div class="line">         outputDesc-&gt;mChannelMask = config.channel_mask;</div><div class="line">         outputDesc-&gt;mFormat = config.format;</div><div class="line">         <span class="keyword">for</span> (<span class="keyword">size_t</span> k = <span class="number">0</span>; k  &lt; supportedDevices.size(); k++) &#123;</div><div class="line">              <span class="keyword">ssize_t</span> index = mAvailableOutputDevices.indexOf(supportedDevices[k]);</div><div class="line">              <span class="comment">// give a valid ID to an attached device once confirmed it is reachable</span></div><div class="line">              <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; !mAvailableOutputDevices[index]-&gt;isAttached()) &#123;</div><div class="line">                  mAvailableOutputDevices[index]-&gt;attach(mHwModules[i]);</div><div class="line">              &#125;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">if</span> (mPrimaryOutput == <span class="number">0</span> &amp;&amp;</div><div class="line">                     outProfile-&gt;getFlags() &amp; AUDIO_OUTPUT_FLAG_PRIMARY) &#123;</div><div class="line">             mPrimaryOutput = outputDesc;</div><div class="line">         &#125;</div><div class="line">         addOutput(output, outputDesc);</div><div class="line">         setOutputDevice(outputDesc,</div><div class="line">                         outputDesc-&gt;mDevice,</div><div class="line">                         <span class="literal">true</span>,</div><div class="line">                         <span class="number">0</span>,</div><div class="line">                         <span class="literal">NULL</span>,</div><div class="line">                         address.<span class="built_in">string</span>());</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们看到会使用到mpClientInterface打开输出，即调用AudioPolicyClient的openOutput，即调用<br>AudioFlinger的openOutput及openOutput_l。首先调用findSuitableHwDev_l查询合适的AudioHwDevice，即通过audio_module_handle_t在之前加载的mAudioHwDevs中去除对应的AudioHwDevice，调用AudioHwDevice的openOutputStream得到AudioStreamOut，然后根据output flag创建相应的Thread，最后以audio_io_handle_t为key将Thread保存在mPlaybackThreads和mMmapThreads。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line">sp&lt;AudioFlinger::ThreadBase&gt; AudioFlinger::openOutput_l(<span class="keyword">audio_module_handle_t</span> <span class="keyword">module</span>,</div><div class="line">                                                            <span class="keyword">audio_io_handle_t</span> *output,</div><div class="line">                                                            <span class="keyword">audio_config_t</span> *config,</div><div class="line">                                                            <span class="keyword">audio_devices_t</span> devices,</div><div class="line">                                                            <span class="keyword">const</span> String8&amp; address,</div><div class="line">                                                            <span class="keyword">audio_output_flags_t</span> flags)</div><div class="line">&#123;</div><div class="line">    AudioHwDevice *outHwDev = findSuitableHwDev_l(<span class="keyword">module</span>, devices);</div><div class="line">    <span class="keyword">if</span> (outHwDev == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (*output == AUDIO_IO_HANDLE_NONE) &#123;</div><div class="line">        *output = nextUniqueId(AUDIO_UNIQUE_ID_USE_OUTPUT);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    mHardwareStatus = AUDIO_HW_OUTPUT_OPEN;</div><div class="line">    <span class="comment">// FOR TESTING ONLY:</span></div><div class="line">    ......</div><div class="line"></div><div class="line">    AudioStreamOut *outputStream = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">status_t</span> status = outHwDev-&gt;openOutputStream(</div><div class="line">            &amp;outputStream,</div><div class="line">            *output,</div><div class="line">            devices,</div><div class="line">            flags,</div><div class="line">            config,</div><div class="line">            address.<span class="built_in">string</span>());</div><div class="line">    mHardwareStatus = AUDIO_HW_IDLE;</div><div class="line">    <span class="keyword">if</span> (status == NO_ERROR) &#123;</div><div class="line">        <span class="keyword">if</span> (flags &amp; AUDIO_OUTPUT_FLAG_MMAP_NOIRQ) &#123;</div><div class="line">            sp&lt;MmapPlaybackThread&gt; thread =</div><div class="line">                    <span class="keyword">new</span> MmapPlaybackThread(<span class="keyword">this</span>, *output, outHwDev, outputStream,</div><div class="line">                                          devices, AUDIO_DEVICE_NONE, mSystemReady);</div><div class="line">            mMmapThreads.add(*output, thread);</div><div class="line">            ALOGV(<span class="string">"openOutput_l() created mmap playback thread: ID %d thread %p"</span>,</div><div class="line">                  *output, thread.get());</div><div class="line">            <span class="keyword">return</span> thread;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            sp&lt;PlaybackThread&gt; thread;</div><div class="line">            <span class="keyword">if</span> (flags &amp; AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD) &#123;</div><div class="line">                thread = <span class="keyword">new</span> OffloadThread(<span class="keyword">this</span>, outputStream, *output, devices, mSystemReady);</div><div class="line">                ALOGV(<span class="string">"openOutput_l() created offload output: ID %d thread %p"</span>,</div><div class="line">                      *output, thread.get());</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((flags &amp; AUDIO_OUTPUT_FLAG_DIRECT)</div><div class="line">                    || !isValidPcmSinkFormat(config-&gt;format)</div><div class="line">                    || !isValidPcmSinkChannelMask(config-&gt;channel_mask)) &#123;</div><div class="line">                thread = <span class="keyword">new</span> DirectOutputThread(<span class="keyword">this</span>, outputStream, </div><div class="line">                                         *output, devices, mSystemReady);</div><div class="line">                ALOGV(<span class="string">"openOutput_l() created direct output: ID %d thread %p"</span>,</div><div class="line">                      *output, thread.get());</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                thread = <span class="keyword">new</span> MixerThread(<span class="keyword">this</span>, outputStream, *output, devices, mSystemReady);</div><div class="line">                ALOGV(<span class="string">"openOutput_l() created mixer output: ID %d thread %p"</span>,</div><div class="line">                      *output, thread.get());</div><div class="line">            &#125;</div><div class="line">            mPlaybackThreads.add(*output, thread);</div><div class="line">            <span class="keyword">return</span> thread;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">status_t</span> AudioFlinger::openOutput(<span class="keyword">audio_module_handle_t</span> <span class="keyword">module</span>,</div><div class="line">                                  <span class="keyword">audio_io_handle_t</span> *output,</div><div class="line">                                  <span class="keyword">audio_config_t</span> *config,</div><div class="line">                                  <span class="keyword">audio_devices_t</span> *devices,</div><div class="line">                                  <span class="keyword">const</span> String8&amp; address,</div><div class="line">                                  <span class="keyword">uint32_t</span> *latencyMs,</div><div class="line">                                  <span class="keyword">audio_output_flags_t</span> flags)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (devices == <span class="literal">NULL</span> || *devices == AUDIO_DEVICE_NONE) &#123;</div><div class="line">        <span class="keyword">return</span> BAD_VALUE;</div><div class="line">    &#125;</div><div class="line">    Mutex::Autolock _l(mLock);</div><div class="line">    sp&lt;ThreadBase&gt; thread = openOutput_l(<span class="keyword">module</span>, output, config, *devices, address, flags);</div><div class="line">    <span class="keyword">if</span> (thread != <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> ((flags &amp; AUDIO_OUTPUT_FLAG_MMAP_NOIRQ) == <span class="number">0</span>) &#123;</div><div class="line">            PlaybackThread *playbackThread = (PlaybackThread *)thread.get();</div><div class="line">            *latencyMs = playbackThread-&gt;latency();</div><div class="line">            <span class="comment">// notify client processes of the new output creation</span></div><div class="line">            playbackThread-&gt;ioConfigChanged(AUDIO_OUTPUT_OPENED);</div><div class="line">            <span class="comment">// the first primary output opened designates the primary hw device</span></div><div class="line">            <span class="keyword">if</span> ((mPrimaryHardwareDev == <span class="literal">NULL</span>) &amp;&amp; (flags &amp; AUDIO_OUTPUT_FLAG_PRIMARY)) &#123;</div><div class="line">                ALOGI(<span class="string">"Using module %d as the primary audio interface"</span>, <span class="keyword">module</span>);</div><div class="line">                mPrimaryHardwareDev = playbackThread-&gt;getOutput()-&gt;audioHwDev;</div><div class="line">                <span class="function">AutoMutex <span class="title">lock</span><span class="params">(mHardwareLock)</span></span>;</div><div class="line">                mHardwareStatus = AUDIO_HW_SET_MODE;</div><div class="line">                mPrimaryHardwareDev-&gt;hwDevice()-&gt;setMode(mMode);</div><div class="line">                mHardwareStatus = AUDIO_HW_IDLE;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            MmapThread *mmapThread = (MmapThread *)thread.get();</div><div class="line">            mmapThread-&gt;ioConfigChanged(AUDIO_OUTPUT_OPENED);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> NO_ERROR;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> NO_INIT;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们可以看到在AudioPolicyManager中有mOutputs以audio_io_handle_t为key保存SwAudioOutputDescriptor，而在AudioFlinger中mPlaybackThreads和mMmapThreads以audio_io_handle_t保存线程，所以我们可以得出如下关系图。<br><img src="https://i.imgur.com/K5J8Y6B.png" alt=""></p><h3 id="打开音频输入"><a href="#打开音频输入" class="headerlink" title="打开音频输入"></a>打开音频输入</h3><p>打开音频输入和打开音频输出很类似，只是将SwAudioOutputDescriptor、PlaybackThread及AudioStreamOut换成了AudioInputDescriptor、RecordThread及AudioStreamIn，这里就一笔带过。</p><h3 id="确保可用输入输出和默认输出真正可用"><a href="#确保可用输入输出和默认输出真正可用" class="headerlink" title="确保可用输入输出和默认输出真正可用"></a>确保可用输入输出和默认输出真正可用</h3><p>无其他。主要是移除不可达设备。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// make sure all attached devices have been allocated a unique ID</span></div><div class="line"><span class="comment">// 确保所有可用输出设备真正可用</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i  &lt; mAvailableOutputDevices.size();) &#123;</div><div class="line">    <span class="keyword">if</span> (!mAvailableOutputDevices[i]-&gt;isAttached()) &#123;</div><div class="line">        ALOGW(<span class="string">"Output device %08x unreachable"</span>, mAvailableOutputDevices[i]-&gt;type());</div><div class="line">        mAvailableOutputDevices.remove(mAvailableOutputDevices[i]);</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// The device is now validated and can be appended to the available </span></div><div class="line">    <span class="comment">// devices of the engine</span></div><div class="line">    <span class="comment">// 目前不做任何处理</span></div><div class="line">    mEngine-&gt;setDeviceConnectionState(mAvailableOutputDevices[i],</div><div class="line">                                      AUDIO_POLICY_DEVICE_STATE_AVAILABLE);</div><div class="line">    i++;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 确保所有可用输入设备真正可用</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i  &lt; mAvailableInputDevices.size();) &#123;</div><div class="line">    <span class="keyword">if</span> (!mAvailableInputDevices[i]-&gt;isAttached()) &#123;</div><div class="line">        ALOGW(<span class="string">"Input device %08x unreachable"</span>, mAvailableInputDevices[i]-&gt;type());</div><div class="line">        mAvailableInputDevices.remove(mAvailableInputDevices[i]);</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// The device is now validated and can be appended to the available devices of the engine</span></div><div class="line">    <span class="comment">// 目前不做任何处理</span></div><div class="line">    mEngine-&gt;setDeviceConnectionState(mAvailableInputDevices[i],</div><div class="line">                                      AUDIO_POLICY_DEVICE_STATE_AVAILABLE);</div><div class="line">    i++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// make sure default device is reachable</span></div><div class="line"><span class="comment">// 确保默认输出设备真正可用</span></div><div class="line"><span class="keyword">if</span> (mDefaultOutputDevice == <span class="number">0</span> || </div><div class="line">    mAvailableOutputDevices.indexOf(mDefaultOutputDevice) &lt; <span class="number">0</span>) &#123;</div><div class="line">    ALOGE(<span class="string">"Default device %08x is unreachable"</span>, mDefaultOutputDevice-&gt;type());</div><div class="line">&#125;</div><div class="line"></div><div class="line">ALOGE_IF((mPrimaryOutput == <span class="number">0</span>), <span class="string">"Failed to open primary output"</span>);</div><div class="line">updateDevicesAndOutputs();</div></pre></td></tr></table></figure></p><h2 id="AudioPolicyEffects初始化"><a href="#AudioPolicyEffects初始化" class="headerlink" title="AudioPolicyEffects初始化"></a>AudioPolicyEffects初始化</h2><p>对于音效策略，类似会先加载audio_effects.conf，这个文件可能位于system/etc/或者vendor/etc/。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">AudioPolicyEffects::AudioPolicyEffects()</div><div class="line">&#123;</div><div class="line">    <span class="comment">// load automatic audio effect modules</span></div><div class="line">    <span class="keyword">if</span> (access(AUDIO_EFFECT_VENDOR_CONFIG_FILE, R_OK) == <span class="number">0</span>) &#123;</div><div class="line">        loadAudioEffectConfig(AUDIO_EFFECT_VENDOR_CONFIG_FILE);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (access(AUDIO_EFFECT_DEFAULT_CONFIG_FILE, R_OK) == <span class="number">0</span>) &#123;</div><div class="line">        loadAudioEffectConfig(AUDIO_EFFECT_DEFAULT_CONFIG_FILE);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这个文件的格式如下。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"># List of effect libraries to load. Each library element must contain a <span class="string">"path"</span> element</div><div class="line"><span class="meta"># giving the full path of the library .so file.</span></div><div class="line"><span class="meta">#    libraries &#123;</span></div><div class="line">#        &lt;lib name&gt; &#123;</div><div class="line"><span class="meta">#          path <span class="meta-string">&lt;lib path&gt;</span></span></div><div class="line">#        &#125;</div><div class="line">#    &#125;</div><div class="line"><span class="meta"># list of effects to load. Each effect element must contain a <span class="meta-string">"library"</span> and a <span class="meta-string">"uuid"</span> element.</span></div><div class="line"># The value of the <span class="string">"library"</span> element must correspond to the name of one library element in the</div><div class="line"># <span class="string">"libraries"</span> element.</div><div class="line"># The name of the effect element is indicative, only the value of the <span class="string">"uuid"</span> element</div><div class="line"><span class="meta"># designates the effect.</span></div><div class="line"># The uuid is the implementation specific UUID as specified by the effect vendor. This is <span class="keyword">not</span> the</div><div class="line"><span class="meta"># generic effect type UUID.</span></div><div class="line"><span class="meta">#    effects &#123;</span></div><div class="line">#        &lt;fx name&gt; &#123;</div><div class="line"><span class="meta">#            library <span class="meta-string">&lt;lib name&gt;</span></span></div><div class="line"><span class="meta">#            uuid <span class="meta-string">&lt;effect uuid&gt;</span></span></div><div class="line">#        &#125;</div><div class="line">#        ...</div><div class="line">#    &#125;</div></pre></td></tr></table></figure></p><p>到这里AudioPolicyService的启动流程已经完结，且篇幅已经挺长，其他的知识点，学习到时再补上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AudioPolicyService在Audio系统另一个重要的服务，是音频策略的制定者，负责音频设备切换的策略抉择、音量调节策略等。本文基于Android 8.0的代码，记录了AudioPolicyService启动的过程，介绍了其中几个比较关键的点，希望以后自己看到此文
      
    
    </summary>
    
      <category term="Android Audio" scheme="http://yoursite.com/categories/Android-Audio/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>AudioFlinger启动过程</title>
    <link href="http://yoursite.com/2017/11/09/AudioFlinger%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/11/09/AudioFlinger启动过程/</id>
    <published>2017-11-09T07:58:02.000Z</published>
    <updated>2017-11-21T12:16:09.589Z</updated>
    
    <content type="html"><![CDATA[<p>AudioFlinger以media.audio_flinger为名注册到ServiceManager，是Android Audio系统的一个核心服务，是音频策略的执行者，负责输入输出流设备的管理及音频流数据的处理传输。本文以Android 8.0的代码为基础，记录了其启动过程以及AudioFlinger主要类的关系。其代码位于frameworks/av/services/audioflinger。</p><h2 id="AudioFlinger的启动过程"><a href="#AudioFlinger的启动过程" class="headerlink" title="AudioFlinger的启动过程"></a>AudioFlinger的启动过程</h2><p>Android 8.0中与7.0相比，在初始化过程中，主要是实例化了mDevicesFactoryHal和mEffectsFactoryHal，作为HAL进程的客户端与HAL进程交互。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">AudioFlinger::AudioFlinger()</div><div class="line">    <span class="comment">//变量初始化</span></div><div class="line">    : BnAudioFlinger(),</div><div class="line">      mMediaLogNotifier(<span class="keyword">new</span> AudioFlinger::MediaLogNotifier()),</div><div class="line">      mPrimaryHardwareDev(<span class="literal">NULL</span>),</div><div class="line">      mAudioHwDevs(<span class="literal">NULL</span>),</div><div class="line">      mHardwareStatus(AUDIO_HW_IDLE),</div><div class="line">      mMasterVolume(<span class="number">1.0f</span>),</div><div class="line">      mMasterMute(<span class="literal">false</span>),</div><div class="line">      <span class="comment">// mNextUniqueId(AUDIO_UNIQUE_ID_USE_MAX),</span></div><div class="line">      mMode(AUDIO_MODE_INVALID),</div><div class="line">      mBtNrecIsOff(<span class="literal">false</span>),</div><div class="line">      mIsLowRamDevice(<span class="literal">true</span>),</div><div class="line">      mIsDeviceTypeKnown(<span class="literal">false</span>),</div><div class="line">      mGlobalEffectEnableTime(<span class="number">0</span>),</div><div class="line">      mSystemReady(<span class="literal">false</span>)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line"></div><div class="line">    mDevicesFactoryHal = DevicesFactoryHalInterface::create();</div><div class="line">    mEffectsFactoryHal = EffectsFactoryHalInterface::create();</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里我们主要看一下DevicesFactoryHalInterface关系图。EffectsFactoryHalInterface也是类似的情况。<br><img src="https://i.imgur.com/urJudFp.png" alt=""><br>阅读每个类的代码实现，我们发现只有DevicesFactoryHalHybrid实现了DevicesFactoryHalInterface接口的create()函数，所以这里会创建DevicesFactoryHalHybrid实例，而DevicesFactoryHalHybrid会创建DevicesFactoryHalLocal和DevicesFactoryHalHidl实例。DevicesFactoryHalLocal用于直接加载HAL的lib，是为了兼容8.0之前的版本，而DevicesFactoryHalHidl通过binder通信从hwservicemanager中返回IDevicesFactory实例，通过IDevicesFactory的openDevice函数返回具体的Device，并且用DeviceHalHidl封装返回的Device，这里不再会直接加载HAL的lib，后续和HAL的通信完全通过IDevicesFactory接口，具体在AudioPolicyService加载HW module时会更清楚明白。</p><p>第一次初始化还会执行onFirstRef()，创建PatchPanel实例且将AudioFlinger实例传入PatchPanel，设置Audio Mode为AUDIO_MODE_NORMAL,并将自己保存在全局变量gAudioFlinger。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> AudioFlinger::onFirstRef()</div><div class="line">&#123;</div><div class="line">    Mutex::Autolock _l(mLock);</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">    mPatchPanel = <span class="keyword">new</span> PatchPanel(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    mMode = AUDIO_MODE_NORMAL;</div><div class="line"></div><div class="line">    gAudioFlinger = <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Mutex是互斥类，用于多线程访问同一个资源的时候，保证一次只有一个线程能访问该资源。它的工作原理是某一个线程要访问公共资源的时候先锁定这个Mutex，完成操作之后对Mutex解锁，在此期间如果有其它的线程也要访问公共资源，它就先要去锁Mutex，当它发现Mutex已经被锁住了，那么这个线程就是阻塞在那儿。等Mutex解锁之后所有阻塞在Mutex的线程都会醒来，只有第一个醒来的会抢到Mutex，其它没有抢到的发现自己晚了一步，只能继续阻塞在那儿，等待下次机会。Mutex源码位置/system/core/libutils/include/utils。</p><p>为了简化一般的Mutex操作，在class Mutex中定义了一个内部类Autolock，它利用{}作用域实现自动解锁，看一下它的构造函数就知道了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Autolock</span> &#123;</span></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        inline explicit Autolock(Mutex&amp; mutex) : mLock(mutex)  &#123; mLock.lock(); &#125;</div><div class="line">        inline explicit Autolock(Mutex* mutex) : mLock(*mutex) &#123; mLock.lock(); &#125;</div><div class="line">        <span class="keyword">inline</span> ~Autolock() &#123; mLock.unlock(); &#125;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        Mutex&amp; mLock;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>我们知道在{}中创建的变量，变开这个大括号时就要销毁，于是就自动调用析构函数了。</p><h2 id="AudioFlinger中放音录音线程"><a href="#AudioFlinger中放音录音线程" class="headerlink" title="AudioFlinger中放音录音线程"></a>AudioFlinger中放音录音线程</h2><p>AudioFlinger作为音频的核心服务，主要责任是负责放音与录音，下面我们可以大致看看放音与录音线程的关系，在AudioPolicyServic启动过程中我们会看到这些线程的创建。<br><img src="https://i.imgur.com/FiwGgwV.png" alt=""></p><ul><li>ThreadBase：ThreadBase以Thread为基类，而又是PlaybackThread、RecordThread和MmapThread的基类。</li><li>RecordThread：音频录音线程，负责音频的录音，没有子类。</li><li>PlaybackThread：代表放音线程，有两个直接子类MixerThread和DirectOutputThread。</li><li>MixerThread：混音放音线程，有子类DuplicatingThread，负责处理标识为<br>AUDIO_OUTPUT_FLAG_PRIMARY、AUDIO_OUTPUT_FLAG_FAST、AUDIO_OUTPUT_FLAG_DEEP_BUFFER的音频流，MixerThread 可以把多个音轨的数据混音后再输出。</li><li>DirectOutputThread：直接输出放音线程，有子类OffloadThread，负责处理标识为AUDIO_OUTPUT_FLAG_DIRECT的音频流，这种音频流数据不需要软件混音，直接输出到音频设备即可。</li><li>DuplicatingThread：复制输出放音线程，负责复制音频流数据到其他输出设备，使用场景如主声卡设备、蓝牙耳机设备、USB声卡设备同时输出。</li><li>OffloadThread：硬解回放线程，负责处理标识为AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD的音频流，这种音频流未经软件解码的（一般是MP3、AAC等格式的数据），需要输出到硬件解码器，由硬件解码器解码成PCM 数据。</li><li>MmapThread：这个线程是Android 8.0新加入的，用于低延迟的放音与录音，与AAudio有关系，有MmapPlaybackThread和MmapCaptureThread两个子类。</li><li>MmapPlaybackThread：MMAP放音线程，负责处理标识为AUDIO_OUTPUT_FLAG_MMAP_NOIRQ的音频流。</li><li>MmapcaptureThread：MMAP录音线程，负责处理标识为AUDIO_INPUT_FLAG_MMAP_NOIRQ的音频流。<h2 id="AudioFlinger中Tracks"><a href="#AudioFlinger中Tracks" class="headerlink" title="AudioFlinger中Tracks"></a>AudioFlinger中Tracks</h2>Track：音轨，是AudioFlinger中另一个重要的将角色，下面我们可以看看其关系。<br><img src="https://i.imgur.com/HHP2bZp.png" alt=""><br>对于播放对应Track，OutputTrack，TrackHandle及BnAudioTrack，TrackHandle和BnAudioTrack主要用于和Client端Binder通信，真正代表输出音轨的为Track。同样对应录音音轨的是RecordTrack，RecordHandle及BnAudioRecord，RecordHandle和BnAudioRecord也用于Binder通信，真正录音音轨为RecordTrack。而对于MmapTrack稍微不太样，而是定义通用接口MmapStreamInterface封装MmapThread，再封装MmapTrack，不是通过XXXHandle继承BnXXX，这也许是出于latency上的考虑。<h2 id="AudioFlinger中的Streams"><a href="#AudioFlinger中的Streams" class="headerlink" title="AudioFlinger中的Streams"></a>AudioFlinger中的Streams</h2>我们看到在AudioFlinger中以AudioHwDevice封装HAL的DeviceHalHidl，而DeviceHalHidl封装从HAL返回的具体的Device，这就和HAL层的so文件连接在一起，且AudioHwDevice直接或间接依赖AudioStreamOut和AudioStreanIn这样也和HAL层中stream关联上，后续打开音频输入输出以及打开输入音频流及输出音频流做好准备。具体我们可以在AudioPolicyService启动的时候看的更清楚。<br><img src="https://i.imgur.com/bIsUSZO.png" alt=""><br>AudioFlinger中还有很多其他的知识点，后续学到时再慢慢补上。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AudioFlinger以media.audio_flinger为名注册到ServiceManager，是Android Audio系统的一个核心服务，是音频策略的执行者，负责输入输出流设备的管理及音频流数据的处理传输。本文以Android 8.0的代码为基础，记录了其启动
      
    
    </summary>
    
      <category term="Android Audio" scheme="http://yoursite.com/categories/Android-Audio/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Audio Server启动</title>
    <link href="http://yoursite.com/2017/11/08/Android-Audio-Server%E5%90%AF%E5%8A%A8/"/>
    <id>http://yoursite.com/2017/11/08/Android-Audio-Server启动/</id>
    <published>2017-11-08T02:44:20.000Z</published>
    <updated>2017-11-19T09:55:49.540Z</updated>
    
    <content type="html"><![CDATA[<p>Android audioserver是Audio系统native的服务，也是连接Audio Framework和Audio HAL的一个纽带，其中包含了AudioFlinger、AudioPolicyService、AAudioService、RadioService、SoundTriggerHwService等服务。源代码位于frameworks/av/media/audioserver</p><p>从Android 7.0开始，Audio相关的service从mediaserver中转移到audioserver，把audio，camera及mediaplayerservice做了一个拆分，这样不会显得臃肿、职能更加独立且安全性更高。拆分之后audioserver还是一个native service，还是从init进程中启动，如下是其在audioserver.rc中的启动代码。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">service audioserver /system/bin/audioserver</div><div class="line">    class main                                   <span class="comment"># audioserver和class main行为一致</span></div><div class="line">    user audioserver                             <span class="comment"># 用户归属，uid：AID_AUDIOSERVER</span></div><div class="line">    <span class="comment"># media gid needed for /dev/fm (radio) and for /data/misc/media (tee)</span></div><div class="line">    group audio camera drmrpc inet media mediadrm net_bt \</div><div class="line">          net_bt_admin net_bw_acct oem_2901                         <span class="comment"># 用户组归属</span></div><div class="line">    ioprio rt 4                                                     <span class="comment"># io调度优先级</span></div><div class="line">    <span class="comment"># 当子进程被创建的时候，将子进程的pid写入到给定的文件中,cgroup/cpuset用法</span></div><div class="line">    writepid /dev/cpuset/foreground/tasks /dev/stune/foreground/tasks                </div><div class="line">    onrestart restart audio-hal-2-0                     <span class="comment"># audioserver重启会重启hal</span></div></pre></td></tr></table></figure><p>我们看到Android 8.0当重启audioserver时，会重启audio-hal-2-0，这个服务是audio hal的服务，在android 8.0中，framework native进程与hal分离，hal不在和framework native处于同一个进程，而是独立进程，进程间通过binder通信。先不讲HAL binder化，我们先看看audioserver中包含哪几个服务。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc __unused, <span class="keyword">char</span> **argv)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">   signal(SIGPIPE, SIG_IGN);</div><div class="line"></div><div class="line">   <span class="keyword">bool</span> doLog = (<span class="keyword">bool</span>) property_get_bool(<span class="string">"ro.test_harness"</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">   <span class="keyword">pid_t</span> childPid;</div><div class="line"></div><div class="line">   ......</div><div class="line"></div><div class="line">   <span class="keyword">if</span> (doLog &amp;&amp; (childPid = fork()) != <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">      ......</div><div class="line"></div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">      sp&lt;ProcessState&gt; proc(ProcessState::self());</div><div class="line">      sp&lt;IServiceManager&gt; sm = defaultServiceManager();</div><div class="line">      ALOGI(<span class="string">"ServiceManager: %p"</span>, sm.get());</div><div class="line">      AudioFlinger::instantiate();</div><div class="line">      AudioPolicyService::instantiate();</div><div class="line">      AAudioService::instantiate();</div><div class="line">      RadioService::instantiate();</div><div class="line">      SoundTriggerHwService::instantiate();</div><div class="line"></div><div class="line">      ProcessState::self()-&gt;startThreadPool();</div><div class="line"></div><div class="line"><span class="comment">// <span class="doctag">FIXME:</span> remove when BUG 31748996 is fixed</span></div><div class="line">      android::hardware::ProcessState::self()-&gt;startThreadPool();</div><div class="line"></div><div class="line">      IPCThreadState::self()-&gt;joinThreadPool();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>从如上代码可以看出，audioserver中回依次执行AudioFlinger、AudioPolicyService、AAudioService、RadioService、SoundTriggerHwService的instantiate函数。通过阅读源代码，由于继承的缘故这个五个service最终会调用BinderService的instantiate函数且将自己注册到ServiceManager中，后续client端可以通过service注册时用的name从ServiceManager返回server端。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> SERVICE&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinderService</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> status_t <span class="title">publish</span><span class="params">(<span class="keyword">bool</span> allowIsolated = <span class="literal">false</span>)</span> </span>&#123;</div><div class="line">        sp&lt;IServiceManager&gt; sm(defaultServiceManager());</div><div class="line">        <span class="keyword">return</span> sm-&gt;addService(</div><div class="line">                String16(SERVICE::getServiceName()),</div><div class="line">                <span class="keyword">new</span> SERVICE(), allowIsolated);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publishAndJoinThreadPool</span><span class="params">(<span class="keyword">bool</span> allowIsolated = <span class="literal">false</span>)</span> </span>&#123;</div><div class="line">        publish(allowIsolated);</div><div class="line">        joinThreadPool();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">instantiate</span><span class="params">()</span> </span>&#123; publish(); &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> status_t <span class="title">shutdown</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> NO_ERROR; &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">joinThreadPool</span><span class="params">()</span> </span>&#123;</div><div class="line">        sp&lt;ProcessState&gt; ps(ProcessState::self());</div><div class="line">        ps-&gt;startThreadPool();</div><div class="line">        ps-&gt;giveThreadPoolName();</div><div class="line">        IPCThreadState::self()-&gt;joinThreadPool();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>AudioFlinger（media.audio_flinger）：Audio系统的一个核心服务，是音频策略的执行者，负责输入输出流设备的管理及音频流数据的处理传输。</p><p>AudioPolicyService（media.audio_policy）：音频策略的制定者，负责音频设备切换的策略抉择、音量调节策略等。</p><p>AAudioService（media.aaudio）：这是Android 8.0加入角色，是OpenSL ES的另外一种选择，需要低延迟的高性能音频应用的另外一种选择。</p><p>RadioService（media.radio）：与FM相关的一个服务。</p><p>SoundTriggerHwService（media.sound_trigger_hw）：Android语音识别的native服务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android audioserver是Audio系统native的服务，也是连接Audio Framework和Audio HAL的一个纽带，其中包含了AudioFlinger、AudioPolicyService、AAudioService、RadioService、S
      
    
    </summary>
    
      <category term="Android Audio" scheme="http://yoursite.com/categories/Android-Audio/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>GitHub搭建个人的博客</title>
    <link href="http://yoursite.com/2017/10/30/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2017/10/30/GitHub搭建自己的博客/</id>
    <published>2017-10-30T09:34:27.481Z</published>
    <updated>2017-11-19T09:52:02.501Z</updated>
    
    <content type="html"><![CDATA[<p>最近突然间发现，自己过去看过的东西，没过多久就忘得一干二净，每当要用时，又得从头来一遍，真是好记性不如烂笔头，所以有了写笔记的想法，GitHub上可以方便记录自己一切想记录的，于是就在GitHub上开始写笔记，希望自己不要把知识忘得太快。本文记录在Windows环境下使用Hexo搭建GitHub博客的过程。</p><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>在nodejs官网下载对应的版本安装<br>下载地址：<a href="https://nodejs.org/en/download" target="_blank" rel="external">https://nodejs.org/en/download</a></p><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>下载地址：<a href="https://git-for-windows.github.io" target="_blank" rel="external">https://git-for-windows.github.io</a></p><h2 id="创建GitHub账户"><a href="#创建GitHub账户" class="headerlink" title="创建GitHub账户"></a>创建GitHub账户</h2><p>进入GitHub主页<a href="https://github.com/" target="_blank" rel="external">https://github.com/</a>，依次输入用户名、邮箱、密码，然后点击注册，按默认点击“Finish sign up”。然后进行邮箱验证。</p><h2 id="创建GitHub仓库"><a href="#创建GitHub仓库" class="headerlink" title="创建GitHub仓库"></a>创建GitHub仓库</h2><p>点击“New repository”，新建一个仓库，仓库名为“[yourname].github.io”，这样<a href="https://[yourname].github.io" target="_blank" rel="external">https://[yourname].github.io</a> 就是你的博客地址了。默认这仓库只有master分支，新建一个hexo分支。</p><h2 id="配置Hexo"><a href="#配置Hexo" class="headerlink" title="配置Hexo"></a>配置Hexo</h2><p>接下来的命令都在Git Bash中执行。</p><p>在自己喜欢的位置新建一个blog文件夹，在这个文件夹下打开Git Bash，因为npm是国外服务器，可能执行比较慢，可以使用淘宝镜像，命令如下：</p><pre><code>$ npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>执行成功后使用淘宝NPM安装Hexo</p><pre><code>$ cnpm install -g hexo-cli$ cnmp install hexo --save$ hexo -vhexo: 3.4.0hexo-cli: 1.0.4os: Windows_NT 6.1.7600 win32 ia32http_parser: 2.7.0node: 8.7.0v8: 6.1.534.42uv: 1.15.0zlib: 1.2.11ares: 1.10.1-DEVmodules: 57nghttp2: 1.25.0openssl: 1.0.2licu: 59.1unicode: 9.0cldr: 31.0.1tz: 2017b</code></pre><p>到这里hexo已经安装好了</p><h2 id="配置ssh-key"><a href="#配置ssh-key" class="headerlink" title="配置ssh key"></a>配置ssh key</h2><pre><code>ssh-keygen -t rsa -C &quot;Github的注册邮箱地址&quot;</code></pre><p>在C:\Users\yourname\.ssh下会得到密钥id_rsa和id_rsa.pub，用nodepad++打开id_rsa.pub复制全文，打开<a href="https://github.com/settings/ssh" target="_blank" rel="external">https://github.com/settings/ssh</a>，Add SSH key，粘贴进去保存。 </p><p>测试是否配置成功</p><pre><code>$ ssh -T git@github.comHi [yourname]! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</code></pre><h2 id="配置git信息"><a href="#配置git信息" class="headerlink" title="配置git信息"></a>配置git信息</h2><pre><code>$ git config --global user.name &quot;你的用户名&quot;$ git config --global user.email &quot;你的邮箱&quot;</code></pre><h2 id="使用Hexo管理博客"><a href="#使用Hexo管理博客" class="headerlink" title="使用Hexo管理博客"></a>使用Hexo管理博客</h2><h3 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h3><pre><code>$ hexo init &lt;nodejs-hexo&gt; //初始化nodejs-hexo（文件夹名随意）$ git clone -b hexo https://github.com/[yourname]/[yourname].github.io</code></pre><p>将[yourname].github.io文件夹下的.git文件夹拷贝到nodejs-hexo文件夹。</p><pre><code>$ cnpm install //安装生成器$ hexo server //运行（Ctrl + C停止运行）</code></pre><p>在浏览器输入localhost:4000，这样就可以在本地看到博客了。</p><h3 id="配置博客"><a href="#配置博客" class="headerlink" title="配置博客"></a>配置博客</h3><p>_config.yml中配置基本信息</p><pre><code>title: #博客标题subtitle: #博客副标题description: #博客描述author: #博客作者language: zh-Hanstimezone: Asia/Shanghai</code></pre><p>_config.yml中配置主题</p><pre><code>theme: next</code></pre><p>_config.yml中配置部署</p><pre><code>deploy:  type: git  repo: https://github.com/[yourname]/[yourname].github.io  branch: master</code></pre><p>注意：这里的设置冒号后面必须有空格</p><h3 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h3><pre><code>$ hexo new &quot;博客名&quot; //增加新文章$ cnpm install hexo-deployer-git --save //安装hexo git插件$ git add .$ git commit -m &quot;message&quot;$ git push origin hexo$ hexo generate //生成静态文件$ hexo deploy   //部署</code></pre><h3 id="换PC管理博客"><a href="#换PC管理博客" class="headerlink" title="换PC管理博客"></a>换PC管理博客</h3><pre><code>$ git clone -b hexo https://github.com/[yourname]/[yourname].github.io</code></pre><p>在[yourname].github.io中从新安装hexo，就可以写博客及发布博客了。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>Next主题配置参考：<a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="external">http://theme-next.iissnan.com/theme-settings.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近突然间发现，自己过去看过的东西，没过多久就忘得一干二净，每当要用时，又得从头来一遍，真是好记性不如烂笔头，所以有了写笔记的想法，GitHub上可以方便记录自己一切想记录的，于是就在GitHub上开始写笔记，希望自己不要把知识忘得太快。本文记录在Windows环境下使用H
      
    
    </summary>
    
      <category term="搭建博客" scheme="http://yoursite.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
  </entry>
  
</feed>
