<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Raycco&#39;s Notes</title>
  
  <subtitle>Quick Notes</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-11-21T12:15:30.239Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Raycco</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AudioPolicyService启动过程</title>
    <link href="http://yoursite.com/2017/11/10/AudioPolicyService%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/11/10/AudioPolicyService启动过程/</id>
    <published>2017-11-10T12:39:29.000Z</published>
    <updated>2017-11-21T12:15:30.239Z</updated>
    
    <content type="html"><![CDATA[<p>AudioPolicyService在Audio系统另一个重要的服务，是音频策略的制定者，负责音频设备切换的策略抉择、音量调节策略等。本文基于Android 8.0的代码，记录了AudioPolicyService启动的过程，介绍了其中几个比较关键的点，希望以后自己看到此文能快速回想起AudioPolicyService的启动过程。其代码位于frameworks/av/services/audiopolicy。</p><h2 id="audiopolicy的代码结构"><a href="#audiopolicy的代码结构" class="headerlink" title="audiopolicy的代码结构"></a>audiopolicy的代码结构</h2><ol><li>service目录是AudioPolicyService、AudioPolicyClient、AudioCommandThread及AudioPolicyEffects的定义及实现。</li><li>managerdefault目录提供AudioPolicyManager的基本实现。</li><li>manager目录中是一个工厂类可以根据需要生产所需的AudioPolicyManager，一般各个厂商都会自己实现自己的AudioPolicyManager。</li><li>engine目录定义了AudioPolicyManagerInterface和AudioPolicyManagerObserver接口，<br>AudioPolicyManagerInterface由Policy Engine实现，AudioPolicyManagerObserver这个观察者由AudioPolicyManager实现，以供Engine访问。</li><li>engineconfigure和enginedefault目录是Policy Engine的两种实现，可以根据需要选择其中一种。</li><li>config目录存放audio policy及音量曲线的config文件。</li><li>common目录下定义公共代码。audio_policy.conf是旧版本的audio policy config文件。</li><li>AudioPolicyInterface.h定义了AudioPolicyInterface和AudioPolicyClientInterface接口，AudioPolicyInterface由AuidoPolicyManager实现，特定平台AuidoPolicyManager通过AudioPolicyClientInterface接口的实现者AudioPolicyClient控制音频的输入输出。<br><img src="https://i.imgur.com/kZpNl4i.png" alt=""><h2 id="AudioPolicyService初始化"><a href="#AudioPolicyService初始化" class="headerlink" title="AudioPolicyService初始化"></a>AudioPolicyService初始化</h2>从Android 8.0的code发现，基本流程还是和之前一样，分别创建了ApmTone、ApmAudio、ApmOutput三个AudioCommandThread线程，分别用于播放tone音、执行audio命令和执行输出命令，创建AudioPolicyClient，创建AudioPolicyManager以及创建AudioPolicyEffects。但已经完全移除了对旧版本的AUDIO_POLICY_HARDWARE_MODULE_ID的支持（不再加载audio_policy.default.so库得到audio_policy_module模块），完全使用新模式。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">AudioPolicyService::AudioPolicyService()</div><div class="line">    : BnAudioPolicyService(), mpAudioPolicyDev(<span class="literal">NULL</span>), mpAudioPolicy(<span class="literal">NULL</span>),</div><div class="line">      mAudioPolicyManager(<span class="literal">NULL</span>), mAudioPolicyClient(<span class="literal">NULL</span>), mPhoneState(AUDIO_MODE_INVALID)</div><div class="line">&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> AudioPolicyService::onFirstRef()</div><div class="line">&#123;</div><div class="line">    &#123;</div><div class="line">        Mutex::Autolock _l(mLock);</div><div class="line"></div><div class="line">        <span class="comment">// start tone playback thread</span></div><div class="line">        mTonePlaybackThread = <span class="keyword">new</span> AudioCommandThread(String8(<span class="string">"ApmTone"</span>), <span class="keyword">this</span>);</div><div class="line">        <span class="comment">// start audio commands thread</span></div><div class="line">        mAudioCommandThread = <span class="keyword">new</span> AudioCommandThread(String8(<span class="string">"ApmAudio"</span>), <span class="keyword">this</span>);</div><div class="line">        <span class="comment">// start output activity command thread</span></div><div class="line">        mOutputCommandThread = <span class="keyword">new</span> AudioCommandThread(String8(<span class="string">"ApmOutput"</span>), <span class="keyword">this</span>);</div><div class="line"></div><div class="line">        mAudioPolicyClient = <span class="keyword">new</span> AudioPolicyClient(<span class="keyword">this</span>);</div><div class="line">        mAudioPolicyManager = createAudioPolicyManager(mAudioPolicyClient);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// load audio processing modules</span></div><div class="line">    sp&lt;AudioPolicyEffects&gt;audioPolicyEffects = <span class="keyword">new</span> AudioPolicyEffects();</div><div class="line">    &#123;</div><div class="line">        Mutex::Autolock _l(mLock);</div><div class="line">        mAudioPolicyEffects = audioPolicyEffects;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>这些类之间的大致关系如下（AudioPolicyClient和AudioCommandThread都为AudioPolicyService的内部类）：<br><img src="https://i.imgur.com/wNiugU3.png" alt=""><br>AudioPolicyService的初始化大致分为3步：<br>1.创建三个AudioCommandThread（mTonePlaybackThread，mAudioCommandThread和mOutputCommandThread）<br>2.初始化AudioPolicyManager<br> 2.1 加载并解析audio_policy_configuration.xml<br> 2.2 加载对应的HW module<br> 2.3 初始化Policy Engine<br> 2.4 打开输入输出<br> 2.5 确保所有可用输入输出设备和默认输出设备真正可用<br>3.初始化AudioPolicyEffects</p><h2 id="AudioCommandThread线程"><a href="#AudioCommandThread线程" class="headerlink" title="AudioCommandThread线程"></a>AudioCommandThread线程</h2><p>AudioCommandThread采用异步方式来执行audio command，当需要执行上表中的命令时，首先将命令投递到AudioCommandThread的mAudioCommands命令向量表中，然后通过mWaitWorkCV.signal()唤醒AudioCommandThread线程，被唤醒的AudioCommandThread线程执行完command后，又通过mWaitWorkCV.waitRelative(mLock, waitTime)睡眠等待命令到来。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> AudioPolicyService::AudioCommandThread::onFirstRef()</div><div class="line">&#123;</div><div class="line">    run(mName.<span class="built_in">string</span>(), ANDROID_PRIORITY_AUDIO);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">status_t</span> AudioPolicyService::AudioCommandThread::volumeCommand(<span class="keyword">audio_stream_type_t</span> stream,</div><div class="line">                              <span class="keyword">float</span> volume, <span class="keyword">audio_io_handle_t</span> output, <span class="keyword">int</span> delayMs)</div><div class="line">&#123;</div><div class="line">    sp&lt;AudioCommand&gt; command = <span class="keyword">new</span> AudioCommand();</div><div class="line">    command-&gt;mCommand = SET_VOLUME;</div><div class="line">    sp&lt;VolumeData&gt; data = <span class="keyword">new</span> VolumeData();</div><div class="line">    data-&gt;mStream = stream;</div><div class="line">    data-&gt;mVolume = volume;</div><div class="line">    data-&gt;mIO = output;</div><div class="line">    command-&gt;mParam = data;</div><div class="line">    command-&gt;mWaitStatus = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">return</span> sendCommand(command, delayMs);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">bool</span> AudioPolicyService::AudioCommandThread::threadLoop()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">nsecs_t</span> waitTime = <span class="number">-1</span>;</div><div class="line"></div><div class="line">    mLock.lock();</div><div class="line">    <span class="keyword">while</span> (!exitPending())</div><div class="line">    &#123;</div><div class="line">        sp&lt;AudioPolicyService&gt; svc;</div><div class="line">        <span class="keyword">while</span> (!mAudioCommands.isEmpty() &amp;&amp; !exitPending()) &#123;</div><div class="line">            <span class="keyword">nsecs_t</span> curTime = systemTime();</div><div class="line">            <span class="comment">// commands are sorted by increasing time stamp: execute them from index 0 and up</span></div><div class="line">            <span class="keyword">if</span> (mAudioCommands[<span class="number">0</span>]-&gt;mTime &lt;= curTime) &#123;</div><div class="line">                sp&lt;AudioCommand&gt; command = mAudioCommands[<span class="number">0</span>];</div><div class="line">                mAudioCommands.removeAt(<span class="number">0</span>);</div><div class="line">                mLastCommand = command;</div><div class="line"></div><div class="line">                <span class="keyword">switch</span> (command-&gt;mCommand) &#123;</div><div class="line"></div><div class="line">                ......</div><div class="line"></div><div class="line">                <span class="keyword">case</span> SET_VOLUME: &#123;</div><div class="line">                    VolumeData *data = (VolumeData *)command-&gt;mParam.get();</div><div class="line">                    ALOGV(<span class="string">"AudioCommandThread() processing set volume stream %d, \</span></div><div class="line"><span class="string">                            volume %f, output %d"</span>, data-&gt;mStream, data-&gt;mVolume, data-&gt;mIO);</div><div class="line">                    command-&gt;mStatus = AudioSystem::setStreamVolume(data-&gt;mStream,</div><div class="line">                                                                    data-&gt;mVolume,</div><div class="line">                                                                    data-&gt;mIO);</div><div class="line">                    &#125;<span class="keyword">break</span>;</div><div class="line"></div><div class="line">                ......</div><div class="line"></div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                .....</div><div class="line"></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                waitTime = mAudioCommands[<span class="number">0</span>]-&gt;mTime - curTime;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ......</div><div class="line"></div><div class="line">        <span class="comment">// At this stage we have either an empty command queue or the first command in the queue</span></div><div class="line">        <span class="comment">// has a finite delay. So unless we are exiting it is safe to wait.</span></div><div class="line">        <span class="keyword">if</span> (!exitPending()) &#123;</div><div class="line">            ALOGV(<span class="string">"AudioCommandThread() going to sleep"</span>);</div><div class="line">            <span class="keyword">if</span> (waitTime == <span class="number">-1</span>) &#123;</div><div class="line">                mWaitWorkCV.wait(mLock);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                mWaitWorkCV.waitRelative(mLock, waitTime);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ......</div><div class="line"></div><div class="line">    mLock.unlock();</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>AudioCommandThread是AudioPolicyService的内部类，AudioCommandThread在内部又定义了AudioCommand及AudioCommandData关系如下。<br><img src="https://i.imgur.com/6IUY98f.png" alt=""></p><h2 id="AudioPolicyManager初始化"><a href="#AudioPolicyManager初始化" class="headerlink" title="AudioPolicyManager初始化"></a>AudioPolicyManager初始化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">AudioPolicyManager::AudioPolicyManager(AudioPolicyClientInterface *clientInterface)</div><div class="line">    :</div><div class="line">    mLimitRingtoneVolume(<span class="literal">false</span>), mLastVoiceVolume(<span class="number">-1.0f</span>),</div><div class="line">    mA2dpSuspended(<span class="literal">false</span>),</div><div class="line">    mAudioPortGeneration(<span class="number">1</span>),</div><div class="line">    mBeaconMuteRefCount(<span class="number">0</span>),</div><div class="line">    mBeaconPlayingRefCount(<span class="number">0</span>),</div><div class="line">    mBeaconMuted(<span class="literal">false</span>),</div><div class="line">    mTtsOutputAvailable(<span class="literal">false</span>),</div><div class="line">    mMasterMono(<span class="literal">false</span>),</div><div class="line">    mMusicEffectOutput(AUDIO_IO_HANDLE_NONE),</div><div class="line">    mHasComputedSoundTriggerSupportsConcurrentCapture(<span class="literal">false</span>)</div><div class="line">&#123;</div><div class="line">    mUidCached = getuid();</div><div class="line">    mpClientInterface = clientInterface;</div><div class="line"></div><div class="line">    ...... </div><div class="line">    <span class="comment">// audio policy config加载</span></div><div class="line"></div><div class="line">    <span class="comment">// 初始化Policy Engine</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mHwModules.size(); i++) &#123;</div><div class="line">        <span class="comment">// 加载所有的HW module</span></div><div class="line">        ......</div><div class="line">        <span class="comment">// 打开音频输入输出</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 确保所有可用输入输出设备真正可用</span></div><div class="line">    ......</div><div class="line"></div><div class="line">    <span class="comment">// 确保默认输出设备真正可用</span></div><div class="line">    ALOGE_IF((mPrimaryOutput == <span class="number">0</span>), <span class="string">"Failed to open primary output"</span>);</div><div class="line">    updateDevicesAndOutputs();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="audio-policy-config加载"><a href="#audio-policy-config加载" class="headerlink" title="audio policy config加载"></a>audio policy config加载</h3><p>进入AudioPolicyManager构造函数，会首先加载audio policy config文件，对于旧版本使用audio_policy.conf，在代码中定义音量曲线，对于新版本使用audio_policy_configuration.xml。对于Android 8.0使用新版本，这个文件一般会位于/odm/etc或/vendor/etc，同时解析音量曲线xml（audio_policy_volumes.xml和default_volume_tables.xml）,比起之前的硬编码音量曲线，灵活性更好。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_XML_AUDIO_POLICY_CONF</span></div><div class="line">    mVolumeCurves = <span class="keyword">new</span> VolumeCurvesCollection();</div><div class="line">    <span class="function">AudioPolicyConfig <span class="title">config</span><span class="params">(mHwModules, mAvailableOutputDevices, mAvailableInputDevices,</span></span></div><div class="line"><span class="function"><span class="params">                             mDefaultOutputDevice, speakerDrcEnabled,</span></span></div><div class="line">                             static_cast&lt;VolumeCurvesCollection *&gt;(mVolumeCurves));</div><div class="line">    <span class="keyword">if</span> (deserializeAudioPolicyXmlConfig(config) != NO_ERROR) &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    mVolumeCurves = <span class="keyword">new</span> StreamDescriptorCollection();</div><div class="line">    <span class="function">AudioPolicyConfig <span class="title">config</span><span class="params">(mHwModules, mAvailableOutputDevices, mAvailableInputDevices,</span></span></div><div class="line"><span class="function"><span class="params">                             mDefaultOutputDevice, speakerDrcEnabled)</span></span>;</div><div class="line">    <span class="keyword">if</span> ((ConfigParsingUtils::loadConfig(AUDIO_POLICY_VENDOR_CONFIG_FILE, config) != NO_ERROR) &amp;&amp;</div><div class="line">            (ConfigParsingUtils::loadConfig(AUDIO_POLICY_CONFIG_FILE, config) != NO_ERROR)) &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">        ALOGE(<span class="string">"could not load audio policy configuration file, setting defaults"</span>);</div><div class="line">        config.setDefault();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// must be done after reading the policy (since conditionned by Speaker Drc Enabling)</span></div><div class="line">    <span class="comment">// xml模式时这里是一个空函数无实现</span></div><div class="line">    mVolumeCurves-&gt;initializeVolumeCurves(speakerDrcEnabled);</div></pre></td></tr></table></figure></p><p>当执行完deserializeAudioPolicyXmlConfig，会得到mHwModules对应各个Audio HAL模块、mAvailableOutputDevices可用的输出设备、mAvailableInputDevices可用的输入设备、mDefaultOutputDevice默认输出设备、mVolumeCurves音量曲线及speakerDrcEnabled。</p><p>audio_policy_configuration.xml同时定义了多个audio接口(HwModules)，每一个audio接口包含若干routes（通路）、devicesPorts（设备）和mixPorts（音频流），而每个mixPorts又包含多个input和output流，每个input和output流又同时支持多种输入输出模式，每种输入输出模式又支持若干种设备。<br>mixPorts：listing all output and input streams exposed by the audio HAL.<br>routes：list of possible connections between input and output devices or between stream and devices.<br>devicePorts：a list of device descriptors for all input and output devices accessible via this module.This contains both permanently attached devices and removable devices.<br><img src="https://i.imgur.com/eEXkdfk.png" alt=""><br>每个stream type会分为四种device category：DEVICE_CATEGORY_HEADSET，DEVICE_CATEGORY_SPEAKER，DEVICE_CATEGORY_EARPIECE及DEVICE_CATEGORY_EXT_MEDIA来定义音量曲线，定义的形式如下，一样是分段定义，在每一段中定义不同的衰减值以控制音量的大小。<br>It contains a list of points of this curve expressing the attenuation in Millibels for a given volume index from 0 to 100.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">volume</span> <span class="attr">stream</span>=<span class="string">"AUDIO_STREAM_VOICE_CALL"</span> <span class="attr">deviceCategory</span>=<span class="string">"DEVICE_CATEGORY_HEADSET"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">point</span>&gt;</span>0,-4200<span class="tag">&lt;/<span class="name">point</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">point</span>&gt;</span>33,-2800<span class="tag">&lt;/<span class="name">point</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">point</span>&gt;</span>66,-1400<span class="tag">&lt;/<span class="name">point</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">point</span>&gt;</span>100,0<span class="tag">&lt;/<span class="name">point</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">volume</span>&gt;</span></div></pre></td></tr></table></figure></p><h3 id="初始化Policy-Engine"><a href="#初始化Policy-Engine" class="headerlink" title="初始化Policy Engine"></a>初始化Policy Engine</h3><p>这里也算一个观察者模式吧，EngineInstance是单例模式，通过EngineInstance创建AudioPolicyManagerInterface，从而创建Policy Engine，然后设置观察者。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Once policy config has been parsed, retrieve an instance of the engine and initialize it.</span></div><div class="line">    audio_policy::EngineInstance *engineInstance = audio_policy::EngineInstance::getInstance();</div><div class="line">    <span class="keyword">if</span> (!engineInstance) &#123;</div><div class="line">        ALOGE(<span class="string">"%s:  Could not get an instance of policy engine"</span>, __FUNCTION__);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Retrieve the Policy Manager Interface</span></div><div class="line">    mEngine = engineInstance-&gt;queryInterface&lt;AudioPolicyManagerInterface&gt;();</div><div class="line">    <span class="keyword">if</span> (mEngine == <span class="literal">NULL</span>) &#123;</div><div class="line">        ALOGE(<span class="string">"%s: Failed to get Policy Engine Interface"</span>, __FUNCTION__);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    mEngine-&gt;setObserver(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">status_t</span> status = mEngine-&gt;initCheck();</div><div class="line">    (<span class="keyword">void</span>) status;</div><div class="line">    ALOG_ASSERT(status == NO_ERROR, <span class="string">"Policy engine not initialized(err=%d)"</span>, status);</div></pre></td></tr></table></figure></p><p>其大致关系如下。<br><img src="https://i.imgur.com/PDHsnQK.png" alt=""></p><h3 id="加载HW-Module"><a href="#加载HW-Module" class="headerlink" title="加载HW Module"></a>加载HW Module</h3><p>根据audio policy config加载的HwModule真正加载HAL层的HW module。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// mAvailableOutputDevices and mAvailableInputDevices now contain all attached devices</span></div><div class="line"><span class="comment">// open all output streams needed to access attached devices</span></div><div class="line"><span class="keyword">audio_devices_t</span> outputDeviceTypes = mAvailableOutputDevices.types();</div><div class="line"><span class="keyword">audio_devices_t</span> inputDeviceTypes = mAvailableInputDevices.types() &amp; ~AUDIO_DEVICE_BIT_IN;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mHwModules.size(); i++) &#123;</div><div class="line">    mHwModules[i]-&gt;mHandle = mpClientInterface-&gt;loadHwModule(mHwModules[i]-&gt;getName());</div><div class="line">    <span class="keyword">if</span> (mHwModules[i]-&gt;mHandle == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>从如上代码看出，会执行mpClientInterface-&gt;loadHwModule，即调用AudioPolicyClient的loadHwModule函数，又会转到AudioFlinger的loadHwModule。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">audio_module_handle_t</span> AudioPolicyService::AudioPolicyClient::loadHwModule(<span class="keyword">const</span> <span class="keyword">char</span> *name)</div><div class="line">&#123;</div><div class="line">    sp&lt;IAudioFlinger&gt; af = AudioSystem::get_audio_flinger();</div><div class="line">    <span class="keyword">if</span> (af == <span class="number">0</span>) &#123;</div><div class="line">        ALOGW(<span class="string">"%s: could not get AudioFlinger"</span>, __func__);</div><div class="line">        <span class="keyword">return</span> AUDIO_MODULE_HANDLE_NONE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> af-&gt;loadHwModule(name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">audio_module_handle_t</span> AudioFlinger::loadHwModule(<span class="keyword">const</span> <span class="keyword">char</span> *name)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (name == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> AUDIO_MODULE_HANDLE_NONE;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!settingsAllowed()) &#123;</div><div class="line">        <span class="keyword">return</span> AUDIO_MODULE_HANDLE_NONE;</div><div class="line">    &#125;</div><div class="line">    Mutex::Autolock _l(mLock);</div><div class="line">    <span class="keyword">return</span> loadHwModule_l(name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// loadHwModule_l() must be called with AudioFlinger::mLock held</span></div><div class="line"><span class="keyword">audio_module_handle_t</span> AudioFlinger::loadHwModule_l(<span class="keyword">const</span> <span class="keyword">char</span> *name)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mAudioHwDevs.size(); i++) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(mAudioHwDevs.valueAt(i)-&gt;moduleName(), name, <span class="built_in">strlen</span>(name)) == <span class="number">0</span>) &#123;</div><div class="line">            ALOGW(<span class="string">"loadHwModule() module %s already loaded"</span>, name);</div><div class="line">            <span class="keyword">return</span> mAudioHwDevs.keyAt(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sp&lt;DeviceHalInterface&gt; dev;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> rc = mDevicesFactoryHal-&gt;openDevice(name, &amp;dev);</div><div class="line">    <span class="keyword">if</span> (rc) &#123;</div><div class="line">        ALOGE(<span class="string">"loadHwModule() error %d loading module %s"</span>, rc, name);</div><div class="line">        <span class="keyword">return</span> AUDIO_MODULE_HANDLE_NONE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">    <span class="comment">// Check and cache this HAL's level of support for master mute and master</span></div><div class="line">    <span class="comment">// volume.  If this is the first HAL opened, and it supports the get</span></div><div class="line">    <span class="comment">// methods, use the initial values provided by the HAL as the current</span></div><div class="line">    <span class="comment">// master mute and volume settings.</span></div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">    <span class="keyword">audio_module_handle_t</span> handle = </div><div class="line">          (<span class="keyword">audio_module_handle_t</span>) nextUniqueId(AUDIO_UNIQUE_ID_USE_MODULE);</div><div class="line">    mAudioHwDevs.add(handle, <span class="keyword">new</span> AudioHwDevice(handle, name, dev, flags));</div><div class="line"></div><div class="line">    ALOGI(<span class="string">"loadHwModule() Loaded %s audio interface, handle %d"</span>, name, handle);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> handle;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>mDevicesFactoryHal-&gt;openDevice(name, &amp;dev),从前面AudioFlinger的启动，我们知道mDevicesFactoryHal是HAL进程的客户端，对于Android 8.0加载HAL so文件已经移到HAL进程中，不再与audioserver处于同一个进程中。在AudioFlinger中使用AudioHwDevice代表HW Module，AudioHwDevice会封装audio_module_handle_t和DeviceHalInterface，并以audio_module_handle_t为key将其保存在AudioFlinger的mAudioHwDevs中，以供后续查询。<br>到这里就加载系统的音频接口就加载完了，我们大致可以得出如下结果。<br><img src="https://i.imgur.com/ou4M7xS.png" alt=""></p><h3 id="打开音频输出"><a href="#打开音频输出" class="headerlink" title="打开音频输出"></a>打开音频输出</h3><p>这里的输出，即mixPorts中outputs，也就是mHwModules中所有OutputProfile（IOProfile），代表了音频输出流。所以会遍历mHwModules中所有OutputProfile，然后SwAudioOutputDescriptor来描述每一个output，最终保存在以audio_io_handle_t为key的mOutputs中，以供后续查询。不过这里会除了AUDIO_OUTPUT_FLAG_DIRECT，AUDIO_OUTPUT_FLAG_DIRECT的output会在使用的时候打开，不会预先open。在打开输出设备后还会标记可用输出设备的可用情况，以备后续确认可用输出设备真正可用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// open all output streams needed to access attached devices</span></div><div class="line"><span class="comment">// except for direct output streams that are only opened when they are actually</span></div><div class="line"><span class="comment">// required by an app.</span></div><div class="line"><span class="comment">// This also validates mAvailableOutputDevices list</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; mHwModules[i]-&gt;mOutputProfiles.size(); j++)</div><div class="line">&#123;</div><div class="line">     <span class="keyword">const</span> sp&lt;IOProfile&gt; outProfile = mHwModules[i]-&gt;mOutputProfiles[j];</div><div class="line">     <span class="keyword">if</span> (!outProfile-&gt;hasSupportedDevices()) &#123;</div><div class="line">         <span class="keyword">continue</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">if</span> ((outProfile-&gt;getFlags() &amp; AUDIO_OUTPUT_FLAG_TTS) != <span class="number">0</span>) &#123;</div><div class="line">         mTtsOutputAvailable = <span class="literal">true</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">if</span> ((outProfile-&gt;getFlags() &amp; AUDIO_OUTPUT_FLAG_DIRECT) != <span class="number">0</span>) &#123;</div><div class="line">         <span class="keyword">continue</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">audio_devices_t</span> profileType = outProfile-&gt;getSupportedDevicesType();</div><div class="line">     <span class="keyword">if</span> ((profileType &amp; mDefaultOutputDevice-&gt;type()) != AUDIO_DEVICE_NONE) &#123;</div><div class="line">         profileType = mDefaultOutputDevice-&gt;type();</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">         <span class="comment">// chose first device present in profile's SupportedDevices also part of</span></div><div class="line">         <span class="comment">// outputDeviceTypes</span></div><div class="line">         profileType = outProfile-&gt;getSupportedDeviceForType(outputDeviceTypes);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">if</span> ((profileType &amp; outputDeviceTypes) == <span class="number">0</span>) &#123;</div><div class="line">         <span class="keyword">continue</span>;</div><div class="line">     &#125;</div><div class="line">     sp&lt;SwAudioOutputDescriptor&gt; outputDesc = </div><div class="line">                       <span class="keyword">new</span> SwAudioOutputDescriptor(outProfile, mpClientInterface);</div><div class="line">     <span class="keyword">const</span> DeviceVector &amp;supportedDevices = outProfile-&gt;getSupportedDevices();</div><div class="line">     <span class="keyword">const</span> DeviceVector &amp;devicesForType = </div><div class="line">                           supportedDevices.getDevicesFromType(profileType);</div><div class="line">     String8 address = devicesForType.size() &gt; <span class="number">0</span> </div><div class="line">                       ? devicesForType.itemAt(<span class="number">0</span>)-&gt;mAddress : String8(<span class="string">""</span>);</div><div class="line">     outputDesc-&gt;mDevice = profileType;</div><div class="line">     <span class="keyword">audio_config_t</span> config = AUDIO_CONFIG_INITIALIZER;</div><div class="line">     config.sample_rate = outputDesc-&gt;mSamplingRate;</div><div class="line">     config.channel_mask = outputDesc-&gt;mChannelMask;</div><div class="line">     config.format = outputDesc-&gt;mFormat;</div><div class="line">     <span class="keyword">audio_io_handle_t</span> output = AUDIO_IO_HANDLE_NONE;</div><div class="line">     <span class="keyword">status_t</span> status = mpClientInterface-&gt;openOutput(outProfile-&gt;getModuleHandle(),</div><div class="line">                                                     &amp;output,</div><div class="line">                                                     &amp;config,</div><div class="line">                                                     &amp;outputDesc-&gt;mDevice,</div><div class="line">                                                     address,</div><div class="line">                                                     &amp;outputDesc-&gt;mLatency,</div><div class="line">                                                     outputDesc-&gt;mFlags);</div><div class="line">     <span class="keyword">if</span> (status != NO_ERROR) &#123;</div><div class="line">         ......</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">         outputDesc-&gt;mSamplingRate = config.sample_rate;</div><div class="line">         outputDesc-&gt;mChannelMask = config.channel_mask;</div><div class="line">         outputDesc-&gt;mFormat = config.format;</div><div class="line">         <span class="keyword">for</span> (<span class="keyword">size_t</span> k = <span class="number">0</span>; k  &lt; supportedDevices.size(); k++) &#123;</div><div class="line">              <span class="keyword">ssize_t</span> index = mAvailableOutputDevices.indexOf(supportedDevices[k]);</div><div class="line">              <span class="comment">// give a valid ID to an attached device once confirmed it is reachable</span></div><div class="line">              <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; !mAvailableOutputDevices[index]-&gt;isAttached()) &#123;</div><div class="line">                  mAvailableOutputDevices[index]-&gt;attach(mHwModules[i]);</div><div class="line">              &#125;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">if</span> (mPrimaryOutput == <span class="number">0</span> &amp;&amp;</div><div class="line">                     outProfile-&gt;getFlags() &amp; AUDIO_OUTPUT_FLAG_PRIMARY) &#123;</div><div class="line">             mPrimaryOutput = outputDesc;</div><div class="line">         &#125;</div><div class="line">         addOutput(output, outputDesc);</div><div class="line">         setOutputDevice(outputDesc,</div><div class="line">                         outputDesc-&gt;mDevice,</div><div class="line">                         <span class="literal">true</span>,</div><div class="line">                         <span class="number">0</span>,</div><div class="line">                         <span class="literal">NULL</span>,</div><div class="line">                         address.<span class="built_in">string</span>());</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们看到会使用到mpClientInterface打开输出，即调用AudioPolicyClient的openOutput，即调用<br>AudioFlinger的openOutput及openOutput_l。首先调用findSuitableHwDev_l查询合适的AudioHwDevice，即通过audio_module_handle_t在之前加载的mAudioHwDevs中去除对应的AudioHwDevice，调用AudioHwDevice的openOutputStream得到AudioStreamOut，然后根据output flag创建相应的Thread，最后以audio_io_handle_t为key将Thread保存在mPlaybackThreads和mMmapThreads。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line">sp&lt;AudioFlinger::ThreadBase&gt; AudioFlinger::openOutput_l(<span class="keyword">audio_module_handle_t</span> <span class="keyword">module</span>,</div><div class="line">                                                            <span class="keyword">audio_io_handle_t</span> *output,</div><div class="line">                                                            <span class="keyword">audio_config_t</span> *config,</div><div class="line">                                                            <span class="keyword">audio_devices_t</span> devices,</div><div class="line">                                                            <span class="keyword">const</span> String8&amp; address,</div><div class="line">                                                            <span class="keyword">audio_output_flags_t</span> flags)</div><div class="line">&#123;</div><div class="line">    AudioHwDevice *outHwDev = findSuitableHwDev_l(<span class="keyword">module</span>, devices);</div><div class="line">    <span class="keyword">if</span> (outHwDev == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (*output == AUDIO_IO_HANDLE_NONE) &#123;</div><div class="line">        *output = nextUniqueId(AUDIO_UNIQUE_ID_USE_OUTPUT);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    mHardwareStatus = AUDIO_HW_OUTPUT_OPEN;</div><div class="line">    <span class="comment">// FOR TESTING ONLY:</span></div><div class="line">    ......</div><div class="line"></div><div class="line">    AudioStreamOut *outputStream = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">status_t</span> status = outHwDev-&gt;openOutputStream(</div><div class="line">            &amp;outputStream,</div><div class="line">            *output,</div><div class="line">            devices,</div><div class="line">            flags,</div><div class="line">            config,</div><div class="line">            address.<span class="built_in">string</span>());</div><div class="line">    mHardwareStatus = AUDIO_HW_IDLE;</div><div class="line">    <span class="keyword">if</span> (status == NO_ERROR) &#123;</div><div class="line">        <span class="keyword">if</span> (flags &amp; AUDIO_OUTPUT_FLAG_MMAP_NOIRQ) &#123;</div><div class="line">            sp&lt;MmapPlaybackThread&gt; thread =</div><div class="line">                    <span class="keyword">new</span> MmapPlaybackThread(<span class="keyword">this</span>, *output, outHwDev, outputStream,</div><div class="line">                                          devices, AUDIO_DEVICE_NONE, mSystemReady);</div><div class="line">            mMmapThreads.add(*output, thread);</div><div class="line">            ALOGV(<span class="string">"openOutput_l() created mmap playback thread: ID %d thread %p"</span>,</div><div class="line">                  *output, thread.get());</div><div class="line">            <span class="keyword">return</span> thread;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            sp&lt;PlaybackThread&gt; thread;</div><div class="line">            <span class="keyword">if</span> (flags &amp; AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD) &#123;</div><div class="line">                thread = <span class="keyword">new</span> OffloadThread(<span class="keyword">this</span>, outputStream, *output, devices, mSystemReady);</div><div class="line">                ALOGV(<span class="string">"openOutput_l() created offload output: ID %d thread %p"</span>,</div><div class="line">                      *output, thread.get());</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((flags &amp; AUDIO_OUTPUT_FLAG_DIRECT)</div><div class="line">                    || !isValidPcmSinkFormat(config-&gt;format)</div><div class="line">                    || !isValidPcmSinkChannelMask(config-&gt;channel_mask)) &#123;</div><div class="line">                thread = <span class="keyword">new</span> DirectOutputThread(<span class="keyword">this</span>, outputStream, </div><div class="line">                                         *output, devices, mSystemReady);</div><div class="line">                ALOGV(<span class="string">"openOutput_l() created direct output: ID %d thread %p"</span>,</div><div class="line">                      *output, thread.get());</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                thread = <span class="keyword">new</span> MixerThread(<span class="keyword">this</span>, outputStream, *output, devices, mSystemReady);</div><div class="line">                ALOGV(<span class="string">"openOutput_l() created mixer output: ID %d thread %p"</span>,</div><div class="line">                      *output, thread.get());</div><div class="line">            &#125;</div><div class="line">            mPlaybackThreads.add(*output, thread);</div><div class="line">            <span class="keyword">return</span> thread;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">status_t</span> AudioFlinger::openOutput(<span class="keyword">audio_module_handle_t</span> <span class="keyword">module</span>,</div><div class="line">                                  <span class="keyword">audio_io_handle_t</span> *output,</div><div class="line">                                  <span class="keyword">audio_config_t</span> *config,</div><div class="line">                                  <span class="keyword">audio_devices_t</span> *devices,</div><div class="line">                                  <span class="keyword">const</span> String8&amp; address,</div><div class="line">                                  <span class="keyword">uint32_t</span> *latencyMs,</div><div class="line">                                  <span class="keyword">audio_output_flags_t</span> flags)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (devices == <span class="literal">NULL</span> || *devices == AUDIO_DEVICE_NONE) &#123;</div><div class="line">        <span class="keyword">return</span> BAD_VALUE;</div><div class="line">    &#125;</div><div class="line">    Mutex::Autolock _l(mLock);</div><div class="line">    sp&lt;ThreadBase&gt; thread = openOutput_l(<span class="keyword">module</span>, output, config, *devices, address, flags);</div><div class="line">    <span class="keyword">if</span> (thread != <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> ((flags &amp; AUDIO_OUTPUT_FLAG_MMAP_NOIRQ) == <span class="number">0</span>) &#123;</div><div class="line">            PlaybackThread *playbackThread = (PlaybackThread *)thread.get();</div><div class="line">            *latencyMs = playbackThread-&gt;latency();</div><div class="line">            <span class="comment">// notify client processes of the new output creation</span></div><div class="line">            playbackThread-&gt;ioConfigChanged(AUDIO_OUTPUT_OPENED);</div><div class="line">            <span class="comment">// the first primary output opened designates the primary hw device</span></div><div class="line">            <span class="keyword">if</span> ((mPrimaryHardwareDev == <span class="literal">NULL</span>) &amp;&amp; (flags &amp; AUDIO_OUTPUT_FLAG_PRIMARY)) &#123;</div><div class="line">                ALOGI(<span class="string">"Using module %d as the primary audio interface"</span>, <span class="keyword">module</span>);</div><div class="line">                mPrimaryHardwareDev = playbackThread-&gt;getOutput()-&gt;audioHwDev;</div><div class="line">                <span class="function">AutoMutex <span class="title">lock</span><span class="params">(mHardwareLock)</span></span>;</div><div class="line">                mHardwareStatus = AUDIO_HW_SET_MODE;</div><div class="line">                mPrimaryHardwareDev-&gt;hwDevice()-&gt;setMode(mMode);</div><div class="line">                mHardwareStatus = AUDIO_HW_IDLE;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            MmapThread *mmapThread = (MmapThread *)thread.get();</div><div class="line">            mmapThread-&gt;ioConfigChanged(AUDIO_OUTPUT_OPENED);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> NO_ERROR;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> NO_INIT;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们可以看到在AudioPolicyManager中有mOutputs以audio_io_handle_t为key保存SwAudioOutputDescriptor，而在AudioFlinger中mPlaybackThreads和mMmapThreads以audio_io_handle_t保存线程，所以我们可以得出如下关系图。<br><img src="https://i.imgur.com/K5J8Y6B.png" alt=""></p><h3 id="打开音频输入"><a href="#打开音频输入" class="headerlink" title="打开音频输入"></a>打开音频输入</h3><p>打开音频输入和打开音频输出很类似，只是将SwAudioOutputDescriptor、PlaybackThread及AudioStreamOut换成了AudioInputDescriptor、RecordThread及AudioStreamIn，这里就一笔带过。</p><h3 id="确保可用输入输出和默认输出真正可用"><a href="#确保可用输入输出和默认输出真正可用" class="headerlink" title="确保可用输入输出和默认输出真正可用"></a>确保可用输入输出和默认输出真正可用</h3><p>无其他。主要是移除不可达设备。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// make sure all attached devices have been allocated a unique ID</span></div><div class="line"><span class="comment">// 确保所有可用输出设备真正可用</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i  &lt; mAvailableOutputDevices.size();) &#123;</div><div class="line">    <span class="keyword">if</span> (!mAvailableOutputDevices[i]-&gt;isAttached()) &#123;</div><div class="line">        ALOGW(<span class="string">"Output device %08x unreachable"</span>, mAvailableOutputDevices[i]-&gt;type());</div><div class="line">        mAvailableOutputDevices.remove(mAvailableOutputDevices[i]);</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// The device is now validated and can be appended to the available </span></div><div class="line">    <span class="comment">// devices of the engine</span></div><div class="line">    <span class="comment">// 目前不做任何处理</span></div><div class="line">    mEngine-&gt;setDeviceConnectionState(mAvailableOutputDevices[i],</div><div class="line">                                      AUDIO_POLICY_DEVICE_STATE_AVAILABLE);</div><div class="line">    i++;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 确保所有可用输入设备真正可用</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i  &lt; mAvailableInputDevices.size();) &#123;</div><div class="line">    <span class="keyword">if</span> (!mAvailableInputDevices[i]-&gt;isAttached()) &#123;</div><div class="line">        ALOGW(<span class="string">"Input device %08x unreachable"</span>, mAvailableInputDevices[i]-&gt;type());</div><div class="line">        mAvailableInputDevices.remove(mAvailableInputDevices[i]);</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// The device is now validated and can be appended to the available devices of the engine</span></div><div class="line">    <span class="comment">// 目前不做任何处理</span></div><div class="line">    mEngine-&gt;setDeviceConnectionState(mAvailableInputDevices[i],</div><div class="line">                                      AUDIO_POLICY_DEVICE_STATE_AVAILABLE);</div><div class="line">    i++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// make sure default device is reachable</span></div><div class="line"><span class="comment">// 确保默认输出设备真正可用</span></div><div class="line"><span class="keyword">if</span> (mDefaultOutputDevice == <span class="number">0</span> || </div><div class="line">    mAvailableOutputDevices.indexOf(mDefaultOutputDevice) &lt; <span class="number">0</span>) &#123;</div><div class="line">    ALOGE(<span class="string">"Default device %08x is unreachable"</span>, mDefaultOutputDevice-&gt;type());</div><div class="line">&#125;</div><div class="line"></div><div class="line">ALOGE_IF((mPrimaryOutput == <span class="number">0</span>), <span class="string">"Failed to open primary output"</span>);</div><div class="line">updateDevicesAndOutputs();</div></pre></td></tr></table></figure></p><h2 id="AudioPolicyEffects初始化"><a href="#AudioPolicyEffects初始化" class="headerlink" title="AudioPolicyEffects初始化"></a>AudioPolicyEffects初始化</h2><p>对于音效策略，类似会先加载audio_effects.conf，这个文件可能位于system/etc/或者vendor/etc/。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">AudioPolicyEffects::AudioPolicyEffects()</div><div class="line">&#123;</div><div class="line">    <span class="comment">// load automatic audio effect modules</span></div><div class="line">    <span class="keyword">if</span> (access(AUDIO_EFFECT_VENDOR_CONFIG_FILE, R_OK) == <span class="number">0</span>) &#123;</div><div class="line">        loadAudioEffectConfig(AUDIO_EFFECT_VENDOR_CONFIG_FILE);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (access(AUDIO_EFFECT_DEFAULT_CONFIG_FILE, R_OK) == <span class="number">0</span>) &#123;</div><div class="line">        loadAudioEffectConfig(AUDIO_EFFECT_DEFAULT_CONFIG_FILE);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这个文件的格式如下。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"># List of effect libraries to load. Each library element must contain a <span class="string">"path"</span> element</div><div class="line"><span class="meta"># giving the full path of the library .so file.</span></div><div class="line"><span class="meta">#    libraries &#123;</span></div><div class="line">#        &lt;lib name&gt; &#123;</div><div class="line"><span class="meta">#          path <span class="meta-string">&lt;lib path&gt;</span></span></div><div class="line">#        &#125;</div><div class="line">#    &#125;</div><div class="line"><span class="meta"># list of effects to load. Each effect element must contain a <span class="meta-string">"library"</span> and a <span class="meta-string">"uuid"</span> element.</span></div><div class="line"># The value of the <span class="string">"library"</span> element must correspond to the name of one library element in the</div><div class="line"># <span class="string">"libraries"</span> element.</div><div class="line"># The name of the effect element is indicative, only the value of the <span class="string">"uuid"</span> element</div><div class="line"><span class="meta"># designates the effect.</span></div><div class="line"># The uuid is the implementation specific UUID as specified by the effect vendor. This is <span class="keyword">not</span> the</div><div class="line"><span class="meta"># generic effect type UUID.</span></div><div class="line"><span class="meta">#    effects &#123;</span></div><div class="line">#        &lt;fx name&gt; &#123;</div><div class="line"><span class="meta">#            library <span class="meta-string">&lt;lib name&gt;</span></span></div><div class="line"><span class="meta">#            uuid <span class="meta-string">&lt;effect uuid&gt;</span></span></div><div class="line">#        &#125;</div><div class="line">#        ...</div><div class="line">#    &#125;</div></pre></td></tr></table></figure></p><p>到这里AudioPolicyService的启动流程已经完结，且篇幅已经挺长，其他的知识点，学习到时再补上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AudioPolicyService在Audio系统另一个重要的服务，是音频策略的制定者，负责音频设备切换的策略抉择、音量调节策略等。本文基于Android 8.0的代码，记录了AudioPolicyService启动的过程，介绍了其中几个比较关键的点，希望以后自己看到此文
      
    
    </summary>
    
      <category term="Android Audio" scheme="http://yoursite.com/categories/Android-Audio/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>AudioFlinger启动过程</title>
    <link href="http://yoursite.com/2017/11/09/AudioFlinger%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/11/09/AudioFlinger启动过程/</id>
    <published>2017-11-09T07:58:02.000Z</published>
    <updated>2017-11-21T12:16:09.589Z</updated>
    
    <content type="html"><![CDATA[<p>AudioFlinger以media.audio_flinger为名注册到ServiceManager，是Android Audio系统的一个核心服务，是音频策略的执行者，负责输入输出流设备的管理及音频流数据的处理传输。本文以Android 8.0的代码为基础，记录了其启动过程以及AudioFlinger主要类的关系。其代码位于frameworks/av/services/audioflinger。</p><h2 id="AudioFlinger的启动过程"><a href="#AudioFlinger的启动过程" class="headerlink" title="AudioFlinger的启动过程"></a>AudioFlinger的启动过程</h2><p>Android 8.0中与7.0相比，在初始化过程中，主要是实例化了mDevicesFactoryHal和mEffectsFactoryHal，作为HAL进程的客户端与HAL进程交互。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">AudioFlinger::AudioFlinger()</div><div class="line">    <span class="comment">//变量初始化</span></div><div class="line">    : BnAudioFlinger(),</div><div class="line">      mMediaLogNotifier(<span class="keyword">new</span> AudioFlinger::MediaLogNotifier()),</div><div class="line">      mPrimaryHardwareDev(<span class="literal">NULL</span>),</div><div class="line">      mAudioHwDevs(<span class="literal">NULL</span>),</div><div class="line">      mHardwareStatus(AUDIO_HW_IDLE),</div><div class="line">      mMasterVolume(<span class="number">1.0f</span>),</div><div class="line">      mMasterMute(<span class="literal">false</span>),</div><div class="line">      <span class="comment">// mNextUniqueId(AUDIO_UNIQUE_ID_USE_MAX),</span></div><div class="line">      mMode(AUDIO_MODE_INVALID),</div><div class="line">      mBtNrecIsOff(<span class="literal">false</span>),</div><div class="line">      mIsLowRamDevice(<span class="literal">true</span>),</div><div class="line">      mIsDeviceTypeKnown(<span class="literal">false</span>),</div><div class="line">      mGlobalEffectEnableTime(<span class="number">0</span>),</div><div class="line">      mSystemReady(<span class="literal">false</span>)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line"></div><div class="line">    mDevicesFactoryHal = DevicesFactoryHalInterface::create();</div><div class="line">    mEffectsFactoryHal = EffectsFactoryHalInterface::create();</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里我们主要看一下DevicesFactoryHalInterface关系图。EffectsFactoryHalInterface也是类似的情况。<br><img src="https://i.imgur.com/urJudFp.png" alt=""><br>阅读每个类的代码实现，我们发现只有DevicesFactoryHalHybrid实现了DevicesFactoryHalInterface接口的create()函数，所以这里会创建DevicesFactoryHalHybrid实例，而DevicesFactoryHalHybrid会创建DevicesFactoryHalLocal和DevicesFactoryHalHidl实例。DevicesFactoryHalLocal用于直接加载HAL的lib，是为了兼容8.0之前的版本，而DevicesFactoryHalHidl通过binder通信从hwservicemanager中返回IDevicesFactory实例，通过IDevicesFactory的openDevice函数返回具体的Device，并且用DeviceHalHidl封装返回的Device，这里不再会直接加载HAL的lib，后续和HAL的通信完全通过IDevicesFactory接口，具体在AudioPolicyService加载HW module时会更清楚明白。</p><p>第一次初始化还会执行onFirstRef()，创建PatchPanel实例且将AudioFlinger实例传入PatchPanel，设置Audio Mode为AUDIO_MODE_NORMAL,并将自己保存在全局变量gAudioFlinger。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> AudioFlinger::onFirstRef()</div><div class="line">&#123;</div><div class="line">    Mutex::Autolock _l(mLock);</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">    mPatchPanel = <span class="keyword">new</span> PatchPanel(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    mMode = AUDIO_MODE_NORMAL;</div><div class="line"></div><div class="line">    gAudioFlinger = <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Mutex是互斥类，用于多线程访问同一个资源的时候，保证一次只有一个线程能访问该资源。它的工作原理是某一个线程要访问公共资源的时候先锁定这个Mutex，完成操作之后对Mutex解锁，在此期间如果有其它的线程也要访问公共资源，它就先要去锁Mutex，当它发现Mutex已经被锁住了，那么这个线程就是阻塞在那儿。等Mutex解锁之后所有阻塞在Mutex的线程都会醒来，只有第一个醒来的会抢到Mutex，其它没有抢到的发现自己晚了一步，只能继续阻塞在那儿，等待下次机会。Mutex源码位置/system/core/libutils/include/utils。</p><p>为了简化一般的Mutex操作，在class Mutex中定义了一个内部类Autolock，它利用{}作用域实现自动解锁，看一下它的构造函数就知道了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Autolock</span> &#123;</span></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        inline explicit Autolock(Mutex&amp; mutex) : mLock(mutex)  &#123; mLock.lock(); &#125;</div><div class="line">        inline explicit Autolock(Mutex* mutex) : mLock(*mutex) &#123; mLock.lock(); &#125;</div><div class="line">        <span class="keyword">inline</span> ~Autolock() &#123; mLock.unlock(); &#125;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        Mutex&amp; mLock;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>我们知道在{}中创建的变量，变开这个大括号时就要销毁，于是就自动调用析构函数了。</p><h2 id="AudioFlinger中放音录音线程"><a href="#AudioFlinger中放音录音线程" class="headerlink" title="AudioFlinger中放音录音线程"></a>AudioFlinger中放音录音线程</h2><p>AudioFlinger作为音频的核心服务，主要责任是负责放音与录音，下面我们可以大致看看放音与录音线程的关系，在AudioPolicyServic启动过程中我们会看到这些线程的创建。<br><img src="https://i.imgur.com/FiwGgwV.png" alt=""></p><ul><li>ThreadBase：ThreadBase以Thread为基类，而又是PlaybackThread、RecordThread和MmapThread的基类。</li><li>RecordThread：音频录音线程，负责音频的录音，没有子类。</li><li>PlaybackThread：代表放音线程，有两个直接子类MixerThread和DirectOutputThread。</li><li>MixerThread：混音放音线程，有子类DuplicatingThread，负责处理标识为<br>AUDIO_OUTPUT_FLAG_PRIMARY、AUDIO_OUTPUT_FLAG_FAST、AUDIO_OUTPUT_FLAG_DEEP_BUFFER的音频流，MixerThread 可以把多个音轨的数据混音后再输出。</li><li>DirectOutputThread：直接输出放音线程，有子类OffloadThread，负责处理标识为AUDIO_OUTPUT_FLAG_DIRECT的音频流，这种音频流数据不需要软件混音，直接输出到音频设备即可。</li><li>DuplicatingThread：复制输出放音线程，负责复制音频流数据到其他输出设备，使用场景如主声卡设备、蓝牙耳机设备、USB声卡设备同时输出。</li><li>OffloadThread：硬解回放线程，负责处理标识为AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD的音频流，这种音频流未经软件解码的（一般是MP3、AAC等格式的数据），需要输出到硬件解码器，由硬件解码器解码成PCM 数据。</li><li>MmapThread：这个线程是Android 8.0新加入的，用于低延迟的放音与录音，与AAudio有关系，有MmapPlaybackThread和MmapCaptureThread两个子类。</li><li>MmapPlaybackThread：MMAP放音线程，负责处理标识为AUDIO_OUTPUT_FLAG_MMAP_NOIRQ的音频流。</li><li>MmapcaptureThread：MMAP录音线程，负责处理标识为AUDIO_INPUT_FLAG_MMAP_NOIRQ的音频流。<h2 id="AudioFlinger中Tracks"><a href="#AudioFlinger中Tracks" class="headerlink" title="AudioFlinger中Tracks"></a>AudioFlinger中Tracks</h2>Track：音轨，是AudioFlinger中另一个重要的将角色，下面我们可以看看其关系。<br><img src="https://i.imgur.com/HHP2bZp.png" alt=""><br>对于播放对应Track，OutputTrack，TrackHandle及BnAudioTrack，TrackHandle和BnAudioTrack主要用于和Client端Binder通信，真正代表输出音轨的为Track。同样对应录音音轨的是RecordTrack，RecordHandle及BnAudioRecord，RecordHandle和BnAudioRecord也用于Binder通信，真正录音音轨为RecordTrack。而对于MmapTrack稍微不太样，而是定义通用接口MmapStreamInterface封装MmapThread，再封装MmapTrack，不是通过XXXHandle继承BnXXX，这也许是出于latency上的考虑。<h2 id="AudioFlinger中的Streams"><a href="#AudioFlinger中的Streams" class="headerlink" title="AudioFlinger中的Streams"></a>AudioFlinger中的Streams</h2>我们看到在AudioFlinger中以AudioHwDevice封装HAL的DeviceHalHidl，而DeviceHalHidl封装从HAL返回的具体的Device，这就和HAL层的so文件连接在一起，且AudioHwDevice直接或间接依赖AudioStreamOut和AudioStreanIn这样也和HAL层中stream关联上，后续打开音频输入输出以及打开输入音频流及输出音频流做好准备。具体我们可以在AudioPolicyService启动的时候看的更清楚。<br><img src="https://i.imgur.com/bIsUSZO.png" alt=""><br>AudioFlinger中还有很多其他的知识点，后续学到时再慢慢补上。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AudioFlinger以media.audio_flinger为名注册到ServiceManager，是Android Audio系统的一个核心服务，是音频策略的执行者，负责输入输出流设备的管理及音频流数据的处理传输。本文以Android 8.0的代码为基础，记录了其启动
      
    
    </summary>
    
      <category term="Android Audio" scheme="http://yoursite.com/categories/Android-Audio/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Audio Server启动</title>
    <link href="http://yoursite.com/2017/11/08/Android-Audio-Server%E5%90%AF%E5%8A%A8/"/>
    <id>http://yoursite.com/2017/11/08/Android-Audio-Server启动/</id>
    <published>2017-11-08T02:44:20.000Z</published>
    <updated>2017-11-19T09:55:49.540Z</updated>
    
    <content type="html"><![CDATA[<p>Android audioserver是Audio系统native的服务，也是连接Audio Framework和Audio HAL的一个纽带，其中包含了AudioFlinger、AudioPolicyService、AAudioService、RadioService、SoundTriggerHwService等服务。源代码位于frameworks/av/media/audioserver</p><p>从Android 7.0开始，Audio相关的service从mediaserver中转移到audioserver，把audio，camera及mediaplayerservice做了一个拆分，这样不会显得臃肿、职能更加独立且安全性更高。拆分之后audioserver还是一个native service，还是从init进程中启动，如下是其在audioserver.rc中的启动代码。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">service audioserver /system/bin/audioserver</div><div class="line">    class main                                   <span class="comment"># audioserver和class main行为一致</span></div><div class="line">    user audioserver                             <span class="comment"># 用户归属，uid：AID_AUDIOSERVER</span></div><div class="line">    <span class="comment"># media gid needed for /dev/fm (radio) and for /data/misc/media (tee)</span></div><div class="line">    group audio camera drmrpc inet media mediadrm net_bt \</div><div class="line">          net_bt_admin net_bw_acct oem_2901                         <span class="comment"># 用户组归属</span></div><div class="line">    ioprio rt 4                                                     <span class="comment"># io调度优先级</span></div><div class="line">    <span class="comment"># 当子进程被创建的时候，将子进程的pid写入到给定的文件中,cgroup/cpuset用法</span></div><div class="line">    writepid /dev/cpuset/foreground/tasks /dev/stune/foreground/tasks                </div><div class="line">    onrestart restart audio-hal-2-0                     <span class="comment"># audioserver重启会重启hal</span></div></pre></td></tr></table></figure><p>我们看到Android 8.0当重启audioserver时，会重启audio-hal-2-0，这个服务是audio hal的服务，在android 8.0中，framework native进程与hal分离，hal不在和framework native处于同一个进程，而是独立进程，进程间通过binder通信。先不讲HAL binder化，我们先看看audioserver中包含哪几个服务。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc __unused, <span class="keyword">char</span> **argv)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">   signal(SIGPIPE, SIG_IGN);</div><div class="line"></div><div class="line">   <span class="keyword">bool</span> doLog = (<span class="keyword">bool</span>) property_get_bool(<span class="string">"ro.test_harness"</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">   <span class="keyword">pid_t</span> childPid;</div><div class="line"></div><div class="line">   ......</div><div class="line"></div><div class="line">   <span class="keyword">if</span> (doLog &amp;&amp; (childPid = fork()) != <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">      ......</div><div class="line"></div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">      sp&lt;ProcessState&gt; proc(ProcessState::self());</div><div class="line">      sp&lt;IServiceManager&gt; sm = defaultServiceManager();</div><div class="line">      ALOGI(<span class="string">"ServiceManager: %p"</span>, sm.get());</div><div class="line">      AudioFlinger::instantiate();</div><div class="line">      AudioPolicyService::instantiate();</div><div class="line">      AAudioService::instantiate();</div><div class="line">      RadioService::instantiate();</div><div class="line">      SoundTriggerHwService::instantiate();</div><div class="line"></div><div class="line">      ProcessState::self()-&gt;startThreadPool();</div><div class="line"></div><div class="line"><span class="comment">// <span class="doctag">FIXME:</span> remove when BUG 31748996 is fixed</span></div><div class="line">      android::hardware::ProcessState::self()-&gt;startThreadPool();</div><div class="line"></div><div class="line">      IPCThreadState::self()-&gt;joinThreadPool();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>从如上代码可以看出，audioserver中回依次执行AudioFlinger、AudioPolicyService、AAudioService、RadioService、SoundTriggerHwService的instantiate函数。通过阅读源代码，由于继承的缘故这个五个service最终会调用BinderService的instantiate函数且将自己注册到ServiceManager中，后续client端可以通过service注册时用的name从ServiceManager返回server端。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> SERVICE&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinderService</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> status_t <span class="title">publish</span><span class="params">(<span class="keyword">bool</span> allowIsolated = <span class="literal">false</span>)</span> </span>&#123;</div><div class="line">        sp&lt;IServiceManager&gt; sm(defaultServiceManager());</div><div class="line">        <span class="keyword">return</span> sm-&gt;addService(</div><div class="line">                String16(SERVICE::getServiceName()),</div><div class="line">                <span class="keyword">new</span> SERVICE(), allowIsolated);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publishAndJoinThreadPool</span><span class="params">(<span class="keyword">bool</span> allowIsolated = <span class="literal">false</span>)</span> </span>&#123;</div><div class="line">        publish(allowIsolated);</div><div class="line">        joinThreadPool();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">instantiate</span><span class="params">()</span> </span>&#123; publish(); &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> status_t <span class="title">shutdown</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> NO_ERROR; &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">joinThreadPool</span><span class="params">()</span> </span>&#123;</div><div class="line">        sp&lt;ProcessState&gt; ps(ProcessState::self());</div><div class="line">        ps-&gt;startThreadPool();</div><div class="line">        ps-&gt;giveThreadPoolName();</div><div class="line">        IPCThreadState::self()-&gt;joinThreadPool();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>AudioFlinger（media.audio_flinger）：Audio系统的一个核心服务，是音频策略的执行者，负责输入输出流设备的管理及音频流数据的处理传输。</p><p>AudioPolicyService（media.audio_policy）：音频策略的制定者，负责音频设备切换的策略抉择、音量调节策略等。</p><p>AAudioService（media.aaudio）：这是Android 8.0加入角色，是OpenSL ES的另外一种选择，需要低延迟的高性能音频应用的另外一种选择。</p><p>RadioService（media.radio）：与FM相关的一个服务。</p><p>SoundTriggerHwService（media.sound_trigger_hw）：Android语音识别的native服务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android audioserver是Audio系统native的服务，也是连接Audio Framework和Audio HAL的一个纽带，其中包含了AudioFlinger、AudioPolicyService、AAudioService、RadioService、S
      
    
    </summary>
    
      <category term="Android Audio" scheme="http://yoursite.com/categories/Android-Audio/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>GitHub搭建个人的博客</title>
    <link href="http://yoursite.com/2017/10/30/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2017/10/30/GitHub搭建自己的博客/</id>
    <published>2017-10-30T09:34:27.481Z</published>
    <updated>2017-11-19T09:52:02.501Z</updated>
    
    <content type="html"><![CDATA[<p>最近突然间发现，自己过去看过的东西，没过多久就忘得一干二净，每当要用时，又得从头来一遍，真是好记性不如烂笔头，所以有了写笔记的想法，GitHub上可以方便记录自己一切想记录的，于是就在GitHub上开始写笔记，希望自己不要把知识忘得太快。本文记录在Windows环境下使用Hexo搭建GitHub博客的过程。</p><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>在nodejs官网下载对应的版本安装<br>下载地址：<a href="https://nodejs.org/en/download" target="_blank" rel="external">https://nodejs.org/en/download</a></p><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>下载地址：<a href="https://git-for-windows.github.io" target="_blank" rel="external">https://git-for-windows.github.io</a></p><h2 id="创建GitHub账户"><a href="#创建GitHub账户" class="headerlink" title="创建GitHub账户"></a>创建GitHub账户</h2><p>进入GitHub主页<a href="https://github.com/" target="_blank" rel="external">https://github.com/</a>，依次输入用户名、邮箱、密码，然后点击注册，按默认点击“Finish sign up”。然后进行邮箱验证。</p><h2 id="创建GitHub仓库"><a href="#创建GitHub仓库" class="headerlink" title="创建GitHub仓库"></a>创建GitHub仓库</h2><p>点击“New repository”，新建一个仓库，仓库名为“[yourname].github.io”，这样<a href="https://[yourname].github.io" target="_blank" rel="external">https://[yourname].github.io</a> 就是你的博客地址了。默认这仓库只有master分支，新建一个hexo分支。</p><h2 id="配置Hexo"><a href="#配置Hexo" class="headerlink" title="配置Hexo"></a>配置Hexo</h2><p>接下来的命令都在Git Bash中执行。</p><p>在自己喜欢的位置新建一个blog文件夹，在这个文件夹下打开Git Bash，因为npm是国外服务器，可能执行比较慢，可以使用淘宝镜像，命令如下：</p><pre><code>$ npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>执行成功后使用淘宝NPM安装Hexo</p><pre><code>$ cnpm install -g hexo-cli$ cnmp install hexo --save$ hexo -vhexo: 3.4.0hexo-cli: 1.0.4os: Windows_NT 6.1.7600 win32 ia32http_parser: 2.7.0node: 8.7.0v8: 6.1.534.42uv: 1.15.0zlib: 1.2.11ares: 1.10.1-DEVmodules: 57nghttp2: 1.25.0openssl: 1.0.2licu: 59.1unicode: 9.0cldr: 31.0.1tz: 2017b</code></pre><p>到这里hexo已经安装好了</p><h2 id="配置ssh-key"><a href="#配置ssh-key" class="headerlink" title="配置ssh key"></a>配置ssh key</h2><pre><code>ssh-keygen -t rsa -C &quot;Github的注册邮箱地址&quot;</code></pre><p>在C:\Users\yourname\.ssh下会得到密钥id_rsa和id_rsa.pub，用nodepad++打开id_rsa.pub复制全文，打开<a href="https://github.com/settings/ssh" target="_blank" rel="external">https://github.com/settings/ssh</a>，Add SSH key，粘贴进去保存。 </p><p>测试是否配置成功</p><pre><code>$ ssh -T git@github.comHi [yourname]! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</code></pre><h2 id="配置git信息"><a href="#配置git信息" class="headerlink" title="配置git信息"></a>配置git信息</h2><pre><code>$ git config --global user.name &quot;你的用户名&quot;$ git config --global user.email &quot;你的邮箱&quot;</code></pre><h2 id="使用Hexo管理博客"><a href="#使用Hexo管理博客" class="headerlink" title="使用Hexo管理博客"></a>使用Hexo管理博客</h2><h3 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h3><pre><code>$ hexo init &lt;nodejs-hexo&gt; //初始化nodejs-hexo（文件夹名随意）$ git clone -b hexo https://github.com/[yourname]/[yourname].github.io</code></pre><p>将[yourname].github.io文件夹下的.git文件夹拷贝到nodejs-hexo文件夹。</p><pre><code>$ cnpm install //安装生成器$ hexo server //运行（Ctrl + C停止运行）</code></pre><p>在浏览器输入localhost:4000，这样就可以在本地看到博客了。</p><h3 id="配置博客"><a href="#配置博客" class="headerlink" title="配置博客"></a>配置博客</h3><p>_config.yml中配置基本信息</p><pre><code>title: #博客标题subtitle: #博客副标题description: #博客描述author: #博客作者language: zh-Hanstimezone: Asia/Shanghai</code></pre><p>_config.yml中配置主题</p><pre><code>theme: next</code></pre><p>_config.yml中配置部署</p><pre><code>deploy:  type: git  repo: https://github.com/[yourname]/[yourname].github.io  branch: master</code></pre><p>注意：这里的设置冒号后面必须有空格</p><h3 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h3><pre><code>$ hexo new &quot;博客名&quot; //增加新文章$ cnpm install hexo-deployer-git --save //安装hexo git插件$ git add .$ git commit -m &quot;message&quot;$ git push origin hexo$ hexo generate //生成静态文件$ hexo deploy   //部署</code></pre><h3 id="换PC管理博客"><a href="#换PC管理博客" class="headerlink" title="换PC管理博客"></a>换PC管理博客</h3><pre><code>$ git clone -b hexo https://github.com/[yourname]/[yourname].github.io</code></pre><p>在[yourname].github.io中从新安装hexo，就可以写博客及发布博客了。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>Next主题配置参考：<a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="external">http://theme-next.iissnan.com/theme-settings.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近突然间发现，自己过去看过的东西，没过多久就忘得一干二净，每当要用时，又得从头来一遍，真是好记性不如烂笔头，所以有了写笔记的想法，GitHub上可以方便记录自己一切想记录的，于是就在GitHub上开始写笔记，希望自己不要把知识忘得太快。本文记录在Windows环境下使用H
      
    
    </summary>
    
      <category term="搭建博客" scheme="http://yoursite.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
  </entry>
  
</feed>
