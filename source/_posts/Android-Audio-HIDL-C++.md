---
title: Android Audio HIDL C++
date: 2017-11-24 09:01:24
tags: Android
categories: Android Audio HAL
---
HAL接口定义语言（简称HIDL，发音为“hide-l”）是用于指定HAL和其用户之间的接口的一种接口描述语言 (IDL)。HIDL允许指定类型和方法调用（会汇集到接口和软件包中）。从更广泛的意义上来说，HIDL是用于在可以独立编译的代码库之间进行通信的系统。

HIDL旨在用于进程间通信 (IPC)。进程之间的通信经过Binder化。对于必须与进程相关联的代码库，还可以使用直通模式（在Java中不受支持）。

HIDL可指定数据结构和方法签名，这些内容会整理归类到接口（与类相似）中，而接口会汇集到软件包中。尽管HIDL具有一系列不同的关键字，但C++和Java程序员对HIDL的语法并不陌生。此外，HIDL还使用Java样式的注释。
## HAL分类
为了更好地实现模块化，Android 8.0对Android操作系统底层进行了重新架构。作为此变化的一部分，运行 Android 8.0的设备必须支持绑定式或直通式HAL：

- **绑定式HAL**：以HAL接口定义语言 (HIDL) 表示的HAL。这些HAL取代了早期 Android 版本中使用的传统 HAL和旧版HAL。在绑定式HAL中，Android框架和HAL之间通过Binder进程间通信 (IPC) 调用进行通信。所有在推出时即搭载了Android 8.0或后续版本的设备都必须只支持绑定式HAL。
- **直通式HAL**：以HIDL封装的传统HAL或旧版HAL。这些HAL封装了现有的HAL，可在绑定模式和 Same-Process（直通）模式下使用。升级到 Android 8.0 的设备可以使用直通式HAL。

## HAL的发展历程
HIDL接口具有客户端和服务器实现：
- HIDL接口的客户端实现是指通过在该接口上调用方法来使用该接口的代码。
- 服务器实现是指HIDL接口的实现，它可接收来自客户端的调用并返回结果（如有必要）。

在从libhardware HAL转换为HIDL HAL的过程中，HAL实现成为服务器，而调用HAL的进程则成为客户端。默认实现可提供直通和绑定式HAL，并可能会随着时间而发生变化：
![](https://i.imgur.com/j26sMR2.png)
## Audio HIDL客户端和服务端
### 客户端创建
libaudioflinger.so会依赖libaudiohal.so
```sh
LOCAL_SHARED_LIBRARIES += \
    libaudiohal
```
libaudiohal.so依赖android.hardware.audio@2.0.so
```sh
LOCAL_SHARED_LIBRARIES += \
    android.hardware.audio@2.0
```
记得在AudioFlinger的启动过程中，在创建libaudiohal的DevicesFactoryHalHidl时有如下以一段代码，这里就是创建Audio HIDL的客户端。
```cpp
#include <android/hardware/audio/2.0/IDevicesFactory.h>

DevicesFactoryHalHidl::DevicesFactoryHalHidl() {
    mDevicesFactory = IDevicesFactory::getService();
    ......
}
```
### 服务端创建
生成可执行文件android.hardware.audio@2.0-service代表服务端，同样依赖于android.hardware.audio@2.0
```sh
LOCAL_MODULE := android.hardware.audio@2.0-service
LOCAL_SHARED_LIBRARIES += \
    android.hardware.audio@2.0
```
为了让HAL在直通模式下发挥作用（对于旧版设备），您必须具有HIDL_FETCH_IModuleName 函数（位于/system/lib(64)?/hw/android.hardware.package@3.0-impl(-$OPTIONAL_IDENTIFIER).so下），其中$OPTIONAL_IDENTIFIER是一个标识直通实现的字符串。比如对于Audio,在android.hardware.audio@2.0-impl.so中：
```cpp
IDevicesFactory* HIDL_FETCH_IDevicesFactory(const char* /* name */) {
    return new DevicesFactory();
}
```
接下来，使用功能填写存根并设置守护进程。守护进程代码（支持直通）示例：
```cpp
#include <hidl/LegacySupport.h>

int main(int /* argc */, char* /* argv */ []) {
    status = registerPassthroughServiceImplementation<IDevicesFactory>();
}
```
registerPassthroughServiceImplementation将对提供的-impl库执行dlopen()操作，并将其作为绑定式服务提供。守护进程代码（对于纯绑定式服务）示例：
```cpp
int main(int /* argc */, char* /* argv */ []) {
    Nfc nfc = new Nfc();
    nfc->registerAsService();
}
```
此守护进程应该存在于$PACKAGE + "-service"（例如android.hardware.audio@2.0-service）中。HAL的特定类的sepolicy是属性hal_<module>（例如 hal_audio))。您必须将此属性应用到运行特定HAL 的守护进程（如果同一进程提供多个HAL，则可以将多个属性应用到该进程）。
## Audio HIDL接口软件包
HIDL接口软件包位于hardware/interfaces或vendor/目录下（少数例外情况除外）。hardware/interfaces顶层会直接映射到android.hardware软件包命名空间；版本是软件包（而不是接口）命名空间下的子目录。

hidl-gen编译器会将.hal文件编译成一组.h和.cpp文件。这些自动生成的文件可用来编译客户端/服务器实现链接到的共享库。用于编译此共享库的Android.bp文件由hardware/interfaces/update-makefiles.sh 脚本自动生成。每次将新软件包添加到hardware/interfaces或在现有软件包中添加/移除.hal文件时，您都必须重新运行该脚本，以确保生成的共享库是最新的。

### Auido HIDL接口定义
对于Audio，.hal文件位于hardware/interfaces/audio/2.0下，我们看看客户端和服务端同时使用的IDevicesFactory接口，该定义在IDevicesFactory.hal中。
```cpp
package android.hardware.audio@2.0;

import android.hardware.audio.common@2.0;
import IDevice;

interface IDevicesFactory {
    typedef android.hardware.audio@2.0::Result Result;

    enum Device : int32_t {
        PRIMARY,
        A2DP,
        USB,
        R_SUBMIX,
        STUB
    };

    /**
     * Opens an audio device. To close the device, it is necessary to release
     * references to the returned device object.
     *
     * @param device device type.
     * @return retval operation completion status. Returns INVALID_ARGUMENTS
     *         if there is no corresponding hardware module found,
     *         NOT_INITIALIZED if an error occured while opening the hardware
     *         module.
     * @return result the interface for the created device.
     */
    openDevice(Device device) generates (Result retval, IDevice result);
};
```
### HIDL接口转化为cpp
如下是编译android.hardware.audio@2.0的Android.bp,由hidl-gen自动产生，不能手动编辑。IDevicesFactory.hal会生成DevicesFactoryAll.cpp，及IDevicesFactory.h，IHwDevicesFactory.h，BnHwDevicesFactory.h，BpHwDevicesFactory.h，BsDevicesFactory.h。
生成的.h位于out/soong/.intermediates/hardware/interfaces/audio/2.0/android.hardware.audio@2.0_genc++_headers，
生成的.cpp文件位于out/soong/.intermediates/hardware/interfaces/audio/2.0/android.hardware.audio@2.0_genc++。
```cpp
// This file is autogenerated by hidl-gen. Do not edit manually.
filegroup {
    name: "android.hardware.audio@2.0_hal",
    srcs: [
        "types.hal",
        "IDevice.hal",
        "IDevicesFactory.hal",
        "IPrimaryDevice.hal",
        "IStream.hal",
        "IStreamIn.hal",
        "IStreamOut.hal",
        "IStreamOutCallback.hal",
    ],
}
genrule {
    name: "android.hardware.audio@2.0_genc++",
    tools: ["hidl-gen"],
    cmd: "$(location hidl-gen) -o $(genDir) -Lc++-sources 
         -randroid.hardware:hardware/interfaces 
         -randroid.hidl:system/libhidl/transport 
         android.hardware.audio@2.0",
    srcs: [
        ":android.hardware.audio@2.0_hal",
    ],
    out: [
        "android/hardware/audio/2.0/types.cpp",
        "android/hardware/audio/2.0/DeviceAll.cpp",
        "android/hardware/audio/2.0/DevicesFactoryAll.cpp",
        "android/hardware/audio/2.0/PrimaryDeviceAll.cpp",
        "android/hardware/audio/2.0/StreamAll.cpp",
        "android/hardware/audio/2.0/StreamInAll.cpp",
        "android/hardware/audio/2.0/StreamOutAll.cpp",
        "android/hardware/audio/2.0/StreamOutCallbackAll.cpp",
    ],
}
genrule {
    name: "android.hardware.audio@2.0_genc++_headers",
    tools: ["hidl-gen"],
    cmd: "$(location hidl-gen) -o $(genDir) -Lc++-headers 
         -randroid.hardware:hardware/interfaces 
         -randroid.hidl:system/libhidl/transport 
         android.hardware.audio@2.0",
    srcs: [
        ":android.hardware.audio@2.0_hal",
    ],
    out: [
        "android/hardware/audio/2.0/types.h",
        "android/hardware/audio/2.0/hwtypes.h",
        "android/hardware/audio/2.0/IDevice.h",
        "android/hardware/audio/2.0/IHwDevice.h",
        "android/hardware/audio/2.0/BnHwDevice.h",
        "android/hardware/audio/2.0/BpHwDevice.h",
        "android/hardware/audio/2.0/BsDevice.h",
        "android/hardware/audio/2.0/IDevicesFactory.h",
        "android/hardware/audio/2.0/IHwDevicesFactory.h",
        "android/hardware/audio/2.0/BnHwDevicesFactory.h",
        "android/hardware/audio/2.0/BpHwDevicesFactory.h",
        "android/hardware/audio/2.0/BsDevicesFactory.h",
        "android/hardware/audio/2.0/IPrimaryDevice.h",
        "android/hardware/audio/2.0/IHwPrimaryDevice.h",
        "android/hardware/audio/2.0/BnHwPrimaryDevice.h",
        "android/hardware/audio/2.0/BpHwPrimaryDevice.h",
        "android/hardware/audio/2.0/BsPrimaryDevice.h",
        "android/hardware/audio/2.0/IStream.h",
        "android/hardware/audio/2.0/IHwStream.h",
        "android/hardware/audio/2.0/BnHwStream.h",
        "android/hardware/audio/2.0/BpHwStream.h",
        "android/hardware/audio/2.0/BsStream.h",
        "android/hardware/audio/2.0/IStreamIn.h",
        "android/hardware/audio/2.0/IHwStreamIn.h",
        "android/hardware/audio/2.0/BnHwStreamIn.h",
        "android/hardware/audio/2.0/BpHwStreamIn.h",
        "android/hardware/audio/2.0/BsStreamIn.h",
        "android/hardware/audio/2.0/IStreamOut.h",
        "android/hardware/audio/2.0/IHwStreamOut.h",
        "android/hardware/audio/2.0/BnHwStreamOut.h",
        "android/hardware/audio/2.0/BpHwStreamOut.h",
        "android/hardware/audio/2.0/BsStreamOut.h",
        "android/hardware/audio/2.0/IStreamOutCallback.h",
        "android/hardware/audio/2.0/IHwStreamOutCallback.h",
        "android/hardware/audio/2.0/BnHwStreamOutCallback.h",
        "android/hardware/audio/2.0/BpHwStreamOutCallback.h",
        "android/hardware/audio/2.0/BsStreamOutCallback.h",
    ],
}
cc_library_shared {
    name: "android.hardware.audio@2.0",
    defaults: ["hidl-module-defaults"],
    generated_sources: ["android.hardware.audio@2.0_genc++"],
    generated_headers: ["android.hardware.audio@2.0_genc++_headers"],
    export_generated_headers: ["android.hardware.audio@2.0_genc++_headers"],
    vendor_available: true,
    shared_libs: [
        "libhidlbase",
        "libhidltransport",
        "libhwbinder",
        "liblog",
        "libutils",
        "libcutils",
        "android.hardware.audio.common@2.0",
    ],
    export_shared_lib_headers: [
        "libhidlbase",
        "libhidltransport",
        "libhwbinder",
        "libutils",
        "android.hardware.audio.common@2.0",
    ],
}
```
![](https://i.imgur.com/C23pi5i.png)
- IDevicesFactory.h - 描述C++类中的纯IDevicesFactory接口；它包含IDevicesFactory.hal文件中的IDevicesFactory接口中所定义的方法和类型，必要时会转换为C++类型。不包含与用于实现此接口的RPC机制（例如HwBinder）相关的详细信息。类的命名空间包含软件包名称和版本号，例如::android::hardware::audio::V2_0::IDevicesFactory。客户端和服务器都包含此标头：客户端用它来调用方法，服务器用它来实现这些方法。
- IHwDevicesFactory.h - 头文件，其中包含用于对接口中使用的数据类型进行序列化的函数的声明。开发者不得直接包含其标头（它不包含任何类）
- BpHwDevicesFactory.h - 从IDevicesFactory继承的类，可描述接口的HwBinder代理（客户端）实现。开发者不得直接引用此类。
- BnHwDevicesFactory.h - 保存对IDevicesFactory实现的引用的类，可描述接口的HwBinder存根（服务器端）实现。开发者不得直接引用此类。
- DevicesFactoryAll.cpp - 包含HwBinder代理和HwBinder存根的实现的类。当客户端调用接口方法时，代理会自动从客户端封送参数，并将事务发送到绑定内核驱动程序，该内核驱动程序会将事务传送到另一端的存根（该存根随后会调用实际的服务器实现）
- BsDevicesFactory.h - 从IDevicesFactory继承的类，直通模式对IDevicesFactory的服务端实现。开发者不得直接引用此类。

这些文件的结构类似于由aidl-cpp生成的文件。独立于HIDL使用的RPC机制的唯一一个自动生成的文件是 IDevicesFactory.h，其他所有文件都与HIDL使用的HwBinder RPC机制相关联。因此，客户端和服务器实现不得直接引用除IDevicesFactory之外的任何内容。为了满足这项要求，请只包含IDevicesFactory.h并链接到生成的共享库。
